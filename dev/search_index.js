var documenterSearchIndex = {"docs":
[{"location":"Helmholtz.html#The-Helmholtz-module","page":"The Helmholtz module","title":"The Helmholtz module","text":"","category":"section"},{"location":"Helmholtz.html#Exported-functionality:","page":"The Helmholtz module","title":"Exported functionality:","text":"","category":"section"},{"location":"Helmholtz.html","page":"The Helmholtz module","title":"The Helmholtz module","text":"Modules = [WavesAndEigenvalues.Helmholtz]\nPrivate=false","category":"page"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz","text":"Module providing functionality to numerically discretize the (thermoacoustic) Helmholtz equation by first, second, and hermitian-order finite elements.\n\n\n\n\n\n","category":"module"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.bloch_expand","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.bloch_expand","text":"v=bloch_expand(mesh::Mesh,sol::Solution,b=:b)\n\nExpand solution vector sol.v on mesh meshwith Bloch wave number sol.params[b] and return it as v.\n\n\n\n\n\n","category":"function"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.bound_mass_normalize-NTuple{5,Any}","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.bound_mass_normalize","text":"nsens=bound_mass_normalize(surface_points,normal_vectors,tri_mask,sens)\n\nNormalize shape sensitivity with boundary mass matrix.\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.discrete_adjoint_shape_sensitivity-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any,Any,Any,Any,Any,Any,Any}","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.discrete_adjoint_shape_sensitivity","text":"sens=discrete_adjoint_shape_sensitivity(mesh::Mesh,dscrp,C,surface_points,tri_mask,tet_mask,L,sol;h=1E-9,output=true)\n\nCompute shape sensitivity of mesh mesh\n\n#Arguments\n\nmesh::Mesh: Mesh\n...\n\n#Notes The method is based on a discrete adjoint approach. The derivative of the operator with respect to a point displacement is, however, computed by central finite differences.\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.discretize-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any,Any}","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.discretize","text":"L=discretize(mesh, dscrp, C; order=:lin, b=:__none__, mass_weighting=true,source=false, output=true)\n\nDiscretize the Helmholtz equation using the mesh mesh.\n\nArguments\n\nmesh::Mesh: tetrahedral mesh\ndscrp::Dict: dictionary containing information on where to apply physical constraints. Such as standard wave propagation, boundary conditions, flame responses, etc.\nC:Array: array defining the speed of sound. If length(C)==length(mesh.tetrahedra) the speed of sound is constant along one tetrahedron. If length(C)==size(mesh.points,2) the speed of sound is linearly interpolated between the vertices of the mesh.\norder::Symbol = :lin: optional paramater to select between first (order==:lin the default), second (order==:quad),or hermitian-order (order==:herm) finite elements.\nb::Symbol=:__none__: optional parameter defining the Bloch wave number. If b=:__none__ (the default) no Blochwave formalism is applied.\nmass_weighting=true: optional parameter if true mass matrix is used as weighting matrix for householder, otherwise this matrix is not set.\nsource::Bool=false: optional parameter to toggle the return of a source vector (experimental)\n`output::Bool=false': optional parameter to toggle live progress report.\n\nReturns\n\nL::LinearOperatorFamily: parametereized discretization of the specified Helmholtz equation.\nrhs::LinearOperatorFamily: parameterized discretization of the source vector. Only returned if source==true.  (experimental)\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.normal_sensitivity-Tuple{Any,Any}","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.normal_sensitivity","text":"normal_sensitivity(normal_vectors, normed_sens)\n\nConvert surface normalized shapegradient `normedsens` to surface_normal shape sensitivity.\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.normalize_sensitivity-NTuple{4,Any}","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.normalize_sensitivity","text":"normed_sens=normalize_sensitivity(surface_points,normal_vectors,tri_mask,sens)\n\nNormalize shape sensitivity with directed area of adjacent triangles.\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#Private-functionality:","page":"The Helmholtz module","title":"Private functionality:","text":"","category":"section"},{"location":"Helmholtz.html","page":"The Helmholtz module","title":"The Helmholtz module","text":"Modules = [WavesAndEigenvalues.Helmholtz]\nPublic=false","category":"page"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.aggregate_elements","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.aggregate_elements","text":"triangles, tetrahedra, dim = aggregate_elements(mesh,el_type)\n\nAgregate lists (triangles and tetrahedra) of lists of indexed degrees of freedom for unstructured tetrahedral meshes. dim is the total number of DoF in the mesh featured by the requested element-type (el_type). Available element types are :lin for first order elements (the default), :quad for second order elements, and :herm for  Hermitian elements.\n\n\n\n\n\n","category":"function"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.get_cylindrics-Tuple{Any}","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.get_cylindrics","text":"helper function to get local cylindric basis vectors\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.get_n_grad_p","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.get_n_grad_p","text":"get_n_grad_p(mesh::Mesh,v,point,n,tet_idx::Int=0)\n\nGet directional derivative dp of teh pressure w.r.t. the direction n at point pointin solution vector v. The optional argument tet_idx accelarates finding the tetrahedron enclosing the point.\n\n\n\n\n\n","category":"function"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.get_p","page":"The Helmholtz module","title":"WavesAndEigenvalues.Helmholtz.get_p","text":"p=get_p(mesh,v,point,tet_idx=0)\n\nGet pressure value p at point pointin solution vector v. The optional argument tet_idx accelarates finding the tetrahedron enclosing the point.\n\n\n\n\n\n","category":"function"},{"location":"Meshutils.html#The-Meshutils-module","page":"The Meshutils module","title":"The Meshutils module","text":"","category":"section"},{"location":"Meshutils.html","page":"The Meshutils module","title":"The Meshutils module","text":"CurrentModule = WavesAndEigenvalues.Meshutils","category":"page"},{"location":"Meshutils.html#Exported-functionality:","page":"The Meshutils module","title":"Exported functionality:","text":"","category":"section"},{"location":"Meshutils.html","page":"The Meshutils module","title":"The Meshutils module","text":"Modules = [Meshutils]\nPrivate=false","category":"page"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils","text":"Module containing functionality to read and process tetrahedral meshes in gmsh or nastran format.\n\n\n\n\n\n","category":"module"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.Mesh","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.Mesh","text":"Definition of the mesh type\n\nFields\n\nname::String: the name of the mesh.\npoints::Array: 3×N array containing the coordinates of the N points defining the mesh.\nlines::List: List of simplices defining the edges of the mesh\ntriangles::List: List of simplices defining the surface triangles of the mesh\nint_triangles::List: List of simplices defining the interior triangles of the mesh\ntetrahedra::List: List of simplices defining the tetrahedra of the mesh\ndomains::Dict: Dictionary defining the domains of the mesh. See comments below.\nfile::String: path to the file containing the mesh.\ntri2tet::Array: Array of length length(tetrahedra) containing the indices of the connected tetrahedra.\ndos: special field meant to contain symmetry information of highly symmetric meshes.\n\nNotes\n\nThe meshes are supposed to be tetrahedral. All simplices (lines, triangles, and tetrahedra) are stored as lists of simplices. Simplices are lists of integers containing the indices of the points (i.e. the column number in the points array) forming the simplex. This means a line is a two-entry list, a triangle a three-entry list, and a tetrahedron a four-entry list. For convenience certain entities of the mesh can be further defined in the domains dictionary. Each key defines a domain and maps to another dictionary. This second-level dictionary contains at least two keys: \"dimension\" mapping to the dimension of the specified domain (1,2, or 3) and \"simplices\" containing a list of integers mapping into the respective simplex lists. More keys may be added to the dictionary to define additional and/or custom information on the domain. For instance the compute_size! function adds an entry with the domain size.\n\n\n\n\n\n","category":"type"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.Mesh-Tuple{String}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.Mesh","text":"mesh=Mesh(file_name::String; scale=1, inttris=false)\n\nread a tetrahedral mesh from gmsh or nastran file into mesh. The optional scaling factor scale may be used to scale the units of the mesh. The optional parameter inttris toggles whether triangles are sortet into two seperate lists for surface and internal triangles.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.collect_lines!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.collect_lines!","text":"collect_lines!(mesh::Mesh)\n\nPopulate the list of lines in mesh.lines.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.color_domains","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.color_domains","text":"data,surf_keys,vol_keys=color_domains(mesh::Mesh,domains=[])\n\nCreate data fields containing an integer number corresponding to the local domain.\n\nArguments\n\nmesh::Mesh: mesh to be colored\ndomains::List: (optional) list of domains that are to be colored. If empty  all domains will be colored.\n\nReturns\n\ndata::Dict: Dictionary containing a key for each colored domain plus magic keys \"__all_surfaces__\" and \"__all_volumes__\" holding all colors in one field. These magic fields may not work correctly if the domains are not disjoint.\nsurf_keys::Dict: Dictionary mapping the surface domain names to their indeces.\nvol_keys::Dict: Dictionary mapping the volume domain names to their indeces.\n\nNotes\n\nThe datavariable is designed to flawlessly work with vtk_write for visualization with paraview. Check the \"Interpret Values as Categories\" box in paraview's color map editor for optimal visualization.\n\nSee also: vtk_write\n\n\n\n\n\n","category":"function"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.compute_size!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.compute_size!","text":"compute_size!(mesh::Mesh,dom::String)\n\nCompute the size of the domain dom and store it in the field \"size\" of the domain definition. The size will be a length, area, or volume depending on the dimension of the domain.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.extend_mesh-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.extend_mesh","text":"full_mesh=extend_mesh(mesh::Mesh, doms; sym_name=\"Symmetry\", blch_name=\"Bloch\", unit=false)\n\nCreate full mesh or unit cell from half cell represented in mesh.\n\nArguments\n\nmesh::Mesh: mesh representing the half cell. The mesh must span a sector of 2π/2N, where N is the (integer) degree of symmetry of the full mesh.\ndoms::List: list of 2-tuples containing the domain names and their copy_degree (see notes below).\nsym_name::String=\"Symmetry\": name of the domain of mesh that forms the symmetry plane of the half-mesh.\nblch_name::String=\"Bloch\": name of the domain of mesh that forms the remaining azimuthal plane of the half-mesh.\nunit::Bool=false: toggle whether extend the mesh to unit cell only.\n\nReturns\n\nfull_mesh::Mesh: representation of the full mesh.\n\nNotes\n\nThe routine copies only domains that are specified  in doms. These domains are extended according to the specified copy_degree. The following are available:\n\n:full: extent the domain and save it under the same name in full_mesh.\n:unit: extent the domain and save the individual unit cells labeled from 0 to N-1 in full_mesh.\n:half: extent the domain and save the individual unit cells as half cells labeled from 0 to N-1 in full_mesh where one half-cell  contains _img in its name.\n\nMultiple styles can be mixed in one domain specification. An example for doms would be     doms=[(\"Interior\", :full), (\"Outlet\", :unit), (\"Flame\", :half)]\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point","text":"tet_idx=find_tetrahedron_containing_point(mesh::Mesh,point)\n\nFind the tetrahedron containing the point point and return the index of the tetrahedron as tet_idx. If the point lies on the interface of two or more tetrahedra, the returned tet_idx will be the lowest index of these tetrahedra, i.e. the index depends on the ordering of the tetrahedra in the mesh.tetrahedra. If no tetrahedron in the mesh encloses the point tet_idx==0.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.generate_field-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.generate_field","text":"generate_field(mesh::Mesh,func;el_type=0)\n\nGenerate field from function funcfor mesh mesh. The element type is either el_type=0 for field values associated with the mesh tetrahedra or el_type=1 for field values associated with the mesh vertices. The function must accept three input arguments corresponding to the three space dimensions.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_normal_vectors","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_normal_vectors","text":"normal_vectors=get_normal_vectors(mesh::Mesh,output::Bool=true)\n\nCompute a 3×length(mesh.triangles) Array containing the outward pointing normal vectors of each of the surface triangles of the mesh mesh. The vectors are not normalised but their norm is twice the area of the corresponding triangle. The optional parameter output toggles whether a progressbar should be shown or not.\n\n\n\n\n\n","category":"function"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_surface_points","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_surface_points","text":"surface_points, tri_mask, tet_mask = get_surface_points(mesh::Mesh,output=true)\n\nGet a list surface_points of all point indices that are on the surface of the mesh mesh. The corresponding lists tri_mask andtet_maskcontain lists of indices of all triangles and tetrahedra that are connected to the surface point. The optional parameteroutput` toggles whether a progressbar should be shown or not.\n\n\n\n\n\n","category":"function"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!","text":"link_triangles_to_tetrahedra!(mesh::Mesh)\n\nFind the tetrahedra that are connected to the triangles in mesh.triangles (and mesh.inttriangles) and store this information in mesh.tri2tet.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.octosplit-Tuple{WavesAndEigenvalues.Meshutils.Mesh}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.octosplit","text":"new_mesh=octosplit(mesh::Mesh)\n\nSubdivide each tetrahedron in the mesh mesh into 8 tetrahedra by splitting each edge at its center.\n\nNotes\n\nThe algorithm introduces length(mesh.lines) new vertices. This yields a finer mesh featuring 8*size(mesh,2) tetrahedra, 4*length(mesh.triangles) triangles, and 2*length(mesh.lines) lines. From the  3 possible subdivision of a tetrahedron the algorithm automatically chooses the one that minimizes the edge lengths of the new tetrahedra. The point labeling of new_mesh is consistent with the point labeling in mesh, i.e., the first size(mesh.points,2) points in new_mesh.points are identical to the points in mesh.points. Hence, mesh and new_mesh form a hierachy of meshes.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.unify!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String,Vararg{Any,N} where N}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.unify!","text":"unify!(mesh::Mesh ,new_domain::String,domains...)\n\nCreate union of domains and name it new_domain. domains must share the same dimension and new_domain must be a new name otherwise errors will occur.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.vtk_write","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.vtk_write","text":"vtk_write(file_name, mesh, data)\n\nWrite vtk-file containing the datavalues data given on the usntructured grid mesh.\n\nArguments\n\nfile_name::String: name given to the written files. The name will be preceeded by a specifier. See Notes below.\nmesh::Mesh: mesh associated with the data.\ndata::Dict: Dictionary containing the data.\n\nNotes\n\nThe routine automatically sorts the data according to its type and writes it in up to three diffrent files. Data that is constant on a tetrahedron goes into \"$(filename)_const.vtu\", data that is linearly interpolated on a tetrahedron goes into \"$(filename)_lin.vtu\", and data that is quadratically interpolated on a tetrahedron goes into \"$(filename)_quad.vtu\"\n\n\n\n\n\n","category":"function"},{"location":"Meshutils.html#Private-functionality:","page":"The Meshutils module","title":"Private functionality:","text":"","category":"section"},{"location":"Meshutils.html","page":"The Meshutils module","title":"The Meshutils module","text":"Modules = [Meshutils]\nPublic=false","category":"page"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.SymInfo","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.SymInfo","text":"Simple struct element to store additional information on symmetry for rotational symmetric meshes.\n\n#Fields\n\nDOS::Int64: degree of symmetry\nnaxis::Int64: number of grid points lying on the center axis\nnxbloch::Int64: number of grid points lying on the Bloch plane but not on the center axis\nnbody::Int64: number of interior points in half cell\nshiftbody::Int64: difference from body point to reflected body point\nnxsymmetry::Int64: number of grid points on symmetry plane (without center axis)\nnxsector::Int64: number of grid points belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)\nnaxis_ln::Int64: number of line segments lying on the center axis\nnxbloch_ln::Int64: number of line segments belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)\nnxsector_ln::Int64: number of line segments belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)\nnxsector_tri::Int64: number of surface triangles belonging to a unit cell (without Bloch and Bloch image plane)\nnxsector_tet::Int64: number of tetrahedra of a unit cell\nn: unit axis vector of the center axis\n`pnt: foot point of the center axis\nunit::Bool: true if mesh represents only a unit cell\n\n\n\n\n\n","category":"type"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.compare-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.compare","text":"cmpr=compare(A,B)\n\nCompare two simplices following lexicographic rules. If B has lower rank, then A cmpr ==-1. If B has higher rank than A, cmpr==1. If A and B are identical, cmpr==0.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis","text":"R = create_rotation_matrix_around_axis(n,α)\n\nCompute the rotation matrix around the directional vector nrotating by an angle α (in rad).\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular","text":"foot = find_foot_of_perpendicular(pnt,pln)\n\nCompute the position of the foot of the perpendicular from the point pnt to the plane pln.\n\nNotes\n\nCode adapted from https://www.geeksforgeeks.org/mirror-of-a-point-through-a-3-d-plane/\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes","text":"p,n = find_intersection_of_two_planes(pln1,pln2)\n\nFind a parametrization of the axis defined by the intersection of the planes pln1and pln2. The axis is parameterized by a point p and direction n.\n\nNotes\n\nThe algorithm follows John Krumm's solution for finding a common point on two intersecting planes as it is explained in https://math.stackexchange.com/questions/475953/how-to-calculate-the-intersection-of-two-planes To simplify the code, here the point p0 is the origin.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.find_smplx-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.find_smplx","text":"idx = find_smplx(list,smplx)\n\nFind index of simplex in ordered list of simplices. If the simplex is not contained in the list, the returned index is nothing\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_line_idx-NTuple{7,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_line_idx","text":"ln_idx = get_line_idx(ln,naxis_ln,nxsector_ln)\n\nGet index ln_idx of line ln  in a mesh that features naxis grid points and naxis_ln' lines on the center line,nxsectorgrid points andnxsector_ln' lines in a unit cell excluding the center axis.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_line_idx-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_line_idx","text":"ln_idx = get_line_idx(mesh::Mesh, ln)\n\nGet index ln_idx of line ln in mesh mesh.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_line_sector-Tuple{Any,Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_line_sector","text":"s = get_line_sector(ln)\n\nGet index s of sector containing line ln, in a mesh that features naxis grid points on the center line and nxsector grid points in a unit cell excluding the center axis..\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_line_sector-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_line_sector","text":"sidx = get_line_sector(mesh::Mesh, ln)\n\nGet sector idx sidxof line ln in mesh mesh.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_point_sector-Tuple{Any,Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_point_sector","text":"sector = get_point_sector(pnt_idx,naxis, nxsector)\n\nGet the sector containing point with index pnt_idx, in a mesh that features naxis grid points on the center line and nxsector grid points in a unit cell excluding the center axis.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_point_sector-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_point_sector","text":"sidx=get_point_sector(mesh::Mesh,pnt_idx)\n\nGet sector idx sidxof point with index pnt_idxin mesh mesh.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_reflected_index-NTuple{7,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_reflected_index","text":"ridx = get_reflected_index(idx,naxis,nxbloch,nbody,shiftbody,nxsymmetry)\n\nGet index ridx of a point in the first unit cell created from reflection of the point with index idx. The definig mesh feature naxis points on the center axis, nxbloch points on the bloch plane (excluding the center axis), nbody points in the interiror of the first half-cell, nxsymmetrypoints on the symmetry plane (excluding the center axis) nxsector points in a unit cell excluding the center axis. The difference of the indeces of a refernce body point and a reflected body point is shiftbody. The number of points per unit cell (excluding the center axis) is nxsector.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.get_rotated_index-NTuple{5,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.get_rotated_index","text":"ridx = get_rotated_index(idx,sector, naxis, nxsector, DOS)\n\nGet index ridx of point in sector sector created from rotation of the point with index idx. The definig mesh feature naxis points on the center axis, nxsector points in a unit cell excluding the center axis, and has a degree of symmetry DOS.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.insert_smplx!-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.insert_smplx!","text":"insert_smplx!(list,smplx)\n\nInsert simplex in ordered list of simplices.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.is_point_in_plane-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.is_point_in_plane","text":"check = is_point_in_plane(pnt, pln)\n\nCheck whether point \"pnt\" is in plane . Note that there is currently no handling of round off errors.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.make_normal_outwards-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.make_normal_outwards","text":"makenormaloutwards!(pln,testpoint)\n\nEnsure that the parameterization of the plane \"pln\" has a normal that is directed twoards testpoint. If necessary reparametrize pln.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.read_ansys-Tuple{Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.read_ansys","text":"read a mesh from ansys cfx file\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.read_msh2-Tuple{Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.read_msh2","text":"points, lines, triangles, tetrahedra, domains=read_msh2(file_name)\n\nRead gmsh's .msh-format version 2. This is an old format and wherever possible version 4 should be used.\n\nhttp://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.read_msh4-Tuple{Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.read_msh4","text":"points, lines, triangles, tetrahedra, domains=read_msh4(file_name)\n\nRead gmsh's .msh-format version 4.\n\nhttp://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.read_nastran-Tuple{Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.read_nastran","text":"points, lines, triangles, tetrahedra, domains=read_nastran(filename)\n\nRead simplicial nastran mesh.\n\nNote\n\nThere is currently no sanity check for non-simplicial elements. These elements are just skipped while reading.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.reflect_point_at_plane-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.reflect_point_at_plane","text":"p = reflect_point_at_plane(pnt,pln)\n\nReflect point pnt at plane pln and return as p.\n\nNotes\n\nCode adapted from https://www.geeksforgeeks.org/mirror-of-a-point-through-a-3-d-plane/\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.sort_smplx-Tuple{Any,Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.sort_smplx","text":"sort_smplx(list,smplx)\n\nHelper function for sorting simplices in lexicographic manner. Utilize divide an conquer strategy to find a simplex in ordered list of simpleces.\n\n\n\n\n\n","category":"method"},{"location":"Meshutils.html#WavesAndEigenvalues.Meshutils.three_points_to_plane-Tuple{Any}","page":"The Meshutils module","title":"WavesAndEigenvalues.Meshutils.three_points_to_plane","text":"pln=three_points_to_plane(A)\n\nCompute equation for a plane from the three points defined in A. The plane is parameterized as a*x+b*y+c*z+d==0 with the coefficients returned as pln=[a,b,c,d].\n\nArguments\n\nA::3×3-Array : Array containing the three points defining the plane as columns.\n\nNotes\n\nCode adapted from https://www.geeksforgeeks.org/program-to-find-equation-of-a-plane-passing-through-3-points/\n\n\n\n\n\n","category":"method"},{"location":"installation.html#Installation","page":"Install","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Install","title":"Install","text":"WavesAndEigenvalues can be installed from Julia's official package repository using the built-in package manager. Just type ] to enter the package manager and then","category":"page"},{"location":"installation.html","page":"Install","title":"Install","text":"pkg> add WavesAndEigenvalues","category":"page"},{"location":"installation.html","page":"Install","title":"Install","text":"or","category":"page"},{"location":"installation.html","page":"Install","title":"Install","text":"julia> import Pkg; Pkg.add(\"WavesAndEigenvalues\")","category":"page"},{"location":"installation.html","page":"Install","title":"Install","text":"in the REPL and you are good to go.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"EditURL = \"<unknown>/tutorial_01_rijke_tube.jl\"","category":"page"},{"location":"tutorial_01_rijke_tube.html#Tutorial-01-Rijke-Tube","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"A Rijke tube is the most simple thermo-acoustic configuration. It comprises a tube with an unsteady heat source somewhere inside the tube. This example will walk you through the basic steps of setting up a Rijke tube in a Helmholtz-solver stability analysis.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"note: Note\nThe tutorial reproduces the validation case found in [1]. To run it yourself you will need the \"Rijke_mm.msh\" file. Download it here.","category":"page"},{"location":"tutorial_01_rijke_tube.html#The-Helmholtz-equation","page":"Tutorial 01 Rijke Tube","title":"The Helmholtz equation","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The Helmholtz equation is the Fourier transform of the acoustic wave equation. Given that there is a heat source, it reads:","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"nablacdot(c^2nabla hat p) + omega^2hat p = - i omega (gamma -1)hat q","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Here c is speed-of-sound-field, hat p the (complex) pressure fluctuation amplitude omega the (complex) frequency of the problem, i the imaginary unit, gamma the ratio of specific heats, and hat q the amplitude of the heat release fluctuation.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"(Note that the Fourier transform here follows a f(t) rightarrow hat f(omega)exp(+iomega t) convention.)","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Together with some boundary conditions the Helmholtz equation models thermo-acoustic resonance in a cavity. The minimum required inputs to specify a problem are","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"the shape of the domain\nthe speed-of-sound field\nthe boundary conditions","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"In case of an active flame (hat q neq 0). We will also need","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"some additional gas properties and\na flame response model linking the heat release fluctuations hat q to the pressure fluctuations hat p","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Once you completed this tutorial you will know the basic steps of how to conduct a thermo-acoustic stability analysis","category":"page"},{"location":"tutorial_01_rijke_tube.html#Header","page":"Tutorial 01 Rijke Tube","title":"Header","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"First you will need to load the Helmholtz solver. The following line brings all necessary tools into scope:","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"using WavesAndEigenvalues.Helmholtz","category":"page"},{"location":"tutorial_01_rijke_tube.html#Mesh","page":"Tutorial 01 Rijke Tube","title":"Mesh","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Now we can load the mesh file. It is the essential piece of information defining the domain shape . This tutorial's mesh has been specified in mm which is why we scale it by 0.001 to load the coordinates as m:","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"mesh=Mesh(\"Rijke_mm.msh\",scale=0.001)","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The displayed info tells us that the mesh features 1006 points as vertices 1562 (addressable) triangles on its surface and 3380 tetrahedra forming the tube. Note, that there are currently no lines stored. This is because line information is only needed when using second-order finite elements. To save memory this information is only assembled and stored when explicitly requested. We will come back to this aspect in a later tutorial.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"You can also see that the mesh features several named domains such as \"Interior\",\"Flame\", \"Inlet\" and \"Outlet\". These domains are used to specify certain conditions for our model.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"A model descriptor is always given as a dictionary featureng domain names as keys and tuples as values. The first tuple entry is a Julia symbol specifying the operator to be build on the associated domain, while the second entry is again a tuple holding information that is specific to the chosen operator.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Model-set-up","page":"Tutorial 01 Rijke Tube","title":"Model set-up","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"For instance, we certainly want to build the wave operator on the entire mesh. So first, we initialize an empty dictionary","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"dscrp=Dict()","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"And then specify that the wave operator should be build everywhere. For the given mesh the domain-specifier to address the entire resonant cavity is \"Interior\" and in general the symbol to create the wave operator is :interior. It requires no options so the options tuple remains empty.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"dscrp[\"Interior\"]=(:interior, ())","category":"page"},{"location":"tutorial_01_rijke_tube.html#Boundary-Conditions","page":"Tutorial 01 Rijke Tube","title":"Boundary Conditions","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The tube should have a pressure node at its outlet, in order to model an open-end boundary condition. Boundary conditions are specified in terms of admittance values. A pressure note corresponds to an infinite admittance. To represent this on a computer we just give it a crazily high value like 1E15. We will also need to specify a variable name for our admittance value. This will allow to quickly change the value after discretization of the model by addressing it by this very name. This feature is one of the core concepts of the solver. As will be demonstrated later.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The complete description of our boundary condition reads","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"dscrp[\"Outlet\"]=(:admittance, (:Y,1E15))","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"You may wonder why we do not specify conditions for the other boundaries of the model. This is because the discretization is based on Bubnov-Galerkin finite elements. All unspecified, boundaries will therefore naturally be discretized as solid walls.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Flame","page":"Tutorial 01 Rijke Tube","title":"Flame","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The Rijke tube's main feature is a domain of heat release. In the current mesh there is a designated domain \"Flame\" addressing a thin volume at the center of the tube. We can use this key to specify a flame with simple n-tau-dynamics. Therefore, we first need to define some basic gas properties.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"γ=1.4 #ratio of specific heats\nρ=1.225 #density at the reference location upstream to the flame in kg/m^3\nTu=300.0    #K unburnt gas temperature\nTb=1200.0    #K burnt gas temperature\nP0=101325.0 # ambient pressure in Pa\nA=pi*0.025^2 # cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1) #the ratio of mean heat release to mean velocity Q02U0","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"We will also need to provide the position where the reference velocity has been taken and the direction of that velocity","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"x_ref=[0.0; 0.0; -0.00101]\nn_ref=[0.0; 0.0; 1.00] #must be a unit vector","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"And of course, we need some values for n and tau","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"n=0.0 #interaction index\nτ=0.001 #time delay","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"With these values the specification of the flame reads","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"dscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ))","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Note that the order of the values in the options tuple is important. Also note that we assign the symbols :nand :τ for later analysis.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Speed-of-Sound","page":"Tutorial 01 Rijke Tube","title":"Speed of Sound","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The description of the Rijke tube model is nearly complete. We just need to specify the speed of sound field.  For this example, the field is fairly simple and can be specified analytically, using the generate_field function and a custom three-parameter function.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"R=287.05 # J/(kg*K) specific gas constant (air)\nfunction speedofsound(x,y,z)\n    if z<0.\n        return sqrt(γ*R*Tu)#m/s\n    else\n        return sqrt(γ*R*Tb)#m/s\n    end\nend\nc=generate_field(mesh,speedofsound)","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Note that in more elaborate models, you may read the field c from a file containing simulation or experimental data, rather than specifying it analytically.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Model-Discretization","page":"Tutorial 01 Rijke Tube","title":"Model Discretization","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Now we have all ingredients together and we can discretize the model.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"L=discretize(mesh,dscrp,c)","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The return value L here is a family of linear operators. The shown info is an algebraic representation of the family plus a list of associated parameters. You might have noticed that the list contains all parameters that have been specified during the model description (n,τ,Y). However, there are also two parameters that were added by default: ω and λ. ω is the complex frequency of the model and λ an auxiliary value that is important for the eigenfrequency computation.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Solving-the-Model","page":"Tutorial 01 Rijke Tube","title":"Solving the Model","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html#Global-Solver","page":"Tutorial 01 Rijke Tube","title":"Global Solver","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"We can solve the model for some eigenvalues using one of the eigenvalue solvers. The package provides you with two types of eigenvalue solvers. A global contour-integration-based solver. That finds you all eigenvalues inside of a specified contour Γ in the complex plane.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Γ=[150.0+5.0im, 150.0-5.0im, 1000.0-5.0im, 1000.0+5.0im].*2*pi #corner points for the contour (in this case a rectangle)\nΩ, P = beyn(L,Γ,l=5,N=256, output=true)","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The found eigenvalues are stored in the array Ω. The corresponding eigenvectors are the columns of P. The huge advantage of the global eigenvalue solver is that it finds you multiple eigenvalues. Nonetheless, its accuracy may be low and sometimes it provides you with outright wrong solutions. However, for the current case the method works as we can verify that in our search window there are two eigenmodes oscilating at 272 and 695 Hz respectively:","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"for ω in Ω\n    println(\"Frequency: $(ω/2/pi)\")\nend","category":"page"},{"location":"tutorial_01_rijke_tube.html#Local-Solver","page":"Tutorial 01 Rijke Tube","title":"Local Solver","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"To get high accuracy eigenvalues , there are also local iterative eigenvalue solvers. Based on an initial guess, they only find you one eigenvalue at a time but with machine-precise accuracy. One of these solvers is based on the method of successive linear problems (mslp). You call it as follows:","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"sol,nn,flag=mslp(L,250*2*pi,output=true);\nnothing #hide","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The return values of this solver are a solution object sol, the number of iterations nn performed by the solver and an error flag flag providing information on the quality of the solution. If flag==0 the solution has converged. If flag<0 something went wrong. And if flag>0... well, probably the solution is fine but you should check it.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"In the current case the flag is 1 indicating that the maximum number of iterations has been reached. This is because we haven't specified a stopping criterion and the iteration just ran for the maximum number of iterations. Nevertheless, the 272 Hz mode is correct. Indeed, as you can see from the printed output it already converged to machine-precision after 5 iterations.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Changing-a-specified-parameter.","page":"Tutorial 01 Rijke Tube","title":"Changing a specified parameter.","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Remember that we have specified the parameters Y,n, and τ?. We can change these easily without rediscretizing our model. For instance currently n==0.0 so the solution is purely acoustic. The effect of the flame just enters the problem via the speed of sound field (this is known as passive flame). By setting the interaction index to 1.0 we activate the flame.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"L.params[:n]=1","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Now we can just solve the model again to get the active solutions","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"sol_actv,nn,flag=mslp(L,245*2*pi-82im*2*pi,output=true,order=3);\nnothing #hide","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The eigenfrequency is now complex:","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"sol_actv.params[:ω]/2/pi","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"with a growth rate -imag(sol_actv.params[:ω]/2/pi)≈  59.22","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Instead of recomputing the eigenvalue by one of the solvers. We can also approximate the eigenvalue as a function of one of the model parameters utilizing high-order perturbation theory. For instance this gives you the 30th order diagonal Padé estimate expanded from the passive solution.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"perturb_fast!(sol,L,:n,16) #compute the coefficients\nfreq(n)=sol(:n,n,8,8)/2/pi #create some function for convenience\nfreq(1) #evaluate the function at any value for `n` you are interested in.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The method is slow when only computing one eigenvalue. But its computational costs are almost constant when computing multiple eigenvalues. Therefore, for larger parametric studies this is clearly the method of choice.","category":"page"},{"location":"tutorial_01_rijke_tube.html#VTK-Output-for-Paraview","page":"Tutorial 01 Rijke Tube","title":"VTK Output for Paraview","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"To visualize your solutions you can store them as \"*.vtu\" files to open them with paraview. Just, create a dictionary, where your modes are stored as fields.","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"data=Dict()\ndata[\"speed_of_sound\"]=c\ndata[\"abs\"]=abs.(sol_actv.v)/maximum(abs.(sol_actv.v)) #normalize so that max=1\ndata[\"phase\"]=angle.(sol_actv.v)\n\nvtk_write(\"tutorial_01\", mesh, data) # Write the solution to paraview","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The vtk_write function automatically sorts your data by its interpolation scheme. Data that is constant on a tetrahedron will be written to a file *_const.vtu, data that is linearly interpolated on a tetrahedron will go to *_lin.vtu, and data that is quadratically interpolated to *_quad.vtu. The current example uses constant speed of sound on a tetrahedron and linear finite elements for the discretization of p. Therefore, two files are generated, namely tutorial_01_const.vtu containing the speed-of-sound field and tutorial_01_lin.vtu containing the mode shape. Open them with paraview and have a look!.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Summary","page":"Tutorial 01 Rijke Tube","title":"Summary","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"You learnt how to set-up a simple Rijke-tube study. This  already introduced all basic steps that are needed to work with the Helmholtz solver. However, there are a lot of details you can fine tune and even features that weren't mentioned in this tutorial. The next tutorials will introduce these aspects in more detail.","category":"page"},{"location":"tutorial_01_rijke_tube.html#References","page":"Tutorial 01 Rijke Tube","title":"References","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"[1] F. Nicoud, L. Benoit, and C. Sensiau, Acoustic Modes in Combustors with Complex Impedances and Multidimensional Active Flames, AIAA, 2007, doi:10.2514/1.24933","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"","category":"page"},{"location":"tutorial_01_rijke_tube.html","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"EditURL = \"<unknown>/tutorial_06_second_order_elements.jl\"","category":"page"},{"location":"tutorial_06_second_order_elements.html#Tutorial-06-Second-Order-Elements","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"","category":"section"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"So far we have deployed linear elements for the FEM discretization of the Helmholtz equation. But WavesAndEigenvalues.Helmholtz can do more. Second order elements are also available. All you have to do is to set the order keyword in the call to order=:quad.","category":"page"},{"location":"tutorial_06_second_order_elements.html#Model-set-up","page":"Tutorial 06 Second Order Elements","title":"Model set-up","text":"","category":"section"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"We demonstrate things with the usual Rijke tube set-up from Tutorial 01.","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"using WavesAndEigenvalues.Helmholtz\nmesh=Mesh(\"Rijke_mm.msh\",scale=0.001) #load mesh\ndscrp=Dict() #initialize model descriptor\ndscrp[\"Interior\"]=(:interior, ()) #define resonant cavity\ndscrp[\"Outlet\"]=(:admittance, (:Y,1E15)) #specify outlet BC\nγ=1.4 #ratio of specific heats\nρ=1.225 #density at the reference location upstream to the flame in kg/m^3\nTu=300.0    #K unburnt gas temperature\nTb=1200.0    #K burnt gas temperature\nP0=101325.0 # ambient pressure in Pa\nA=pi*0.025^2 # cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1) #the ratio of mean heat release to mean velocity Q02U0\nx_ref=[0.0; 0.0; -0.00101] #reference point\nn_ref=[0.0; 0.0; 1.00] #directional unit vector of reference velocity\nn=0.01 #interaction index\nτ=0.001 #time delay\ndscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ)) #flame dynamics\nR=287.05 # J/(kg*K) specific gas constant (air)\nspeedofsound(x,y,z) = z<0. ? sqrt(γ*R*Tu) : sqrt(γ*R*Tb)\nc=generate_field(mesh,speedofsound)","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"The key difference is that we opt for second order elements during discretization","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"L=discretize(mesh,dscrp,c, order=:quad)","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"All subsequent steps are the same. For instance, solving for an eigenvalue is done by","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"sol,nn,flag=mslp(L,340*2*pi,maxiter=20,tol=1E-11,output=true)\n#","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"And writing output to paraview by","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"data=Dict()\ndata[\"abs mode\"]=abs.(sol.v)\nvtk_write(\"tutorial06\",mesh, data)","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"Note However, that the vtk-file name will be tutorial06_quad.vtu.","category":"page"},{"location":"tutorial_06_second_order_elements.html#Summary","page":"Tutorial 06 Second Order Elements","title":"Summary","text":"","category":"section"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"Quadratic elements are an easy matter. Just set order=:quad when calling discretize.","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"","category":"page"},{"location":"tutorial_06_second_order_elements.html","page":"Tutorial 06 Second Order Elements","title":"Tutorial 06 Second Order Elements","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"EditURL = \"<unknown>/tutorial_00_NLEVP.jl\"","category":"page"},{"location":"tutorial_00_NLEVP.html#Tutorial-00-Introduction-to-the-NLEVP-module","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"This tutorial briefly introduces you to the NLEVP module. NLEVP is an abbreviation for nonlinear eigenvalue problem. This is the problem T(λ)v=0 where T is some matrix family the scalar λ and the vector v form an eigenpair. Often also the left eigenvector w for the corresponding problem T'(λ)w=0 is also sought. Clearly, NLEVPs are a generalization of classic (linear) eigenvalue problems they would read T(λ)=A-λI or T(λ)=A-λB. For the reminder of the tutorial it is assumed, that the reader is somewhat familiar with NLEVPs and we refer to the very nice review [1] for a detailed introduction.","category":"page"},{"location":"tutorial_00_NLEVP.html#Setting-up-a-NLEVP","page":"Tutorial 00 Introduction to the NLEVP module","title":"Setting up a NLEVP","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The NLEVP lets you define NLEVPs and provides you with tools for finding accurate as well as perturbative solutions. The using statement brings all necessary tools into scope:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"using WavesAndEigenvalues.NLEVP","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Let's consider the quadratic eigenvalue problem  1 from the collection of NLEVPs [2]. It reads T(λ)= λ^2*A2 + λ*A1 + A0 where","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"A2=[0 6 0;\n    0 6 0;\n    0 0 1];\n\nA1=[1 -6 0;\n    2 -7 0;\n    0  0 0];\n\nA0=[1 0 0;\n    0 1 0;\n    0 0 1];\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"We first need to instantiate an empty operator family.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"T=LinearOperatorFamily()","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"tip: Tip\nPer default the LinearOperatorFamily uses :λ as the symbol for the eigenvalue. You can customize this behavior by calling the constructor with additional parameters, e.g. T=LinearOperatorFamily([:ω]), would make the eigenvalue name :ω. It is also possible to change the eigenvalue after construction.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The next step is to create the three terms and add them to the matrix family. A term is created from the syntax Term(M,func,args,txt,mat), where M is the matrix of the term, func is a list of scalar (possibly multi-variate) functions multiplying, args, is a list of lists containing the symbols of the arguments to the functions, and mat is the character string representing the matrix.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Ok, let's create the first term:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"term=Term(A2,(pow2,),((:λ,),),\"A2\")","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Note, that the function pow2 is provided by the NLEVP module. It computes the square of its input, i.e. pow2(3)==9. However, it has an optional second parameter indicating a derivative order. For instance, pow2(3,1)=6 because the first derivative of the square function at 3 is 2*3==6. This feature is, important because many algorithms in the NLEVP module will need to compute derivatives. You can write your own coefficient-functions, but make sure that they provide at least the first derivative correctly. This will be further explained in the next tutorials.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Now, let's add the term to our family.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"T+=term","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"It worked! The family is not empty anymore.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"tip: Tip\nThere is also the syntax push!(T,term) to add a term. It is actually more efficient because unlike the +-operator it does not create a temporary copy of T. However, it doesn't really matter for small problems like this example and we therefore prefer the +-operator for readability.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Let's also add the other two terms.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"T+=Term(A1,(pow1,),((:λ,),),\"A1\")\nT+=Term(A0,(),(),\"A0\")","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Note that functions and arguments are empty in the last term because there is no coefficient function.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The family is now a complete representation of our problem","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"It is quite powerful. For instance, we can evaluate it at some point in the complex plane, say 3+2im:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"T(3+2im)","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"We can even take its derivatives. For instance, the second derivative at the same point is","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"T(3+2im,2)","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"This syntax comes in handy when writing algorithms for the solution of the NLEVPs. However, the casual user will appreciate it when computing residuals.","category":"page"},{"location":"tutorial_00_NLEVP.html#Iterative-eigenvalue-solvers","page":"Tutorial 00 Introduction to the NLEVP module","title":"Iterative eigenvalue solvers","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The NLEVP module provides various solvers for computing eigensolution. They essentially fall into two categories, iterative and integration-based. We will start the discussion with iterative solvers.","category":"page"},{"location":"tutorial_00_NLEVP.html#method-of-successive-linear-problems","page":"Tutorial 00 Introduction to the NLEVP module","title":"method of successive linear problems","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The method of successive linear problems is a robust iterative solver. Like all iterative solvers it tries finding an eigensolution from an initial guess. We will also set the output keyword to true, in order to see a bit what is going on behind the scenes. The function will return a solution sol of type Solution, as well as the number of iterations n run and an error flag flag.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"sol,n,flag=mslp(T,0,output=true);\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The printed output tells us that the algorithm found 1/3 is an eigenvalue of the problem. It has run for 10 iterations. However, it issued a warning that the maximum number of iterations has been reached. That is why the result comes with a non-zero flag, which says that something might be wrong. In general negative flag values represent errors, while positive values indicate warnings. In the current case the flag is 1, so this is a warning. Therefore, the result can be true, but there is something we should be aware of.  Let's decode the error flag into something more readable.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"msg = decode_error_flag(flag)\nprintln(msg)","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"As we already knew, the iteration aborted because the maximum number of iterations (10) has been performed. You can change the maximum number of iterations from its default value by using the maxiter keyword. However, this won't fix the problem because the iteration will run until a certain tolerance is met or the maximum number of iteration is reached. Per default the tolerance is 0, and therefore due to machine-precision very unlikely to be precisely met. Indeed, we see from the printed output, above that the eigenvalue is not significantly changing anymore after 6 iterations. Let's redo the calculations, with a small but non-zero tolerance by setting the optional tol keyword.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"sol,n,flag=mslp(T,0,tol=1E-10,output=true);\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Boom! The iteration stops after 6 iterations and indicates that an eigenvalue has been found.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"We may also inspect the corresponding left and right eigenvector. They are fields in the solution object:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"println(sol.v)\nprintln(sol.v_adj)","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"There are more iterative solvers. Not all of them solve the complete problem. Some only return the eigenvalue and the right eigenvector others even just the eigenvalue. (If the authors of this software get more funding this might be improved in the future...)","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Let's briefly test them all...","category":"page"},{"location":"tutorial_00_NLEVP.html#inverse-iteration","page":"Tutorial 00 Introduction to the NLEVP module","title":"inverse iteration","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"This algorithm finds an eigenvalue and a corresponding right eigenvector","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"sol,n,flag=inveriter(T, 0, tol=1E-10, output=true);\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html#trace-iteration","page":"Tutorial 00 Introduction to the NLEVP module","title":"trace iteration","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"This algorithm only finds an eigenvalue","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"sol,n,flag=traceiter(T, 0, tol=1E-10, output=true);\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html#Lancaster's-generalized-Rayleigh-quotient-iteration","page":"Tutorial 00 Introduction to the NLEVP module","title":"Lancaster's generalized Rayleigh quotient iteration","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"This algorithm only finds an eigenvalue","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"sol,n,flag=lancaster(T, 0, tol=1E-10, output=true);\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html#two-sided-Rayleigh-functional-iteration","page":"Tutorial 00 Introduction to the NLEVP module","title":"two-sided Rayleigh-functional iteration","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"This algorithm finds a complete eigentriple.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"sol,n,flag=rf2s(T, 0, tol=1E-10, output=true);\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Oops, this last test produced a NaN value. The problem often occurs when the eigenvalue and one point in the iteration is too precise. (See how in the last-but-one iteration we've been already damn close to 1/3). Choosing a slightly different initial guess often leverages the problem:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"sol,n,flag=rf2s(T, 0, tol=1E-10, output=true);\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html#Beyn's-integration-based-solver","page":"Tutorial 00 Introduction to the NLEVP module","title":"Beyn's integration-based solver","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Iterative solvers are highly accurate and do not need many resources. However, they only find one eigenvalue at the time and heavily depend on the initial guess. This is a problem because NLEVPs have many eigenvalues. (Indeed, some have infinitely many!) This is where integration-based solvers enter the stage. They can find all eigenvalue enclosed by a contour in the complex plane. Several such algorithm exist. The NLEVP module implements the one of Beyn 3. Any polygonal shape is supported as a contour (I am an engineer, so a polygon is any flat shape connecting three or more vertices with straight lines in a cyclic manner...).","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Let's test Beyn's algorithm on our example problem by searching for all eigenvalues inside the axis-parallel square spanning from -2-2im to 2+2im. The vertices of this contour are:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Γ=[2+2im, -2+2im, -2-2im, +2-2im];\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"It doesn't matter whether the contour is traversed in clockwise or counter-clockwise direction. However, the vertices should be traversed in a cyclic manner such that the contour is not criss-crossed (unless this is what you want to do, the algorithm correctly accounts for the winding number...)","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Beyn's algorithm also needs an educated guess on how many eigenvalues you are expecting to find inside of the contour. If your guess is too high, this won't be a problem. You will find your eigenvalues but you'll waste computational resources and face an unnecessarily high run time. Nevertheless, if your guess is too small, weird things may happen and you probably will get wrong results. We will further discuss this point later. Now let's focus on the example problem. It is 3-dimensional and quadratic, we therefore know that it that it has 6 eigenvalues. Not all of them must lie in our contour, however this upper bound is a safe guess for our contour. We use the optional keyword l=6 to pass this information to the algorithm. The call then is:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Λ,V=beyn(T,Γ,l=6, output=true);\nnothing #hide","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Note the printed information on singular values. One step in Beyn's algorithm leads to a singular value decomposition. Here, we got 6 singular values because we chose to run the algorithm with l=6 option. In exact arithmetics There would be as many non-zero singular values as there are eigenvalues inside the contour, if the guess l is equal or greater than the number of eigenvalues. The output tells us that there are probably 5 eigenvalues inside the contour as there is only one singular value that can be considered equal to 0 given the machine precision. Indeed, the example solution is analytical solvable and it is known that it has 5 eigenvalues inside the square.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The return values Λ and V are the list of eigenvalues and corresponding (right) eigenvectors such that T(Λ[i])*V[:,i]==0. At least this is what it should be. Because the computation is carried out on a computer the eigenpairs won't evaluate to the zero vector but have some residual. We can use this as a quality check. The computation of the residual norms yields:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"for (idx,λ) in enumerate(Λ)\n   v=V[:,idx]\n   v/=sqrt(v'*v)\n   res=T(λ)*v\n   println(\"λ=$λ residual norm: $(abs(sqrt(res'*res)))\")\nend","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"We clearly see that out of the 6 eigenvalues 5 have extremely low residuals. The eigenvalue with the high residual is actually not an eigenvalue. This is inline with our consideration on the singular value. There is a keyword sigma_tol that you may provide to the call of the algorithm, in order to ignore singular values that are smaller then a user-specified threshold.# However, an appropriate threshold is problem-dependent and often it is a better strategy to feed the computed eigenvalues as initial guesses into an iterative solver.","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"Please, note that you could also compute the number of poles and zeros inside the contour from the residual theorem with the following command:","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"number=count_poles_and_zeros(T,Γ)","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The functions sums up the number of poles and zeros of the determinant of T inside your contour. Zeros are positively counted while poles count negatively when encircling the domain mathematically positive (counter-clockwise). Thus, the number should not be mistaken as an initial guess for l. Yet, often you have some knowledge about the properties of your problem. For instance the current example problem is polynomial an therefore is unlikely to have poles. That number≈5 is a further indicator that there are, indeed, only 5 eigenvalues inside the square. Note, that count_poles_and_zeros uses Jacobi's formula to compute the necessary derivatives of the determinant by trace operations. The command is therefore reliable for small-sized problems only.","category":"page"},{"location":"tutorial_00_NLEVP.html#Summary","page":"Tutorial 00 Introduction to the NLEVP module","title":"Summary","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"The NLEVP module provides you with essential tools for setting up and solving non-linear eigenvalue problems. In particular, there is a bunch of solution algorithms available. There is more the module can do. All of the presented solvers have various optional keyword arguments for fine-tuning there behavior. For instance, just type ? mslp in the REPL or use the documentation browser of your choice to learn more about the mslp command. Moreover, there is functionality for computing perturbation expansions of known solutions. These topics will be further discussed in the next tutorials.","category":"page"},{"location":"tutorial_00_NLEVP.html#References","page":"Tutorial 00 Introduction to the NLEVP module","title":"References","text":"","category":"section"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"[1] S. Güttel and F. Tisseur, The Nonlinear Eigenvalue Problem, 2017, http://eprints.ma.man.ac.uk/2538/","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"[2] T. Betcke, N. J. Higham, V. Mehrmann, C. Schröder and F. Tisseur, NLEVP: A Collection of Nonlinear Eigenvalue Problems, 2013, ACM Trans. Math. Soft., doi:10.1145/2427023.2427024","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"[3] W.-J. Beyn, An integral method for solving nonlinear eigenvalue problems, 2012, Lin. Alg. Appl., doi:10.1016/j.laa.2011.03.030","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"","category":"page"},{"location":"tutorial_00_NLEVP.html","page":"Tutorial 00 Introduction to the NLEVP module","title":"Tutorial 00 Introduction to the NLEVP module","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"EditURL = \"<unknown>/tutorial_02_global_eigenvalue_solver.jl\"","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"#","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#Tutorial-02-Beyn's-Global-Eigenvalue-Solver","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"In Tutorial 01 you learnt the basics of the Helmholtz solver. This tutorial will make you more familiar with the global eigenvalue solver. The solver implements an algorithm invented by W.-J. Beyn in [1]. The implementation closely follows [2].","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#Model-set-up.","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Model set-up.","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"The model is the same Rijke tube configuration as in Tutorial 01:","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"using WavesAndEigenvalues.Helmholtz\nmesh=Mesh(\"Rijke_mm.msh\",scale=0.001) #load mesh\ndscrp=Dict() #initialize model descriptor\ndscrp[\"Interior\"]=(:interior, ()) #define resonant cavity\ndscrp[\"Outlet\"]=(:admittance, (:Y,1E15)) #specify outlet BC\nγ=1.4 #ratio of specific heats\nρ=1.225 #density at the reference location upstream to the flame in kg/m^3\nTu=300.0    #K unburnt gas temperature\nTb=1200.0    #K burnt gas temperature\nP0=101325.0 # ambient pressure in Pa\nA=pi*0.025^2 # cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1) #the ratio of mean heat release to mean velocity Q02U0\nx_ref=[0.0; 0.0; -0.00101] #reference point\nn_ref=[0.0; 0.0; 1.00] #directional unit vector of reference velocity\nn=0.01 #interaction index\nτ=0.001 #time delay\ndscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ)) #flame dynamics\nR=287.05 # J/(kg*K) specific gas constant (air)\nspeedofsound(x,y,z) = z<0. ? sqrt(γ*R*Tu) : sqrt(γ*R*Tb)\nc=generate_field(mesh,speedofsound)\nL=discretize(mesh,dscrp,c)","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"The global eigenvalue solver has a range of parameters. Mandatory, are only the linear operator family L you like to solve and the contour Γ.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"The contour is specified as a list of complex numbers. Each of which defining a vertex of the polygon you want to scan for eigenvalues. In Tutorial 01 we specified the contour as rectangle by","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Γ=[150.0+5.0im, 150.0-5.0im, 1000.0-5.0im, 1000.0+5.0im].*2*pi","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"The vertices are traversed in the order you specify them. However, the direction does not matter, meaning that equivalently you can specify Γ as:","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Γ=[1000.0+5.0im, 1000.0-5.0im, 150.0-5.0im, 150.0+5.0im]","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Note that you should not specify the first point as the last point. This will be automatically done for you by the solver.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Again, Γ is a polygon, so, e.g., specifying only three points will make the search region a triangle. And to get curved regions you just approximate them by a lot of vertices. For instance, this polygon is a good approximation of a circle.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"radius=10\ncenter_point=100\nΓ_circle=radius.*[cos(α)+sin(α)*1.0im for α=0:2*pi/1000:(2*pi-2*pi/1000)].+center_point","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Note that your contour does not need to be convex!","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#Number-of-eigenvalues","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Number of eigenvalues","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Beyn's algorithm needs an initial guess on how many eigenvalues l you expect inside your contour. Per default this is l=5. If this guess is less than the actual eigenvalues. The algorithms will miserably fail to compute any eigenvalue inside your contour correctly. You may, therefore, choose a large number for l to be on the save site. However, this will dramatically increase your computation time.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"There are several strategies to deal with this problem and each of which might be well suited in a certain situation:","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Split your domain in several smaller domains. This reduces the potential number of eigenvalues in each of the subdomains.\nJust repeatedly rerun the solver with increasing values of l until the found eigenvalues do not change anymore.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#Quadrature-points","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Quadrature points","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"As Beyn's algorithm is based on contour integration a numerical quadrature method is performed under the hood. More precisely, the code performs a Gauss-Legendre integration on each of the edges of the Polygon Γ. The number of quadrature points for each of these integrations is N=32 per default. But you can specify it as an optional parameter when calling the solver. For instance as the circular contour is already discretized by 1000 points, it is not necessary to utilize N=16 quadrature points on each of the edges. Let's say N=4 should be fine. Then, you would call the solver like","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Ω,P=beyn(L,Γ_circle,N=4,output=true)","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#Test-singular-values","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Test singular values","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"One step in Beyn's algorithm requires a singular value decomposition. Non-zero singular values and singular vectors associated with these are meant to be disregarded. Unfortunately, on a computer zero could also mean a very small number, and small here is problem-dependent. The code will disregard any singular value σ<tol where tol == 0.0 Per default. This means, that per default only singular values that are exactly 0 will be disregarded. It is very unlikely that this will be the case for any singular value. You may specify your own threshold by the optional key-word argument tol","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Ω,P=beyn(L,Γ, tol=1E-10)","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"but this is rather an option for experts. Even the authors of the code do not know a systematic way of well defining this threshold for given configuration.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#Test-the-position-of-the-eigenvalues","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Test the position of the eigenvalues","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Because there could be a lot of spurious eigenvalues as there is no correct implementation of the singular value test. A very simple test to check whether your eigenvalues are correct is to see whether they are inside your contour Γ. This test is performed per default, but you can disable it using the keyword pos_test.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Ω,P=beyn(L,Γ, pos_test=false)","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Note, that if you disable the position test and do not specify a threshold for the singular values, you will always be returned with l eigenvalues by Beyn's algorithm. (And sometimes even eigenvalues that are outside of your contour are fairly correct... )","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#Toggle-the-progress-bar","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Toggle the progress bar","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Especially when searching for many eigenvalues, in large domains the algorithm may take some time to finish. You can, therefore, optionally display a progress bar together with an estimate of how long it will take for the routine to finish. This is done using the optional keyword output.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Ω,P=beyn(L,Γ, output=true)","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#Summary","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Summary","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"Beyn's algorithm is a powerful tool for finding all eigenvalues in a specified domain. However, its computational costs are quite high and it therefore is best suited for solving small to medium-sized problems. A good strategy is to combine it with a local iterative solver such that solutions from Beyn's algorithm are fed into an iterative solver for further improvement. The next tutorial will further explain iterative solvers.","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html#References","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"References","text":"","category":"section"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"[1] W.-J. Beyn, An integral method for solving nonlinear eigenvalue problems, 2012, Lin. Alg. Appl., doi:10.1016/j.laa.2011.03.030","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"[2] P.E. Buschmann, G.A. Mensah, J.P. Moeck, Solution of Thermoacoustic Eigenvalue Problems with a Non-Iterative Method, J. Eng. Gas Turbines Power, Mar 2020, 142(3): 031022 (11 pages) doi:10.1115/1.4045076","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"","category":"page"},{"location":"tutorial_02_global_eigenvalue_solver.html","page":"Tutorial 02 Beyn's Global Eigenvalue Solver","title":"Tutorial 02 Beyn's Global Eigenvalue Solver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"EditURL = \"<unknown>/tutorial_08_custom_FTF.jl\"","category":"page"},{"location":"tutorial_08_custom_FTF.html#Tutorial-08-Custom-FTF","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"","category":"section"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"The typical use case for thermoacoustic stability assessment will require case-speicific data. e.g, measured impedance functions or flame transfer functions. This tutorial explains how to specify custom functions in order to include them in your model.","category":"page"},{"location":"tutorial_08_custom_FTF.html#Model-set-up","page":"Tutorial 08 Custom FTF","title":"Model set-up","text":"","category":"section"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"The model is the same Rijke tube configuration as in Tutorial 01. However, this time the FTF is customly defined. Let's start with the definition of the flame transfer function. The custom function must return the FTF and all its derivatives w.r.t. the complex freqeuncy. Therefore, the interface must be a function with two inputs: a complex number and an integer. For an n-τ-model it reads.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"function FTF(ω::ComplexF64, k::Int=0)::ComplexF64\n    return n*(-1.0im*τ)^k*exp(-1.0im*ω*τ)\nend","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"note: Note\nn and τ aren't defined yet, but Julia is a quite generous programming language; it won't complain if we define them before making our first call to the function.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Of course, it is sometimes hard to find a closed-form expression for an FTF and all its derivatives. You need to specify at least these derivative orders that will be used by the methods applied to analyse the model. This is at least the first order derivative for the standard mslp method. You might return derivative orders up to the order you need it using an if clause for each order. Anyway, the function may get complicated. The implicit method explained further below is then a viable alternative.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"For convenience we can also specify a display signature, that is used to nicely display our function when the discretized model is displayed in the REPL. Let's say in our case we want the function to be named \"ntau(z)\" where \"z\" is a placeholder for whatever the name of the argument will be. We achieve this by adding a method to our FTF function that takes a symbol as input and returns a string.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"function FTF(z::Symbol)::String\n    return \"ntau($z)\"\nend","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Now let's set-up the Rijke tube model. The data is the same as in Tutorial 01","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"using WavesAndEigenvalues.Helmholtz\nmesh=Mesh(\"Rijke_mm.msh\",scale=0.001) #load mesh\ndscrp=Dict() #initialize model descriptor\ndscrp[\"Interior\"]=(:interior, ()) #define resonant cavity\ndscrp[\"Outlet\"]=(:admittance, (:Y,1E15)) #specify outlet BC\nγ=1.4; #ratio of specific heats\nρ=1.225; #density at the reference location upstream to the flame in kg/m^3\nTu=300.0;    #K unburnt gas temperature\nTb=1200.0;    #K burnt gas temperature\nP0=101325.0; # ambient pressure in Pa\nA=pi*0.025^2; # cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1); #the ratio of mean heat release to mean velocity Q02U0\nx_ref=[0.0; 0.0; -0.00101]; #reference point\nn_ref=[0.0; 0.0; 1.00]; #directional unit vector of reference velocity\nR=287.05; # J/(kg*K) specific gas constant (air)\nspeedofsound(x,y,z) = z<0. ? sqrt(γ*R*Tu) : sqrt(γ*R*Tb);\nc=generate_field(mesh,speedofsound);\nnothing #hide","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"btw this is the moment where we specify the values of n and τ","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"n=1; #interaction index\nτ=0.001; #time delay\nnothing #hide","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"but instead of passing n and τ and its values to the flame description we just pass the FTF","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"dscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,FTF)); #flame dynamics\n\n#... discretize ...\nL=discretize(mesh,dscrp,c)","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"and done! Note how the function is correctly displayed as \"natu(ω)\"  if we wouldn't have named it, the FTF will be displayed as \"FTF(ω)\" in the signature of the operator.","category":"page"},{"location":"tutorial_08_custom_FTF.html#Checking-the-model","page":"Tutorial 08 Custom FTF","title":"Checking the model","text":"","category":"section"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Solving the problem shows that we get the same result as with the built-in n-τ-model in Tutorial 01","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"sol,nn,flag=mslp(L,340,maxiter=20,tol=1E-9,scale=2*pi)\n# changing the parameters","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Because the system parameters n and τ are defined in this outer scope, changing them will change the FTF and thus the model without rediscretization. For instance, you can completely deactivate the FTF by setting n to 0.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"n=0","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Indeed the model now converges to a purely acoustic mode","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"sol,nn,flag=mslp(L,340*2*pi,maxiter=20,tol=1E-11)","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"However, be aware that there is currently no mechanism keeping track of these parameters. It is the programmer's (that's you) responsibility to know the specification of the FTF when sol was computed.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Also, note the parameters are defined in this scope. You cannot change it by iterating it in a for-loop or from within a function, due to julia's scoping rules.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"# Something else than n-τ...","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Of course, this is an academic example. In practice you will specify something very custom as FTF. Maybe a superposition of σ-τ-models or even a statespace model fitted to experimental data.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"A fairly generic way of handling experimental FTFs was intoduced in [1]. This approach is not considering a specific FTF but parametrizes the problem in terms of the flame response. Using perturbation theory, it is then possible to get the frequency as a function of the flame response. This allows for closing the system with a specific FTF in a subsequent step and, hence,  finding the eigenfrequency by solving a scalar equation! Here is a demonstration on how that works:","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"dscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref)) #no flame dynamics specified at all\nH=discretize(mesh,dscrp,c)\nη0=0\nH.params[:FTF]=η0\nsol_base,nn,flag=mslp(H,340*2*pi,maxiter=20,tol=1E-11)","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"The model H has no flame transfer function, but the flame response appears as a parameter :FTF. We set this parameter to 0 and solved the model, i.e. we computed a passive solution.  This solution will serve as a baseline. Note, that it is not necessary to use a passive solution as baseline, a nonzero baseline flame response would also work. Anyway, the baseline solution is used to build a 16th-order Padé-approximation. For convenience we import some tools to handle the algebra.","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"using WavesAndEigenvalues.Helmholtz.NLEVP.Pade: Polynomial, Rational_Polynomial, prodrange, pade\nperturb_fast!(sol_base,H,:FTF,16)\nfunc=pade(Polynomial(sol_base.eigval_pert[Symbol(\"FTF/Taylor\")]),8,8)\nω(z,k=0)=func(z-η0,k)","category":"page"},{"location":"tutorial_08_custom_FTF.html#Newton-Raphson-for-finding-flame-response","page":"Tutorial 08 Custom FTF","title":"Newton-Raphson for finding flame response","text":"","category":"section"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Now, we can deploy a simple Newton-Raphson iteration for finding the eigenfrequency for a chosen FTF as a postprocessing step. This is possible because we have a good approximation of omega as a function of the flame response eta and a FTF would link omega to a flame response. Hence, the eigenfrequency of the problem is implicitly given by the scalar (sic!) equation:","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"eta = FTF(omega(Deltaeta))-eta_0","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Which we can first solve for eta using Newton-Raphson","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Δη_k+1=Δη_k-fracFTF(ω(Δη_k))-Δη_kFTF(ω(Δη_k))ω(Δη_k)-1","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"and then for omega by plugging eta into omega=omega(eta).","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"n=1\nτ=0.001\nη=sol_base.params[:FTF]\nfor ii=1:10\n    global omeg,η\n    omeg=ω(η)\n    η-=(FTF(omeg)-η)/(FTF(omeg,1)*ω(η,1)-1)\n    println(\"iteration #\",ii,\" estimate η:\",η)\nend\nprintln(ω(η)/2pi,\" η :\",η,\" Res:\",FTF(omeg)-η)\nsol_exact,nn,flag=mslp(L,ω(η)/2pi,maxiter=20,tol=1E-11,output=false) #solve again\nω_exact=sol_exact.params[:ω]\nprintln(\" exact=$(ω_exact/2/pi)  vs  approx=$(ω(η)/2pi))\")","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"Works like a charm!","category":"page"},{"location":"tutorial_08_custom_FTF.html#Summary","page":"Tutorial 08 Custom FTF","title":"Summary","text":"","category":"section"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"You can analytically define custom FTFs. In order, for high-order perturbation theory to work, you will need to specify high order derivatives of your custom function, too. Sometimes this is cumbersome. As an alternative, you can first solve the problem parametrized in the flame response only and then closing the problem in a subsequent step using a custom FTF of which only the first derivative is known and a Newton-Raphson-Iteration.","category":"page"},{"location":"tutorial_08_custom_FTF.html#References","page":"Tutorial 08 Custom FTF","title":"References","text":"","category":"section"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"[1] C. F. Silva,  L. Prieto,  M. Ancharek,  P. Marigliani, and  G. A. Mensah, Adjoint-Based Calculation of Parametric Thermoacoustic Maps of an Industrial Combustion Chamber, JEGTP, GTP-20-1520, doi:10.1115/1.4049295","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"","category":"page"},{"location":"tutorial_08_custom_FTF.html","page":"Tutorial 08 Custom FTF","title":"Tutorial 08 Custom FTF","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"EditURL = \"<unknown>/tutorial_07_Bloch_periodicity.jl\"","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html#Tutorial-07-Bloch-periodicity","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"","category":"section"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"The Helmholtz solver was designed with the application of thermoacoustic stability assesment in mind. A very common case is that an annular combustion chamber needs assessment. These chamber types feature a discrete rotational symmetry, i.e., they are built from one constituent entity – the unit cell – that implicitly defines the annular geometry by copying it around the circumference multiple times. This high regularity of the geometry can be used to efficiently model the problem, e.g. only storing the unit cell instead of the entire geometry in a mesh-file in order to save memory and even performing the entire analysis thereby significantly accelerating the computations [1] This tutorial teaches you how using these features.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"note: Note\nTo do this tutorial yourself you will need the \"NTNU_12.msh\" file. Download it here.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html#Model-Set-up","page":"Tutorial 07 Bloch periodicity","title":"Model Set-up","text":"","category":"section"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"As a geometry we choose the laboratory-scale annular combustor used at NTNU Norway [2]. The NTNU combustor features unit cells that are reflection-symmetric. The meshfile NTNU_12.msh, thus, stores only one half of the unit cell. Let's load it...","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"using WavesAndEigenvalues.Helmholtz\nmesh=Mesh(\"NTNU_12.msh\",scale=1.0);\nnothing #hide","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"Note that there are two special domains named \"Bloch\" and \"Symmetry\". These are surfaces associated with the special symmetries of the combustor geometry. \"Bloch\" is the surface where one unit cell ends and the next one should begin, while \"Symmetry\" is the symmetry plane of the unit-cell. As the mesh is stored as a half-cell both surfaces are boundaries. The code will automatically use them to create the full mesh or just a unit-cell. First, let's create a full mesh We therefore specify the expansion scheme, this is a list of tuples containing all domain names we like to expand together with a qualifyer that is either :full,:unit, or :half, in order to tell the the code whether the copied versions should be merged into one addressable domain of the same name spanning the entire annulus (:full), pairs of domains from two corresponding half cells should be merged into individually adressable entities (:unit), or the copied hald cells remain individually addressable (:half). In the current case we only need individual names for each flames and can sefely merge all other entities. The scheme therefore reads:","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"doms=[(\"Interior\",:full),(\"Inlet\",:full), (\"Outlet_high\",:full),\n     (\"Outlet_low\",:full), (\"Flame\",:unit),];\nnothing #hide","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"and we can generate the mesh by","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"full_mesh=extend_mesh(mesh,doms);\nnothing #hide","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"The code automatically recognizes the degree of symmetry – 12 in the current case– and expands the mesh. Note how the full mesh now has 12 consecutively numbered flames, while all other entities still have a single name even though they were copied.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html#Discretizing-the-full-mesh","page":"Tutorial 07 Bloch periodicity","title":"Discretizing the full mesh","text":"","category":"section"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"The generated mesh behaves just like any other mesh. We can use it to discretize the model.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"speedofsound(x,y,z)=z<0.415 ? 347.0 : 850.0; #speed of sound field in m/s\nC=generate_field(full_mesh,speedofsound);\ndscrp=Dict(); #model description\ndscrp[\"Interior\"]=(:interior,());\ndscrp[\"Outlet_high\"]=(:admittance, (:Y_in,0));# src\ndscrp[\"Outlet_low\"]=(:admittance, (:Y_out,0));# src\nL=discretize(full_mesh, dscrp, C,order=:lin)","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"We can use all our standard tools to solve the model. For instance, Indlekofer et al. report on a plenum-dominant 1124Hz-mode that is first order with respect to the azimuthal direction and also first order with respect to the axial direction. Let's see whether we can find it by putting 1000 Hz as an initial guess.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"sol,nn,flag=mslp(L,1000,tol=1E-9,scale=2pi,output=true);\nnothing #hide","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"There it is! But to be honest the computation is kinda slow. Obviously, this is because the full mesh is quite large. Let's see how the unit cell computation would do....","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html#Unit-cell-computation","page":"Tutorial 07 Bloch periodicity","title":"Unit cell computation","text":"","category":"section"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"Ok, first, we create the unit cell mesh. We therefore set the keyowrd parameter unit to true in the call to extend_mesh.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"unit_mesh=extend_mesh(mesh,doms,unit=true)","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"Voila, there we have it! Discretization is nearly as simple as with a normal mesh. However, to invoke special Bloch-periodic boundary conditions the optional parameter b must be set to define a symbol that is used as the Bloch wavenumber. The rest is as before.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"c=generate_field(unit_mesh,speedofsound);\nl=discretize(unit_mesh, dscrp, c, b=:b)","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"Note how the signature of the discretized operator is now much longer. These extra terms facilitate the Bloch periodicity. What is important is the parameter :b that is used to set the Bloch wavenumber. For relatively low frequencies, the Bloch wave number corresponds to the azimuthal mode order. Effectively, it acts like a filter to the eigenmodes. Setting it to 1 will give us mainly first order modes.   (In general it gives us modes with azimuthal order k*12+1 where k is a natural number including 0, but 13th order modes are very high in frequency and therefore don't bother us). In comparison to the full model, this is an extra advantage of Bloch wave theory, as we cannot filter for certain mode shapes using the full mesh. This feature also allows us to reduce the estimate for eigenvalues inside the integration contour when using Beyn's algorithm, as there can only be eigenmodes corresponding to the current Bloch wavenumber. Let's try finding 1124-Hz mode again. It's of first azimuthal order so we should put the Bloch wavenumber to 1.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"l.params[:b] = 1;\nsol,nn,flag = mslp(l,1000,tol=1E-9, scale=2pi, output=true);\nnothing #hide","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"The computation is much faster than with the full mesh, but the eigenfrequency is exactly the same!","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html#Writing-output-to-paraview","page":"Tutorial 07 Bloch periodicity","title":"Writing output to paraview","text":"","category":"section"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"Not only the eigemnvalues much but also the mode shapes. Bloch wave theory clearly dictates how to extend the mode shape from the unit cell to recover the full-annulus solution.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"The `vtkwrite  function does this for you. You, therefore, have to provide it with the current Bloch wavenumber. If you provide it with the unitcell mesh, it will just write a single sector to the file.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"data=Dict();\nv=bloch_expand(full_mesh,sol,:b);\ndata[\"abs\"]=abs.(v)./maximum(abs.(v));\ndata[\"pahase\"]=angle.(v)./pi;\nvtk_write(\"Bloch_tutorial\",full_mesh,data);\nnothing #hide","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html#Summary","page":"Tutorial 07 Bloch periodicity","title":"Summary","text":"","category":"section"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"Bloch-wave-based analysis, significantly reduces the size of your problem without sacrificing any precission. It thereby saves you both memory and computational time.","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html#References","page":"Tutorial 07 Bloch periodicity","title":"References","text":"","category":"section"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"[1] Efficient Computation of Thermoacoustic Modes in Industrial Annular Combustion Chambers Based on Bloch-Wave Theory, G.A. Mensah, G. Campa,  J.P. Moeck 2016, J. Eng. Gas Turb. and Power,doi:10.1115/1.4032335","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"[2] The effect of dynamic operating conditions on the thermoacoustic response of hydrogen rich flames in an annular combustor,  T. Indlekofer, A. Faure-Beaulieu, N. Noiray and J. Dawson, 2021, Comb. and Flame, doi:10.1016/j.combustflame.2020.10.013","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"","category":"page"},{"location":"tutorial_07_Bloch_periodicity.html","page":"Tutorial 07 Bloch periodicity","title":"Tutorial 07 Bloch periodicity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"NLEVP.html#The-NLEVP-module","page":"The NLEVP module","title":"The NLEVP module","text":"","category":"section"},{"location":"NLEVP.html#Exported-functionality:","page":"The NLEVP module","title":"Exported functionality:","text":"","category":"section"},{"location":"NLEVP.html","page":"The NLEVP module","title":"The NLEVP module","text":"Modules = [WavesAndEigenvalues.NLEVP]\nPrivate=false","category":"page"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP","text":"Module containing routines to solve and perturb nonlinear eigenvalue problems.\n\n\n\n\n\n","category":"module"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.LinearOperatorFamily","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.LinearOperatorFamily","text":"LinearOperatorFamily\n\nType for a linear operator family. The type is mutable.\n\nFields\n\nterms: Array of terms forming the operator family\nparams: Dictionary mapping parameter symbols to their values\neigval: the symbol of the parameter that is the eigenvalue\nauxval: the symbol of the parameter that is the auxiliary eigenvalue\nactive: list of symbols that can be actively change when using an instance of\n\nthe family as a function.\n\nmode: mode that is controlling which terms are evalauted when calling an\n\ninstance of the family. This field is not to be modified by the user.\n\nSee also: Solution, Term\n\n\n\n\n\n","category":"type"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.LinearOperatorFamily-Tuple{String}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.LinearOperatorFamily","text":"L=LinearOperatorFamily(fname::String)\n\nLoad and construct LinearOperatorFamily from file fname.\n\nSee also: save\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.Solution","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.Solution","text":"Solution\n\nType for the solution of an iterative eigensolver.\n\nFields\n\nparams: Dictionary mapping parameter symbols to their values\nv: right (direct) eigenvector\nv_adj: left (adjoint) eigenvector\neigval: the symbol of the parameter that is the eigenvalue\neigval_pert: extra data for asymptotic series expansion of the eigenvalue\nv_pert: extra data for asymptotic series expansion of the eigenvector\nauxval: the symbol of the parameter that is the auxiliary eigenvalue\n\nSee also: LinearOperatorFamily\n\n\n\n\n\n","category":"type"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.Solution-2","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.Solution","text":"sol=Solution(params,v,v_adj,eigval,auxval=Symbol())\n\nStandard constructor for a solution object. See Solution for details.\n\n\n\n\n\n","category":"type"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.Term","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.Term","text":"Term{T}\n\nSingle term of a linear operator family.\n\nFields\n\ncoeff::T: matrix coefficient of the term\nfunc::Tuple: tuple of scalar-valued functions multiplying the matrix coefficient\nsymbol::String: character string for displaying the function(s)\nparams::Tuple: tuple of tuples containing function symbols for each function\noperator:String: String for displaying the matrix coefficient\nvarlist::Array{Symbol,1}: Array containing all symbols of fucntion arguments\n\nthat are used at least once\n\n\n\n\n\n","category":"type"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.Term-Tuple{Any,Tuple,Tuple,String}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.Term","text":"term=Term(coeff,func::Tuple,params::Tuple,operator::String)\n\nStandard constructor for type Term.\n\nArguments\n\ncoeff: matrix coefficient of the term\nfunc::Tuple: tuple of scalar-valued functions multiplying the matrix coefficient\nparams::Tuple: tuple of tuples containing function symbols for each function\noperator:String: String for displaying the matrix coefficient\n\nNotes\n\nThe rendering of the functions of term ist automotized. If the passed functions implement a method f(z::Symbol) then this method is used, otherwise the functions will be simply displayed with the string f. You can overwrite this behavior by explicitly passing a string for the function display using the syntax\n\nterm =Term(coeff,func::Tuple,params::Tuple,symbol::String,operator::String)\n\nwhere the extra argument symbolis the string used to display the function.\n\nSee also: LinearOperatorFamily\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.beyn","text":"Ω, P = beyn(L::LinearOperatorFamily, Γ; <keyword arguments>)\n\nCompute all eigenvalues of L inside the contour Γ together with the associated eigenvectors. The contour is given as a list of complex numbers which are interpreted as polygon vertices in the complex plane.  The eigenvalues are stored in the list Ω and the eigenvectors are stored in the columns of P. The eigenvector P[:,i] corresponds to the eigenvalue Ω[i], i.e., they satisfy L(Ω[i])P[:,i]=0.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the non-linear eigenvalue problem\nΓ::Array: List of complex points defining the contour.\nl::Integer = 5: estimate of the number of eigenvalues inside of Γ.\nK::Integer = 1: Augmention dimension if Γ is assumed to contain more than size(L)[1] eigenvalues.\nN::Integer = 16: Number of evaluation points used to perform the Gauss-Legendre integration along each edge of Γ.\ntol::Float=0.0: Threshold value to discard spurious singular values. If set to 0 (the default) no singular values are discarded.\npos_test::bool=true: If set to true perform positions test on the computed eigenvalues, i.e., check whether the eigenvalues are enclosed by Γ and disregard all eigenvalues which fail the test.\noutput::bool=true: Show progressbar if true.\nrandom::bool=false: Randomly initialize the V matrix if true.\n\nReturns\n\nΩ::Array: List of computed eigenvalues\nP::Matrix: Matrix of eigenvectors.\n\nNotes\n\nThe original algorithm was first presented by Beyn in [1]. The implementation closely follows the pseudocode from Buschmann et al. in [2].\n\nReferences\n\n[1] W.-J. Beyn, An integral method for solving nonlinear eigenvalue problems, Linear Algebra and its Applications, 2012, 436(10), p.3839-3863, https://doi.org/10.1016/j.laa.2011.03.030\n\n[2] P.E. Buschmann, G.A. Mensah, J.P. Moeck, Solution of Thermoacoustic Eigenvalue Problems with a Non-Iterative Method, J. Eng. Gas Turbines Power, Mar 2020, 142(3): 031022 (11 pages) https://doi.org/10.1115/1.4045076\n\nSee also: inveriter, lancaster, mslp, rf2s, traceiter\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.compute_moment_matrices-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.compute_moment_matrices","text":"A=compute_moment_matrices(L,Γ, <kwargs>)\n\nCompute moment matrices of L integrating along Γ.\n\nArguments\n\nL::LinearOperatorFamily\nΓ: List of complex points defining the contour.\nl::Int=5: (optional) estimate of the number of eigenvalues inside of Γ.\nK::Int=1: (optional) Augmention dimension if Γ is assumed to contain more than size(L)[1] eigenvalues.\nN::Int=16: (optional)  Number of evaluation points used to perform the Gauss-Legendre integration along each edge of Γ.\noutput::Bool=false (optional) toggle waitbar\nrandom::Bool=false (optional) toggle random initialization of V-matrix\n\nReturns\n\nA::Array: Moment matrices.\n\nNotes\n\nA is a 3 dimensional array. The last index loops over the various Moments, i.e., A[:,:,i]=∫_Γ z^i inv(L(z)) V dz. If random=false V is initialized with ones on its main diagonal. Otherwise it is random.\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.count_poles_and_zeros-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.count_poles_and_zeros","text":"n=count_poles_and_zeros(L,Γ;N=16,output=false)\n\nCount number \"n\" of poles and zeros of the determinant of L inside the contour Γ. The optional parameters N and output. respectively  determine the order of the Gauss-Legendre integration and toggle whether output is desplayed.\n\nNotes\n\nPole orders count negative while zero order count positive. The evaluation is based on applying the residue theorem to the determinant. It utilizes Jacobi's formula to compute the necessary derivatives from a trace operation. and is therefore only suitable for small problems.\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.decode_error_flag-Tuple{Int64}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.decode_error_flag","text":"msg=decode_error_flag(flag::Int)\n\nDecode error flag flag from an iterative solver into a string msg.\n\nSee also: inveriter, lancaster, mslp, rf2s, traceiter\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.householder-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.householder","text":"sol::Solution, n, flag = householder(L::LinearOperatorFamily, z; <keyword arguments>)\n\nUse a Householder method to iteratively find an eigenpar of L, starting the the iteration from z.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the nonlinear eigenvalue problem.\nz: Initial guess for the eigenvalue.\nmaxiter::Integer=10: Maximum number of iterations.\ntol=0: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is abs(z0-z1)<tol the iteration is aborted.\nrelax=1: relaxation parameter\nlam_tol=Inf: tolerance for the auxiliary eigenvalue to test convergence. The default is infinity, so there is effectively no test.\norder::Integer=1: Order of the Householder method, Maximum is 5\nnev::Integer=1: Number of Eigenvalues to be searched for in intermediate ARPACK calls.\nv0::Vector: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with ones.\nv0_adj::Vector: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with v0.\noutput::Bool: Toggle printing online information.\n\nReturns\n\nsol::Solution\nn::Integer: Number of perforemed iterations\nflag::Integer: flag reporting the success of the method. Most important values are 1: method converged, 0: convergence might be slow, -1:maximum number of iteration has been reached. For other error codes see the source code.\n\nNotes\n\nHousholder methods are a generalization of Newton's method. If order=1 the Housholder method is identical to Newton's method. The solver then reduces to the \"generalized Rayleigh Quotient iteration\" presented in [1]. If no relaxation is used (relax == 1), the convergence rate is of order+1. With relaxation (relax != 1) the convergence rate is 1. Thus, with a higher order less iterations will be necessary. However, the computational time must not necessarily improve nor do the convergence properties. Anyway, if the method converges, the error in the eigenvalue is bounded above by tol. For more details on the solver, see the thesis [2].\n\nReferences\n\n[1] P. Lancaster, A Generalised Rayleigh Quotient Iteration for Lambda-Matrices,Arch. Rational Mech Anal., 1961, 8, p. 309-322, https://doi.org/10.1007/BF00277446\n\n[2] G.A. Mensah, Efficient Computation of Thermoacoustic Modes, Ph.D. Thesis, TU Berlin, 2019\n\nSee also: beyn\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.inveriter","text":"sol,n,flag = inveriter(L,z;maxiter=10,tol=0., relax=1., x0=[],v=[], output=true)\n\nDeploy inverse iteration for finding an eigenpair of L.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the nonlinear eigenvalue problem.\nz: Initial guess for the eigenvalue.\nmaxiter::Integer=10: Maximum number of iterations.\ntol=0: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is abs(z0-z1)<tol the iteration is aborted.\nrelax=1: relaxation parameter\nx0::Vector: initial guess for eigenvector. If not provided it is all ones.\nv::Vector: normalization vector. If not provided it is all ones.\noutput::Bool: Toggle printing online information.\n\nReturns\n\nsol::Solution\nn::Integer: Number of perforemed iterations\nflag::Integer: flag reporting the success of the method. Most important values are 1: method converged, 0: convergence might be slow, -1:maximum number of iteration has been reached. For other error codes see the source code.\n\nNotes\n\nThe algorithm uses Newton-Raphson itreations on the vector level for iteratively solving the problem L(λ)x == 0 and v'x == 0. The implementation is based on Algorithm 1 in [1]\n\nReferences\n\n[1] V. Mehrmann and H. Voss (2004), Nonlinear eigenvalue problems: A challenge for modern eigenvalue methods, GAMM-Mitt. 27, 121–152.\n\nSee also: beyn, lancaster, mslp, rf2s, traceiter, decode_error_flag\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.lancaster","text":"sol,n,flag = lancaster(L,z;maxiter=10,tol=0., relax=1., x0=[],y0=[], output=true)\n\nDeploy Lancaster's Rayleigh-quotient iteration for finding an eigenvalue of L.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the nonlinear eigenvalue problem.\nz: Initial guess for the eigenvalue.\nmaxiter::Integer=10: Maximum number of iterations.\ntol=0: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is abs(z0-z1)<tol the iteration is aborted.\nrelax=1: relaxation parameter\nx0::Vector: initial guess for right iteration vector. If not provided it is all ones.\ny0::Vector: initial guess for left iteration vector. If not provided it is all ones.\noutput::Bool: Toggle printing online information.\n\nReturns\n\nsol::Solution\nn::Integer: Number of perforemed iterations\nflag::Integer: flag reporting the success of the method. Most important values are 1: method converged, 0: convergence might be slow, -1:maximum number of iteration has been reached. For other error codes see the source code.\n\nNotes\n\nThe algorithm is a generalization of Rayleigh-quotient-iteration by Lancaster [1].\n\nReferences\n\n[1] P. Lancaster, A Generalised Rayleigh Quotient Iteration for Lambda-Matrices,Arch. Rational Mech Anal., 1961, 8, p. 309-322, https://doi.org/10.1007/BF00277446\n\nSee also: beyn, inveriter, mslp, rf2s, traceiter, decode_error_flag\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.moments2eigs-Tuple{Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.moments2eigs","text":"Ω,P = moments2eigs(A; tol_σ=0.0, return_σ=false)\n\nCompute eigenvalues Ω and eigenvectors P from moment matricesA`.\n\nArguments\n\nA::Array: moment matrices\ntol::Float=0.0: tolerance for truncating singular values.\nreturn_σ::Bool=false: if true also return the singular values as third return value.\n\nReturns\n\nΩ::Array: List of computed eigenvalues\nP::Matrix: Matrix of eigenvectors.\nΣ::Array: List of singular values (only if return_σ==true)\n\nNotes\n\nThe the i-th coloumn in P corresponds to the i-th eigenvalue in Ω, i.e., Ω[i] and P[:,i] are an eigenpair.\n\nSee also: compute_moment_matrices\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.mslp","text":"sol,n,flag = mslp(L,z;maxiter=10,tol=0.,relax=1.,lam_tol=Inf,order=1,nev=1,v0=[],v0_adj=[],num_order=1,scale=1.0+0.0im,output=false)\n\nDeploy the method of successive linear problems for finding an eigentriple of L.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the nonlinear eigenvalue problem.\nz: Initial guess for the eigenvalue.\nmaxiter::Integer=10: Maximum number of iterations.\ntol=0: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is abs(z0-z1)<tol the iteration is aborted.\nrelax=1: relaxation parameter\nlam_tol=Inf: tolerance for the auxiliary eigenvalue to test convergence. The default is infinity, so there is effectively no test.\norder::Integer=1: Order of the Householder method, Maximum is 5\nnev::Integer=1: Number of Eigenvalues to be searched for in intermediate ARPACK calls.\nv0::Vector: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with ones.\nv0_adj::Vector: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with v0.\nnum_order::Int=1: order of the numerator polynomial when forming the Padé approximant.\nscale::Number=1: scaling factor applied to the tolerance (and the eigenvalue output when output==true).\noutput::Bool=false: Toggle printing online information.\n\nReturns\n\nsol::Solution\nn::Integer: Number of perforemed iterations\nflag::Integer: flag reporting the success of the method. Most important values are 1: method converged, 0: convergence might be slow, -1:maximum number of iteration has been reached. For other error codes see the source code.\n\nNotes\n\nThis is a variation of the method of succesive linear Problems [1] as published in Algorithm 3 in [2]. It treats the eigenvalue ω as a parameter in a linear eigenvalue problem L(ω)p=λYp and computes the root of the implicit relation λ(ω)==0.\n\nThe default values \"order==1\" and \"num_order==1\" will result in a Newton-iteration for finding the roots. Choosing a higher order will result in Housholder methods as a generalization of Newton's method. If no relaxation is used (relax == 1), the convergence rate is of order+1. With relaxation (relax != 1) the convergence rate is 1. Thus, with a higher order less iterations will be necessary. However, the computational time must not necessarily improve nor do the convergence properties. Anyway, if the method converges, the error in the eigenvalue is bounded above by tol. For more details on the solver, see the thesis [2].\n\nHouseholder methods are based on expanding the relation λ=λ(ω) into a [1/order-1]-Padé approximant. The numerator order may be increased using the keyword \"num_order\". This feature is experimental.\n\nReferences\n\n[1] A.Ruhe, Algorithms for the non-linear eigenvalue problem, SIAM J. Numer. Anal. ,10:674–689, 1973.\n\n[2] V. Mehrmann and H. Voss (2004), Nonlinear eigenvalue problems: A challenge for modern eigenvalue methods, GAMM-Mitt. 27, 121–152.\n\n[3] G.A. Mensah, Efficient Computation of Thermoacoustic Modes, Ph.D. Thesis, TU Berlin, 2019 doi:10.14279/depositonce-8952 \n\nSee also: beyn, inveriter, lancaster, rf2s, traceiter, decode_error_flag\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.perturb!","text":"perturb!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nFor large perturbation orders N the method might be slow.\n\nSee also: perturb_fast!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb_fast!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.perturb_fast!","text":"perturb_fast!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nThis method reads multi-indeces for the computation of the power series coefficients from disk. Make sure that JulHoltz is properly installed to use this fast method.\n\nSee also: perturb!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb_norm!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.perturb_norm!","text":"perturb_norm!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nThis method reads multi-indeces for the computation of the power series coefficients from disk. Make sure that JulHoltz is properly installed to use this fast method.\n\nSee also: perturb!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.pos_test-Tuple{Any,Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.pos_test","text":"Ω,P=pos_test(Ω,P,Γ)\n\nFilter eigenpairs Ω and Pfor those whose eigenvalues lie inside Γ.\n\nSee also: moments2eigs\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.rf2s","text":"sol,n,flag = rf2s(L,z;maxiter=10,tol=0., relax=1., x0=[],y0=[], output=true)\n\nDeploy two sided Rayleigh-functional iteration for finding an eigentriple of L.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the nonlinear eigenvalue problem.\nz: Initial guess for the eigenvalue.\nmaxiter::Integer=10: Maximum number of iterations.\ntol=0: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is abs(z0-z1)<tol the iteration is aborted.\nrelax=1: relaxation parameter\nx0::Vector: initial guess for right eigenvector. If not provided it is the first basis vector [1 0 0 0 ...].\ny0::Vector: initial guess for left eigenvector. If not provided it is the first basis vector `[1 0 0 0 ...].\noutput::Bool: Toggle printing online information.\n\nReturns\n\nsol::Solution\nn::Integer: Number of perforemed iterations\nflag::Integer: flag reporting the success of the method. Most important values are 1: method converged, 0: convergence might be slow, -1:maximum number of iteration has been reached. For other error codes see the source code.\n\nNotes\n\nThe algorithm is known to have a cubic convergence rate. Its implementation follows Algorithm 4.9 in [1].\n\nReferences\n\n[1] S. Güttel and F. Tisseur, The Nonlinear Eigenvalue Problem, 2017, http://eprints.ma.man.ac.uk/2531/.\n\nSee also: beyn, inveriter, lancaster, mslp, traceiter, decode_error_flag\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.save-Tuple{Any,WavesAndEigenvalues.NLEVP.LinearOperatorFamily}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.save","text":"save(fname::String,L::LinearOperatorFamily)\n\nSave L to file fname. The file is utf8 encoded and adheres to a Julia-enriched TOML standard.\n\nSee also: LinearOperatorFamily\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.solve-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.solve","text":"solve(L,Γ;<keywordarguments>)\n\nFind eigenvalues of linear operator family L inside contour Γ.\n\nArguments\n\nL::LinearOperatorFamily: Linear operator family for which eigenvalues are to be found\nΓ::List: List of complex points defining the contour.\n\nKeywordarguments (optional)\n\nΔl::Int=1: Increment to the search space dimension in Beyn's algorithm\nN::Int=16: Number of integration points per edge of Γ.\ntol::Float=1E-8: Tolerance for local eigenvalue solver.\neigvals::Dict=Dict(): Dictionary of known eigenvalues and corresponding eigenvectors.\nmaxcycles::Int=1: Number of local correction cycles to global eigenvalue estimate.\nnev::Int=1: Number of tested eigenvalues for finding the best local match to the global estimates.\nmax_outer_cycles::Int=1: Number of outer cycles, i.e., incremental increases to the search space dimension by Δl.\natol_σ::Float=1E-12: absolute tolerance for terminating the inner cycle if the maximum singular value is σ<atol_σ`\nrtol_σ::Float=1E-8: relative tolerance for terminating the inner cycle if the the ratio of the initial and the current maximum singular value is σ/σ0<rtol_σ\nloglevel::Int=0: loglevel value between 0 (no output) and 2 (max output) to control the detail of printed output.\n\nReturns\n\neigvals::Dict:List of computed eigenvalues and corresponding eigenvectors.\n\nNotes\n\nThe algorithm is experimental. It startes with a low-dimensional Beyn integral. From which estimates to the eigenvalues are computed. These estimates are used to analytically correct Beyn's integral. This step requires no additional numerical integration and is therefore relatively quick. New local estimates are computed and if the local solver then found new eigenvalues these are used to further correct Beyn's integral. In an optional outer loop the entire procedure can be repeated, after increasing the search space dimension.\n\nSee also: householder, beyn\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.traceiter","text":"sol,n,flag = traceiter(L,z;maxiter=10,tol=0.,relax=1.,output=true)\n\nDeploy trace iteration for finding an eigevalue of L.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the nonlinear eigenvalue problem.\nz: Initial guess for the eigenvalue.\nmaxiter::Integer=10: Maximum number of iterations.\ntol=0: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is abs(z0-z1)<tol the iteration is aborted.\nrelax=1: relaxation parameter\noutput::Bool: Toggle printing online information.\n\nReturns\n\nsol::Solution\nn::Integer: Number of perforemed iterations\nflag::Integer: flag reporting the success of the method. Most important values are 1: method converged, 0: convergence might be slow, -1:maximum number of iteration has been reached. For other error codes see the source code.\n\nNotes\n\nThe algorithm applies Newton-Raphson iteration for finding the root of the determinant. The updates for the iterates are computed by using trace operations and  Jacobi's formula [1]. The trace operation renders the method slow and inaccurate for medium and large problems.\n\nReferences\n\n[1] S. Güttel and F. Tisseur, The Nonlinear Eigenvalue Problem, 2017, http://eprints.ma.man.ac.uk/2531/.\n\nSee also: beyn, inveriter, lancaster, mslp, rf2s, decode_error_flag\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.wn-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.wn","text":"w=wn(z,Γ)\n\nCompute winding number, i.e., how often Γ is wrapped around z. The sign of the winding number indocates the wrapping direction.\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#Private-functionality:","page":"The NLEVP module","title":"Private functionality:","text":"","category":"section"},{"location":"NLEVP.html","page":"The NLEVP module","title":"The NLEVP module","text":"Modules = [WavesAndEigenvalues.NLEVP]\nPublic=false","category":"page"},{"location":"NLEVP.html#Base.size-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily}","page":"The NLEVP module","title":"Base.size","text":"d=size(L::LinearOperatorFamily)\n\nGet dimension d of d×d linear operator family L.\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.initialize_V-Tuple{Int64,Int64}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.initialize_V","text":"V=initialize_V(d::Int,l::Int,random::Bool=false)\n\ninitialioze matrix with drows and l colums either as diagonal matrix featuring ones on the main diagonal and anywhere else or with random entries (random=true).\n\nSee also: generate_subspace\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.polyval-Tuple{Any,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.polyval","text":"f=polyval(p,z)\n\nEvaluate polynomial f(z)=∑_i p[i]z^1 at z, using Horner's scheme.\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.project-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.project","text":"P::LinearOperatorFamily=project(L::LinearOperatorFamily,Q)\n\nProject L on the subspace spanned by the unitary matrix Q, i.e. P(z)=Q'*L(z)*Q.\n\nSee also: generate_subspace\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.read_toml-Tuple{Any}","page":"The NLEVP module","title":"WavesAndEigenvalues.NLEVP.read_toml","text":"This is a minimal TOML parser. See https://en.wikipedia.org/wiki/TOML\n\n\n\n\n\n","category":"method"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"EditURL = \"<unknown>/tutorial_03_local_eigenvalue_solver.jl\"","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#Tutorial-03-A-Local-Eigenvalue-Solver","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"This tutorial will teach you the details of the local eigenvalue solver. The solver is a generalization of the method of successive linear problems [1], in the sense that it enables not only Newton's method for root finding, but also high order Householder iterations. The implementation closely follows the considerations in [2].","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#Model-set-up.","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Model set-up.","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"The model is the same Rijke tube configuration as in Tutorial 01:","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"using WavesAndEigenvalues.Helmholtz\nmesh=Mesh(\"Rijke_mm.msh\",scale=0.001) #load mesh\ndscrp=Dict() #initialize model descriptor\ndscrp[\"Interior\"]=(:interior, ()) #define resonant cavity\ndscrp[\"Outlet\"]=(:admittance, (:Y,1E15)) #specify outlet BC\nγ=1.4 #ratio of specific heats\nρ=1.225 #density at the reference location upstream to the flame in kg/m^3\nTu=300.0    #K unburnt gas temperature\nTb=1200.0    #K burnt gas temperature\nP0=101325.0 #ambient pressure in Pa\nA=pi*0.025^2 #cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1) #the ratio of mean heat release to mean velocity Q02U0\nx_ref=[0.0; 0.0; -0.00101] #reference point\nn_ref=[0.0; 0.0; 1.00] #directional unit vector of reference velocity\nn=0.01 #interaction index\nτ=0.001 #time delay\ndscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ)) #flame dynamics\nR=287.05 # J/(kg*K) specific gas constant (air)\nspeedofsound(x,y,z) = z<0. ? sqrt(γ*R*Tu) : sqrt(γ*R*Tb)\nc=generate_field(mesh,speedofsound)\nL=discretize(mesh,dscrp,c)","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#The-local-solver","page":"Tutorial 03  A Local Eigenvalue Solver","title":"The local solver","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"The key idea behind the local solver is simple: The eigenvalue problem L(ω)p==0 is reinterpreted as L(ω)p == λ*Y*p. This means, the nonlinear eigenvalue ω becomes a parameter in a linear eigenvalue problem with (auxiliary) eigenvalue λ. If an ω is found such that λ==0, this very ω solves the original non-linear eigenvalue problem. Because the auxiliary eigenvalue problem is linear the implicit relation λ=λ(ω) can be examined with established perturbation theory of linear eigenvalue problems. This theory can be used to compute the derivative dλ/dω and iteratively find the root of λ=λ(ω). Each of these iterations requires solving a linear eigenvalue problem and higher order derivatives improve the  iteration. The options of the local-solver mslp allows the user to control the solution process.","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#Mandatory-inputs","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Mandatory inputs","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"Mandatory input arguments are only the linear operator family L and an initial guess z for the eigenvalue ω` iteration.","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"z=300.0*2*pi\nsol,nn,flag = mslp(L, z)","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#Maximum-iterations","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Maximum iterations","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"As per default five iterations are performed. This iteration number can be customized using the keyword maxiter For instance the following command runs 30 iterations","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"sol,nn,flag = mslp(L, z, maxiter=30)","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#A-stopping-crtierion","page":"Tutorial 03  A Local Eigenvalue Solver","title":"A stopping crtierion","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"Usually, the procedure converges after a few iteration steps and further iterations do not significantly improve the solution. For this reason the keyword tol allows for setting a threshold, such that two consecutive iterates for the eigenvalue fulfill abs(ω_0-ω_1), the iteration is terminated. This keyword defaults to tol=0.0 and, thus, maxiter iterations will be performed. However, it is highly recommended to set the parameter to some positive value whenever possible.","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"sol,nn,flag = mslp(L, z, maxiter=30, tol=1E-10)","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"Note that the tolerance is also a bound for the error associated with the computed eigenvalue. Tip: The 64-bit floating numbers have an accuracy of eps≈1E-16. Hence, the threshold tol should not be chosen less than 16 orders of magnitude smaller than the expected eigenvalue. Indeed, tol=1E-10 is already close to the machine-precision we can expect for the Rijke-tube model.","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#Convergence-checks","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Convergence checks","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"Technically, the iteration may stop because of slow progress in the iteration rather than actual convergence. A simple indicator for actual convergence is the auxiliary eigenvalue λ. The closer it is to 0 the better is the quality of the computed solution. To help the identification of falsely terminated iterations you can specify another tolerance lam_tol. If abs(λ)>lam_tol the computed eigenvalue is deemed to be spurious. This feature only makes sense when a termination threshold has been specified. As in the following example:","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"sol,nn,flag = mslp(L, z, maxiter=30, tol=1E-10, lam_tol=1E-8)","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#Faster-convergence","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Faster convergence","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"In order to improve the convergence rate, higher-order derivatives may be computed. You high-order perturbation theory to improve the iteration via the order keyword. For instance, third-order theory is used in this example","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"sol,nn,flag = mslp(L, z, maxiter=30, tol=1E-10, lam_tol=1E-8, order=3)","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"Under the hood the routine calls ARPACK to utilize Arnoldi's method to solve the linear (auxiliary) eigenvalue problem. This method can compute more than one eigenvalue close to some initial guess. Per default, only one is sought but via the nev keyword the number can be increased. This results in an increased computation time but provides more candidates for the next iteration, potentially improving the convergence.","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"sol,nn,flag = mslp(L, z, maxiter=30, tol=1E-10, lam_tol=1E-8, nev=3)","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#Summary","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Summary","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"Iterative solver like the mslp solver are a great opportunity to refine solutions found from Beyn's integration-based method. The tutorial gave you more insight in how to use the keywords for mslp.","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"The next tutorial will explain how to post-process highly accurate solutions from an iterative solver using perturbation theory.","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html#References","page":"Tutorial 03  A Local Eigenvalue Solver","title":"References","text":"","category":"section"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"[1] S. Güttel and F. Tisseur, The Nonlinear Eigenvalue Problem, 2017, http://eprints.ma.man.ac.uk/2538/","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"[2] G.A. Mensah, A. Orchini, J.P. Moeck, Perturbation theory of nonlinear, non-self-adjoint eigenvalue problems: Simple eigenvalues, JSV, 2020, doi:10.1016/j.jsv.2020.115200","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"","category":"page"},{"location":"tutorial_03_local_eigenvalue_solver.html","page":"Tutorial 03  A Local Eigenvalue Solver","title":"Tutorial 03  A Local Eigenvalue Solver","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"EditURL = \"<unknown>/tutorial_05_mesh_refinement.jl\"","category":"page"},{"location":"tutorial_05_mesh_refinement.html#Tutorial-05-Mesh-Refinement","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"","category":"section"},{"location":"tutorial_05_mesh_refinement.html#Intro","page":"Tutorial 05 Mesh Refinement","title":"Intro","text":"","category":"section"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"This tutorial introduces you to utilities for performing mesh-refinement. The main comand here is finer_mesh=octosplit(mesh), which splits all tetrahedral cells in mesh by bisecting each edge. This will lead to a subdivision of each tetrahedron into eight new tetrahedra. Such a division is not unique. There are three ways of splitting a tetrahedron into eight new tetrahedra and bisecting all six original edges. octosplit chooses the splitting such that the maximum of the newly created edges is minimized.","category":"page"},{"location":"tutorial_05_mesh_refinement.html#Basic-set-up","page":"Tutorial 05 Mesh Refinement","title":"Basic set-up","text":"","category":"section"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"We start with initializing the standard Rijke-Tube example.","category":"page"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"using WavesAndEigenvalues.Helmholtz\nmesh=Mesh(\"Rijke_mm.msh\",scale=0.001)\ndscrp=Dict() #initialize model descriptor\ndscrp[\"Interior\"]=(:interior, ()) #define resonant cavity\ndscrp[\"Outlet\"]=(:admittance, (:Y,1E15)) #specify outlet BC\nγ=1.4 #ratio of specific heats\nρ=1.225 #density at the reference location upstream to the flame in kg/m^3\nTu=300.0    #K unburnt gas temperature\nTb=1200.0    #K burnt gas temperature\nP0=101325.0 #ambient pressure in Pa\nA=pi*0.025^2 #cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1) #the ratio of mean heat release to mean velocity Q02U0\nx_ref=[0.0; 0.0; -0.00101] #reference point\nn_ref=[0.0; 0.0; 1.00] #directional unit vector of reference velocity\nn=0.01 #interaction index\nτ=0.001 #time delay\ndscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ)) #flame dynamics\nR=287.05 # J/(kg*K) specific gas constant (air)\nspeedofsound(x,y,z) = z<0. ? sqrt(γ*R*Tu) : sqrt(γ*R*Tb)\nc=generate_field(mesh,speedofsound)\nL=discretize(mesh,dscrp,c)\nsol,nn,flag=householder(L,400*2*pi,maxiter=10)\ndata=Dict()\ndata[\"speed_of_sound\"]=c\ndata[\"abs\"]=abs.(sol.v)/maximum(abs.(sol.v)) #normalize so that max=1\ndata[\"phase\"]=angle.(sol.v)\nvtk_write(\"test\", mesh, data) # Write the solution to paraview","category":"page"},{"location":"tutorial_05_mesh_refinement.html#refine-mesh","page":"Tutorial 05 Mesh Refinement","title":"refine mesh","text":"","category":"section"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"Now let's call octosplit for creating the refined mesh","category":"page"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"fine_mesh=octosplit(mesh)","category":"page"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"and solve the problem again with the fine mesh for comparison.","category":"page"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"c=generate_field(fine_mesh,speedofsound)\nL=discretize(fine_mesh,dscrp,c)\nsol,nn,flag=householder(L,400*2*pi,maxiter=10)\n#write to file\ndata=Dict()\ndata[\"speed_of_sound\"]=c\ndata[\"abs\"]=abs.(sol.v)/maximum(abs.(sol.v)) #normalize so that max=1\ndata[\"phase\"]=angle.(sol.v)\nvtk_write(\"fine_test\", fine_mesh, data) # Write the solution to paraview\n\n# If you think that's not enough, well, then try...\nfine_mesh=octosplit(fine_mesh)","category":"page"},{"location":"tutorial_05_mesh_refinement.html#Summary","page":"Tutorial 05 Mesh Refinement","title":"Summary","text":"","category":"section"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"The octosplit-function allows you to refine your mesh by bisecting all edges. This creates a new mesh with eight-times as many tetrahedral cells. The tool is quite useful for running h-convergence tests for your set-up.","category":"page"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"","category":"page"},{"location":"tutorial_05_mesh_refinement.html","page":"Tutorial 05 Mesh Refinement","title":"Tutorial 05 Mesh Refinement","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Welcome to the documentation of WavesAndEigenvalues.jl.","category":"page"},{"location":"index.html#What-is-WavesAndEigenvalues.jl?","page":"Home","title":"What is WavesAndEigenvalues.jl?","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package has evolved from academic research in thermoacoustic-stability analysis. But it is designed fairly general. It currently contains three modules, each of which is targeting at one of the main design goals:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Provide an elaborate interface to define, solve, and perturb nonlinear eigenvalues (NLEVP)\nProvide a lightweight interface to read unstructured tetrahedral meshes using nastran (*.bdf and *.nas) or the latest gmsh format (*.msh). (Meshutils)\nProvide a convenient interface for solving the (thermo-acoustic) Helmholtz equation. (Helmholtz)","category":"page"},{"location":"index.html#NLEVP","page":"Home","title":"NLEVP","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Assume you are a literally a rocket scientist and you want to solve an eigenvalue problem like","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(mathbf K+omega mathbf C + omega^2 mathbf M+ nexp(-iomegatau) mathbf Fmathbf p = 0","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Where mathbf K, mathbf C, mathbf M, and mathbf F are some matrices, i the imaginary unit, n and tau some parameters, and omega and mathbf p unknown eigenpairs. Then the NLEVP module lets you solve this equation and much more. Actually, any non-linear eigenvalue problem can be solved. Doing science in some other field than rockets or even being a pure mathematician is, thus, no problem at all. Just specify your favourite nonlinear eigenvalue problem and have fun. And fun here includes adjoint-based perturbation of your solution up to arbitrary order!  ","category":"page"},{"location":"index.html#Meshutils","page":"Home","title":"Meshutils","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"OK, this was theoretical. But you are a real scientist, so you know that the matrices mathbf K, mathbf C, mathbf M, and mathbf F are obtained by discretizing some equation using a specific mesh. You do not want to be too limited to simple geometries so unstructured tetrahedral meshing is the method of choice.  Meshutils is the module that gives you the tools to read and process such meshes.","category":"page"},{"location":"index.html#Helmholtz","page":"Home","title":"Helmholtz","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"You are a practitioner? Fine, then eigenvalue theory and mesh handling should not bother your every day work too much. You just want to read in a mesh, specify some properties (boundary conditions, speed of sound field...), and get a report on the stability of your configuration? Helmholtz is your module! It even tells you how to optimize your design.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"EditURL = \"<unknown>/tutorial_04_perturbation_theory.jl\"","category":"page"},{"location":"tutorial_04_perturbation_theory.html#Tutorial-04-Perturbation-Theory","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"","category":"section"},{"location":"tutorial_04_perturbation_theory.html#Introduction","page":"Tutorial 04 Perturbation Theory","title":"Introduction","text":"","category":"section"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"This tutorial demonstrates how high-order perturbation theory is utilized using the WavesAndEigenvalues package. You may ask: 'What is perturbation theory?' Well, perturbation theory deals with the approximation of a solution of a mathematical problem based on a known solution of a problem similar to the problem of interest. (Puhh, that was a long sentence...) The problem is said to be perturbed from a baseline solution. You can find a comprehensive presentation of the internal algorithms in [1,2].","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"note: Note\nThe following example uses perturbation theory up to 30th order. Per default WavesAndEigenvalues.jl is built to run perturbation theory to 16th order. You can reconfigure your installation for higher orders by setting an environment variable and then rebuild the package. For instance this tutorial requires ENV[\"JULIA_WAE_PERT_ORDER\"]=30 for setting the variable and a subsequent ] build WavesAndEigenvalues to rebuild the package. This process may take a few minutes. If you don't make the environment variable permanent, these steps will be necessary once every time you got any update to the package from Julia's package manager. Also note that higher orders take significantly more memory of your installation directory.","category":"page"},{"location":"tutorial_04_perturbation_theory.html#Model-set-up-and-baseline-solution","page":"Tutorial 04 Perturbation Theory","title":"Model set-up and baseline-solution","text":"","category":"section"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"The model is the same Rijke tube configuration as in Tutorial 01:","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"using WavesAndEigenvalues.Helmholtz\nmesh=Mesh(\"Rijke_mm.msh\",scale=0.001) #load mesh\ndscrp=Dict() #initialize model descriptor\ndscrp[\"Interior\"]=(:interior, ()) #define resonant cavity\ndscrp[\"Outlet\"]=(:admittance, (:Y,1E15)) #specify outlet BC\nγ=1.4 #ratio of specific heats\nρ=1.225 #density at the reference location upstream to the flame in kg/m^3\nTu=300.0    #K unburnt gas temperature\nTb=1200.0    #K burnt gas temperature\nP0=101325.0 # ambient pressure in Pa\nA=pi*0.025^2 # cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1) #the ratio of mean heat release to mean velocity Q02U0\nx_ref=[0.0; 0.0; -0.00101] #reference point\nn_ref=[0.0; 0.0; 1.00] #directional unit vector of reference velocity\nn=1 #interaction index\nτ=0.001 #time delay\ndscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ)) #flame dynamics\nR=287.05 # J/(kg*K) specific gas constant (air)\nspeedofsound(x,y,z) = z<0. ? sqrt(γ*R*Tu) : sqrt(γ*R*Tb)\nc=generate_field(mesh,speedofsound)\nL=discretize(mesh,dscrp,c)","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"1006×1006-dimensional operator family: \n\nω^2*M+K+n*exp(-iωτ)*Q+ω*Y*C\n\nParameters\n----------\nn\t1.0 + 0.0im\nλ\tInf + 0.0im\nω\t0.0 + 0.0im\nτ\t0.001 + 0.0im\nY\t1.0e15 + 0.0im\n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"To obtain a baseline solution we solve it using an iterative solver with a very small stopping tollerance of tol=1E-11.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"sol,nn,flag=mslp(L,340*2*pi,maxiter=20,tol=1E-11)","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"(####Solution####\neigval:\nω = 1075.325211506839 + 372.1017670372039im\n\nParameters:\nn = 1.0 + 0.0im\nλ = 2.336203477100084e-8 + 6.515535987345233e-10im\nτ = 0.001 + 0.0im\nY = 1.0e15 + 0.0im\n, 8, 0)","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"this small tolerance is necessary because as the name suggests the base-line solution is the basis to our subsequent steps. If it is inaccurate we will definetly also encounter inaccurate approximations to other configurations than the base-line set-up.","category":"page"},{"location":"tutorial_04_perturbation_theory.html#Taylor-series","page":"Tutorial 04 Perturbation Theory","title":"Taylor series","text":"","category":"section"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Probably, you are somewhat familiar with the concept of Taylor series which is a basic example of perturbation theory. There is some function f from which the value f(x_0) is known together with some derivatives at the same point, the first N say. Then, we can approximate f(x_0+Delta) as:","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"f(x_0+Delta)approx sum_n=0^N f_n(x_0)Δ^n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Let's consider the time delay τ. Our problem depends exponentially on this value.  We can utilize a fast perturbation algorithm to compute the first 20 Taylor-series coefficients of the eigenfrequency ω w.r.t. τ by just typing","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"perturb_fast!(sol,L,:τ,20)","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"The output shows you how long it takes to compute the coefficients. Obviously, it takes longer and longer for higher order coefficients. Note, that there is also an algorithm perturb!(sol,L,:τ,20) which does exactly the same as the fast algorithm but is slower, when it comes to high orders (N>5).","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Both algorithms populate a field in the solution object holding the Taylor coefficients.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"sol.eigval_pert","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Dict{Symbol, Any} with 1 entry:\n  Symbol(\"τ/Taylor\") => ComplexF64[1075.33+372.102im, -2.62868e5+3.40796e5im, -1.79944e8-1.475e8im, 9.4741e10-1.57309e11im, 1.66943e14+8.14274e13im, -8.3483e16+1.86246e17im, -2.15622e20-9.17653e19im, 1.05357e23-2.58704e23im, 3.19354e26+1.25588e26im, -1.54315e29+4.02817e29im, -5.16822e32-1.94111e32im, 2.48748e35-6.72431e35im, 8.85193e38+3.23647e38im, -4.26474e41+1.17688e42im, -1.57803e45-5.68031e44im, 7.63541e47-2.13155e48im, 2.89779e51+1.0345e51im, -1.41133e54+3.9619e54im, -5.44414e57-1.93716e57im, 2.67322e60-7.51468e60im, 1.04148e64+3.70668e63im]","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"We can use these values to form the Taylor-series approximation and for convenience we can just do so by calling to the solution object itself. For instance let's assume we would like to approximate the value of the eigenfrequency when τ==0.0015 based on the 20th order series expansion.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Δ=0.0005\nω_approx=sol(:τ,τ+Δ,20)","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"916.7085040155473 + 494.3258317478708im","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Let's compare this value to the true solution:","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"L.params[:τ]=τ+Δ #change parameter\nsol_exact,nn,flag=mslp(L,ω_approx,maxiter=20,tol=1E-11) #solve again\nω_exact=sol_exact.params[:ω]\nprintln(\" exact=$(ω_exact/2/pi)  vs  approx=$(ω_approx/2/pi))\")","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Launching MSLP solver...\nIter   dz:     z:\n----------------------------------\n0\t\tInf\t916.7085040155473 + 494.3258317478708im\n1\t\t0.006009923194378605\t916.7036137652204 + 494.32932526022125im\n2\t\t2.5654097406043415e-8\t916.7036137579167 + 494.3293252848137im\n3\t\t1.622588396708824e-11\t916.7036137579236 + 494.329325284799im\n4\t\t2.157056083093525e-12\t916.7036137579256 + 494.32932528479967im\nSolution has converged!\n...finished MSLP!\n#####################\n Results \n#####################\nNumber of steps: 4\nLast step parameter variation:2.157056083093525e-12\nAuxiliary eigenvalue λ residual (rhs):5.804108531973829e-9\nEigenvalue:916.7036137579256 + 494.32932528479967im\n exact=145.89791147977746 + 78.67495563435732im  vs  approx=145.89868978845095 + 78.6743996206862im)\n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Clearly, the approximation matches the first 4 digits after the decimal!","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"We can also compute the approximation at any lower order than 20. For instance, the first-order approximation is:","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"ω_approx=sol(:τ,τ+Δ,1)\nprintln(\" first-order approx=$(ω_approx/2/pi)\")","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":" first-order approx=150.22496667319837 + 86.34150633981955im\n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Note that the accuracy is less than at twentieth order.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Also note that we cannot compute the perturbation at higher order than 20 because we have only computed the Taylor series coefficients up to 20th order. Of course we could, prepare higher order coefficients, let's say up to 30th order by","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"perturb_fast!(sol,L,:τ,30)","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"and then","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"ω_approx=sol(:τ,τ+Δ,30)\nprintln(\" 30th-order approx=$(ω_approx/2/pi)\")","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":" 30th-order approx=145.8978874014616 + 78.67497208762059im\n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Ok, we've seen how we can compute Taylor-series coefficients and how to evaluate them as a Taylor series. But how do we choose parameters like the baseline set-up or the perturbation order to get a reasonable estimate? Well there is a lot you can do but, unfortunately, there are a lot of misunderstandings when it comes to the quality perturbative approximations.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Take a second and try to answer the following questions:","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"What is the range of Δ in which you can expect reliable results from the approximation, i.e., the difference from the true solution is small?\nHow does the quality of your approximation improve if you increase the number of known derivatives?\nWhat else can you do to improve your solution?","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Regarding the first question, many people misbelieve that the approximation is good as long as Δ (the shift from the expansion point) is small. This is right and wrong at the same time. Indeed, to classify Δ as small, you need to compare it against some value. For Taylor series this is the radius of convergence. Convergence radii can be quite huge and sometimes super small. Also keep in mind that the numerical value of Δ in most engineering applications is meaningless if it is not linked to some unit of measure. (You know the joke: What is larger, 1 km or a million mm?)","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"So how do we get the radius of convergence? It's as simple as","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"r=conv_radius(sol,:τ)","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"30-element Vector{Float64}:\n 0.0026438071359421856\n 0.0018498027477203886\n 0.0012670310435927681\n 0.0009886548876531008\n 0.0009100554815832927\n 0.0008709697017278116\n 0.000838910762099998\n 0.0008140058757174155\n 0.0007955250149644752\n 0.0007813536279922974\n 0.0007700125089152769\n 0.0007607027504841114\n 0.000752936147548007\n 0.0007463656620716248\n 0.0007407359084332154\n 0.0007358585624584575\n 0.0007315926734366027\n 0.0007278304643904657\n 0.0007244879957019495\n 0.0007214989316859786\n 0.0007188101801265639\n 0.0007163787543387638\n 0.0007141694816882979\n 0.0007121533078940557\n 0.0007103060243302641\n 0.0007086072999209774\n 0.000707039935855723\n 0.0007055892855979911\n 0.0007042427990056821\n 0.0007029896606802446","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"The return value here is an array that holds N-1 values, where N is the order of Taylor-series coefficients that have been computed for :τ. This is because the convergence radius is estimated based on the ratio of two consecutive Taylor-series coefficients. Usually, the last entry of r should give you the best approximate.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"println(\"Best estimate available: r=$(r[end])\")","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Best estimate available: r=0.0007029896606802446\n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"However, there are cases where the estimation procedure for the convergence radius is not appropriate. That is why you can have a look on the other entries in r to judge whether there is smooth convergence. Let's see what's happening if we evaluate the Taylor series beyond it's radius of convergence. We therefore try to find an approximation for a two that is  twice our estimate for r away from the baseline value.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"ω_approx=sol(:τ,τ+r[end]*2,20)\nL.params[:τ]=τ+r[end]*2\nsol_exact,nn,flag=mslp(L,ω_approx,maxiter=20,tol=1E-11) #solve again\nω_exact=sol_exact.params[:ω]\nprintln(\" exact=$(ω_exact/2/pi)  vs  approx=$(ω_approx/2/pi))\")","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Launching MSLP solver...\nIter   dz:     z:\n----------------------------------\n0\t\tInf\t8.879592083136003e6 - 1.1737122716657885e6im\n1\t\t4.0600651883038566e6\t4.870901607915898e6 - 529872.223861651im\n2\t\t1.682178480929161e6\t3.225729888267407e6 - 178967.03072543198im\n3\t\t437944.1873905101\t2.8166148076510336e6 - 22698.153205330833im\n4\t\t34045.990823039225\t2.7910564230047897e6 - 205.96644198751892im\n5\t\t207.55279886998233\t2.7910300114278947e6 - 0.1009691061235003im\n6\t\t0.012185956885981062\t2.791030020923184e6 - 0.1086069737550432im\n7\t\t4.672416133789498e-10\t2.7910300209231847e6 - 0.10860697371664671im\n8\t\t2.2028212587343887e-13\t2.7910300209231847e6 - 0.10860697371686699im\nSolution has converged!\n...finished MSLP!\n#####################\n Results \n#####################\nNumber of steps: 8\nLast step parameter variation:2.2028212587343887e-13\nAuxiliary eigenvalue λ residual (rhs):0.0011653820248254138\nEigenvalue:2.7910300209231847e6 - 0.10860697371686699im\n exact=444206.22414780094 - 0.01728533672129094im  vs  approx=1.413230972670755e6 - 186802.10980322777im)\n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Outch, the approximation is completely off. Also note that the exact solutions has a ridicoulously high value. What's happening here? Well, because  we are evaluating the power series outside of its convergence radius, we find an extremely high value. Keep in mind that any quadratic or higher polynomial will tend to infinity when its argument tends to infinity. Because our estimate is nonsense but high and because we use this estimate to initialize our iterative solver, we also find a high exact eigenvalue which of course does not match our estimate. Remember question 2? Maybe the estimate gets better if we increase the perturbation order ? At least the last time we've seen an improvement. But this time...","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"ω_approx=sol(:τ,τ+r[end]+0.001,30)\nprintln(\"approx=$(ω_approx/2/pi))\")","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"approx=-4.308053889489341e11 + 1.7221050696555923e10im)\n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"things get way worse! A higher order polynomial tends faster to infinity, therefore our is now extremely large. Indeed, if we would feed it into the iterative solver it would trigger an error, because the code can't handle numbers this large.  The large magnitude of the result is exactly the reason why some clever person named r the radius of convergence. Beyond that radius we cannot make the Taylor-series converge without shifting the expansion point. You might think: \"Well, then let's shift the expansion point!\" While this is definitely a valid approach, there is something better you can do...","category":"page"},{"location":"tutorial_04_perturbation_theory.html#Series-accelaration-by-Padé-approximation","page":"Tutorial 04 Perturbation Theory","title":"Series accelaration by Padé approximation","text":"","category":"section"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"The Taylor-series cannot converge beyond its radius of convergence. So why not trying something else than a Taylor-series? The truncated Taylor series is a polynomial approximation to our unknown relation ω=ω(τ). An alternative (if not to say a generalization) of this approach is to consider rational polynomial approximations.  So instead of f(x_0+Δ)_n=0^N f_n(x_0)Δ^n we try something like","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"f(x_0+Δ)fracsum_l=0^L a_l(x_0)Δ^l  1 + sum_m=0^M b_m(x_0)Δ^m ","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"This approach is known as Padé approximation. In order to get the same asymptotic behavior close to our expansion point, we demand that the truncated Taylor series expansion of our Padé approximant is identical to the approximation of our unknown function. Here comes the clou: we already know these values because we computed the Taylor-series coefficients. Only little algebra is needed to convert the Taylor coefficients to Padé coefficients and all of this is built in to the solution type. All you need to know is that the number of Padé coefficients is related to the number of Taylor coefficients by the simple formula L+M=N. Let's give it a try and compute the Padé approximant for L=M=10 (a so-called diagonal Padé approximant). This is just achieve by an extra argument for the call to our solution object.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"ω_approx=sol(:τ,τ+r[end]*2,10,10)\nsol_exact,nn,flag=mslp(L,ω_approx,maxiter=20,tol=1E-11)\nω_exact=sol_exact.params[:ω]\nprintln(\" exact=$(ω_exact/2/pi)  vs  approx=$(ω_approx/2/pi))\")","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Launching MSLP solver...\nIter   dz:     z:\n----------------------------------\n0\t\tInf\t668.5373997804821 + 529.4636751544649im\n1\t\t4.96034674936746e-7\t668.537399929806 + 529.4636746814398im\n2\t\t4.1740258326821776e-12\t668.537399929804 + 529.4636746814361im\nSolution has converged!\n...finished MSLP!\n#####################\n Results \n#####################\nNumber of steps: 2\nLast step parameter variation:4.1740258326821776e-12\nAuxiliary eigenvalue λ residual (rhs):1.1965642295134598e-8\nEigenvalue:668.537399929804 + 529.4636746814361im\n exact=106.40103184063163 + 84.26676101314976im  vs  approx=106.40103181686632 + 84.26676108843462im)\n","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"Wow! There is now only a difference of about 0.00001hz between the true solution and it's estimate. I'would say that's fine for many engineering applications. What's your opinion?","category":"page"},{"location":"tutorial_04_perturbation_theory.html#Summary","page":"Tutorial 04 Perturbation Theory","title":"Summary","text":"","category":"section"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"You learnt how to use perturbation theory. The main computational costs for this approach is the computation of Taylor-series coefficients. Once you have them everything comes down to ta few evaluations of scalar polynomials. Especially, when you like to rapidly evalaute your model for a bunch of values in a given parameter range. This approach should speed up your computations.","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"The next tutorial will familiarize you with the use of higher order finite elements.","category":"page"},{"location":"tutorial_04_perturbation_theory.html#References","page":"Tutorial 04 Perturbation Theory","title":"References","text":"","category":"section"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"[1] G.A. Mensah, Efficient Computation of Thermoacoustic Modes, Ph.D. Thesis, TU Berlin, 2019, doi:10.14279/depositonce-8952 ","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"[2] G.A. Mensah, A. Orchini, J.P. Moeck, Perturbation theory of nonlinear, non-self-adjoint eigenvalue problems: Simple eigenvalues, JSV, 2020, doi:10.1016/j.jsv.2020.115200","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"","category":"page"},{"location":"tutorial_04_perturbation_theory.html","page":"Tutorial 04 Perturbation Theory","title":"Tutorial 04 Perturbation Theory","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"EditURL = \"<unknown>/tutorial_09_forcing.jl\"","category":"page"},{"location":"tutorial_09_forcing.html#Tutorial-09-Forcing","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"","category":"section"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"The tutorial demonstrates how to incorporate source terms into your Helmholtz model. This allows for the computation of acoustic transfer functions and similar qunatities. Currently, only boundary sources are supported. This tutorial will use the outlet wall of the rijke tube mesh, as an acoustic source. Such a case would occur when simulating acoustic excitations from a loudspeaker membrane.","category":"page"},{"location":"tutorial_09_forcing.html#Model-set-up.","page":"Tutorial 09 Forcing","title":"Model set-up.","text":"","category":"section"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"The model is the same Rijke tube configuration as in Tutorial 01.","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"The only difference is that we put a keyowrd :speaker together with some parameters in our model description. The parameters are the excitation strength and the speaker admittance.","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"In particular, the speaker forcing is derived from an impedance boundary condition p̂ - (cZ)/(iω) * ∇p̂⋅n=A where p̂ is the pressure fluctuation amplitude, c the local speed of sound, Z a normalized impedance, i the imaginary unit, ω an angular frequency, n the outward pointing unit normal, and A the excitation strength. This equation is equal to -iωY/c * p̂+∇p̂⋅n=-iωY/c*A, where the admittance is Y=1/Z. Note that for the special case of a a sound-soft impedance (Z=0 aka Y=∞) the excitation level A is identical to the pressure amplitude p̂ (p̂=A).","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"Ok let's see how it works. We start with the standard header known from tutorial 01.","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"using WavesAndEigenvalues.Helmholtz\nmesh=Mesh(\"Rijke_mm.msh\",scale=0.001) #load mesh\ndscrp=Dict() #initialize model descriptor\ndscrp[\"Interior\"]=(:interior, ()) #define resonant cavity","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"Now comes the magic line that specifies the excitation level and speaker impedance:","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"dscrp[\"Outlet\"]=(:speaker, (:A,1,:Y,1E15)); #specify outlet BC\nnothing #hide","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"The rest is the usual set-up...","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"γ=1.4; #ratio of specific heats\nρ=1.225; #density at the reference location upstream to the flame in kg/m^3\nTu=300.0;    #K unburnt gas temperature\nTb=1200.0;    #K burnt gas temperature\nP0=101325.0; # ambient pressure in Pa\nA=pi*0.025^2; # cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1); #the ratio of mean heat release to mean velocity Q02U0\nx_ref=[0.0; 0.0; -0.00101]; #reference point\nn_ref=[0.0; 0.0; 1.00]; #directional unit vector of reference velocity\nn=0.01; #interaction index\nτ=0.001; #time delay\ndscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ)); #flame dynamics\nR=287.05; # J/(kg*K) specific gas constant (air)\nspeedofsound(x,y,z) = z<0. ? sqrt(γ*R*Tu) : sqrt(γ*R*Tb);\nc=generate_field(mesh,speedofsound);\nnothing #hide","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"Note that when calling discretize the source keyword is set to true and a second term rhs is returned. This is the discretization of the right hand side.","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"L,rhs=discretize(mesh,dscrp,c,source=true,order=:quad);\nnothing #hide","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"Like L, rhs is a linear operator family but note that it is a family of vectors not matrices. You can reset parameters  after the descretization. For instance the excitation strength :A:","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"rhs.params[:A]=1;\nnothing #hide","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"note: Note\nYou may also redefine the membrane impedance :Y, but note that you then also need to redefine it in L to get consistent results. There is currently no safety mechanism checking this for you!","category":"page"},{"location":"tutorial_09_forcing.html#Solving-the-problem","page":"Tutorial 09 Forcing","title":"Solving the problem","text":"","category":"section"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"As the problem is linear solving it is an easy matter. We just use the backslash operator. For instance, finding the solution for an excitation frequency of 150 Hz reads:","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"ω=150*2*pi;\nsol=L(ω)\\Array(rhs(ω));\nnothing #hide","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"Note that the rhs is sparse, therefore, conversion to an Array is necessary as the backslash operator does not support sparse rhs. Anyways, we have a solution! We may right it to paraview, using the usual functions:","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"data=Dict();\ndata[\"150Hz abs\"]=abs.(sol);\ndata[\"150Hz phase\"]=angle.(sol);\nvtk_write(\"forcing\", mesh, data);\nnothing #hide","category":"page"},{"location":"tutorial_09_forcing.html#Summary","page":"Tutorial 09 Forcing","title":"Summary","text":"","category":"section"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"You can also discretize a source vector and use it to model forced problems. Just use the :speaker option in the model description and set soure=true in the call to discretize.","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"","category":"page"},{"location":"tutorial_09_forcing.html","page":"Tutorial 09 Forcing","title":"Tutorial 09 Forcing","text":"This page was generated using Literate.jl.","category":"page"}]
}
