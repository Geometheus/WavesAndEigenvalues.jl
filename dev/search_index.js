var documenterSearchIndex = {"docs":
[{"location":"load_mesh.html#How-to-load-a-mesh?-1","page":"How to load a mesh?","title":"How to load a mesh?","text":"","category":"section"},{"location":"load_mesh.html#","page":"How to load a mesh?","title":"How to load a mesh?","text":"First load tools from the Mesh utility module     using WavesAndEigenvalues.Meshutils Then load your mesh     Mesh(\"filename.msh\",scale=0.001) The scale parameter is optional and multiplies the coordinates of the red mesh with some number. This functionality is basically here to convert units of length.","category":"page"},{"location":"Helmholtz.html#Helmholtz-1","page":"Helmholtz","title":"Helmholtz","text":"","category":"section"},{"location":"Helmholtz.html#","page":"Helmholtz","title":"Helmholtz","text":"Modules = [WavesAndEigenvalues.Helmholtz]","category":"page"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz","text":"Module providing functionality to numerically discretize the (thermoacoustic) Helmholtz equation by first and second-order finite elements.\n\n\n\n\n\n","category":"module"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.bloch_expand","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.bloch_expand","text":"v=bloch_expand(mesh::Mesh,sol::Solution,b=:b)\n\nExpand solution vector sol.v on mesh meshwith Bloch wave number sol.params[b] and return it as v.\n\n\n\n\n\n","category":"function"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.discretize-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any,Any}","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.discretize","text":"L=discretize(mesh, dscrp, C; el_type=1, c_type=0, b=:__none__, mass_weighting=true)\n\nDiscretize the Helmholtz equation using the mesh mesh.\n\nArguments\n\nmesh::Mesh: tetrahedral mesh\ndscrp::Dict: dictionary containing information on where to apply physical constraints. Such as standard wave propagation, boundary conditions, flame responses, etc.\nC:Array: array defining the speed of sound. If c_type==0 the speed of sound is constant along one tetrahedron and length(C)==length(mesh.tetrahedra). If c_type==1 the speed of sound is linearly interpolated between the vertices of the mesh and length(C)==size(mesh.points,2).\nel_type = 1: optional paramater to select between first (el_type==1 the default) and second order (el_type==2) finite elements.\nc_type = 1: optional parameter controlling whether speed of sound is constant on a tetrahedron or linearly interpolated between vertices.\nb::Symbol=:__none__: optional parameter defining the Bloch wave number. If b=:__none__ (the default) no Blochwave formalism is applied.\nmass_weighting=true: optional parameter if true mass matrix is used as weighting matrix for householder, otherwise this matrix is not set.\n\nReturns\n\nL::LinearOperatorFamily: parametereized discretization of the specified Helmholtz equation.\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#Discretization-Order-1","page":"Helmholtz","title":"Discretization Order","text":"","category":"section"},{"location":"Helmholtz.html#","page":"Helmholtz","title":"Helmholtz","text":"Modules = [\n  WavesAndEigenvalues.Helmholtz.lin,\n  WavesAndEigenvalues.Helmholtz.quad,\n  WavesAndEigenvalues.Helmholtz.quad20,\n]","category":"page"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.lin.assemble_boundary_mass_operator-Tuple{Any,Any,Any}","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.lin.assemble_boundary_mass_operator","text":"boundary mass operator for first order elements\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.lin.assemble_stiffness_operator-Tuple{Any,Any,Any}","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.lin.assemble_stiffness_operator","text":"stiffness operator for first order elements\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.lin.assemble_volume_source-Tuple{Any,Any}","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.lin.assemble_volume_source","text":"volume source vector for first order elements\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#Mesh-1","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Modules = [WavesAndEigenvalues.Meshutils]","category":"page"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils","page":"Mesh","title":"WavesAndEigenvalues.Meshutils","text":"Module containing functionality to read and process tetrahedral meshes from gmsh.\n\n\n\n\n\n","category":"module"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.Mesh","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.Mesh","text":"Definition of the mesh type\n\nFields\n\nname::String: the name of the mesh.\npoints::Array: 3×N array containing the coordinates of the N points defining the mesh.\nlines::List: List of simplices defining the edges of the mesh\ntriangles::List: List of simplices defining the surface triangles of the mesh\ntetrahedra::List: List of simplices defining the tetrahedra of the mesh\ndomains::Dict: Dictionairy defining the domains of the mesh. See comments below.\nfile::String: path to the file containing the mesh.\ntri2tet::Array: Array of length length(tetrahedra) containing the indices of the connected tetrahedra.\ndos: special field meant to contain symmetry information of highly symmetric meshes.\n\nNotes\n\nThe meshes are supposed to be tetrahedral. All simplices (lines, triangles, and tetrahedra) are stored as lists of simplices. Simplices are lists of integers containing the indices of the points (i.e. the column number in the points array) forming the simplex. This means a line is a two-entry list, a triangle a three-entry list, and a tetrahedron a four-entry list. For convenience certain entities of the mesh can be further defined in the domains dictionary. Each key defines a domain and maps to another dictionary. This second-level dictionary contains at least two keys: \"dimension\" mapping to the dimension of the specified domain (1,2, or 3) and \"simplices\" containing a list of integers mapping into the respective simplex lists. More keys may be added to the dictionary to define additional and/or custom information on the domain. For instance the compute_volume! function adds an entry with the domain size.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.Mesh-Tuple{String}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.Mesh","text":"mesh=Mesh(file_name::String; scale=1)\n\nread a tetrahedral mesh from gmsh file into mesh. The optional scaling factor scale may be used to scale the units of the mesh.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.collect_lines!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.collect_lines!","text":"collect_lines!(mesh::Mesh)\n\nPopulate the list of lines in mesh.lines.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.compute_volume!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.compute_volume!","text":"compute_volume!(mesh::Mesh,dom::String)\n\nCompute the size of the domain dom and store it in the field \"size\" of the domain definition. The size will be a length, area, or volume depending on the dimension of the domain.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.extend_mesh-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.extend_mesh","text":"full_mesh=extend_mesh(mesh::Mesh, doms; sym_name=\"Symmetry\", blch_name=\"Bloch\", unit=false)\n\nCreate full mesh or unit cell from half cell represented in mesh.\n\nArguments\n\nmesh::Mesh: mesh representing the half cell. The mesh must span a sector of 2π/2N, where N is the (integer) degree of symmetry of the full mesh.\ndoms::List: list of 2-tuples containing the domain names and their copy_degree (see notes below).\nsym_name::String=\"Symmetry\": name of the domain of mesh that forms the symmetry plane of the half-mesh.\nblch_name::String=\"Bloch\": name of the domain of mesh that forms the remaining azimuthal plane of the half-mesh.\nunit::Bool=false: toggle whether extend the mesh to unit cell only.\n\nReturns\n\nfull_mesh::Mesh: representation of the full mesh.\n\nNotes\n\nThe routine copies only domains that are specified  in doms. These domains are extended according to the specified copy_degree. The following are available:\n\n:full: extent the domain and save it under the same name in full_mesh.\n:unit: extent the domain and save the individual unit cells labeled from 0 to N-1 in full_mesh.\n:half: extent the domain and save the individual unit cells as half cells labeled from 0 to N-1 in full_mesh where one half-cell  contains _img in its name.\n\nMultiple styles can be mixed in one domain specification. An example for doms would be     doms=[(\"Interior\", :full), (\"Outlet\", :unit), (\"Flame\", :half)]\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point","text":"tet_idx=find_tetrahedron_containing_point(mesh::Mesh,point)\n\nFind the tetrahedron containing the point point and return the index of the tetrahedron as tet_idx. If the point lies on the interface of two or more tetrahedra, the returned tet_idx will be the lowest index of these tetrahedra, i.e. the index depends on the ordering of the tetrahedra in the mesh.tetrahedra. If no tetrahedron in the mesh encloses the point tet_idx==0.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.generate_field","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.generate_field","text":"generate_field(mesh::Mesh,func,el_type=0)\n\nGenerate field from function funcfor mesh mesh. The element type is either el_type=0 for field values associated with the mesh tetrahedra or el_type=1 for field values associated with the mesh vertices. The function must accept three input arguments corresponding to the three space dimensions.\n\n\n\n\n\n","category":"function"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_normal_vectors","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_normal_vectors","text":"normal_vectors=get_normal_vectors(mesh::Mesh,output::Bool=true)\n\nCompute a 3×length(mesh.triangles) Array containing the outward pointing normal vectors of each of the surface triangles of the mesh mesh. The vectors are not normalised but their norm is twice the area of the corresponding triangle. The optional parameter output toggles whether a progressbar should be shown or not.\n\n\n\n\n\n","category":"function"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_surface_points","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_surface_points","text":"surface_points, tri_mask, tet_mask = get_surface_points(mesh::Mesh,output=true)\n\nGet a list surface_points of all point indices that are on the surface of the mesh mesh. The corresponding lists tri_mask andtet_maskcontain lists of indices of all triangles and tetrahedra that are connected to the surface point. The optional parameteroutput` toggles whether a progressbar should be shown or not.\n\n\n\n\n\n","category":"function"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!","text":"link_triangles_to_tetrahedra!(mesh::Mesh)\n\nFind the tetrahedra that are connected to the triangles in mesh.triangles and store this information in mesh.tri2tet.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.unify!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String,Vararg{Any,N} where N}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.unify!","text":"unify!(mesh::Mesh ,new_domain::String,domains...)\n\nCreate union of domains and name it new_domain. domains must share the same dimension and new_domain must be a new name otherwise errors will occur.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.vtk_write-Tuple{String,WavesAndEigenvalues.Meshutils.Mesh,Dict}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.vtk_write","text":"vtk_write(file_name, mesh, data)\n\nWrite vtk-file containing the datavalues data given on the usntructured grid mesh.\n\nArguments\n\nfile_name::String: name given to the written files. The name will be preceeded by a specifier. See Notes below.\nmesh::Mesh: mesh associated with the data.\ndata::Dict: Dictionairy containing the data.\n\nNotes\n\nThe routine automatically sorts the data according to its type and writes it in up to three diffrent files. Data that is constant on a tetrahedron goes into \"$(filename)_const.vtu\", data that is linearly interpolated on a tetrahedron goes into \"$(filename)_lin.vtu\", and data that is quadratically interpolated on a tetrahedron goes into \"$(filename)_quad.vtu\"\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.SymInfo","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.SymInfo","text":"Simple struct element to store additional information on symmetry for rotational symmetric meshes.\n\n#Fields\n\nDOS::Int64: degree of symmetry\nnaxis::Int64: number of grid points lying on the center axis\nnxbloch::Int64: number of grid points lying on the Bloch plane but not on the center axis\nnbody::Int64: number of interior points in half cell\nshiftbody::Int64: difference from body point to reflected body point\nnxsymmetry::Int64: number of grid points on symmetry plane (without center axis)\nnxsector::Int64: number of grid points belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)\nnaxis_ln::Int64: number of line segments lying on the center axis\nnxbloch_ln::Int64: number of line segments belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)\nnxsector_ln::Int64: number of line segments belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)\nnxsector_tri::Int64: number of surface triangles belonging to a unit cell (without Bloch and Bloch image plane)\nnxsector_tet::Int64: number of tetrahedra of a unit cell\nn: unit axis vector of the center axis\n`pnt: foot point of the center axis\nunit::Bool: true if mesh represents only a unit cell\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.compare-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.compare","text":"cmpr=compare(A,B)\n\nCompare two simplices following lexicographic rules. If B has lower rank, then A cmpr ==-1. If B has higher rank than A, cmpr==1. If A and B are identical, cmpr==0.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis","text":"R = create_rotation_matrix_around_axis(n,α)\n\nCompute the rotation matrix around the directional vector nrotating by an angle α (in rad).\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular","text":"foot = find_foot_of_perpendicular(pnt,pln)\n\nCompute the position of the foot of the perpendicular from the point pnt to the plane pln.\n\n#Notes Code adapted from https://www.geeksforgeeks.org/mirror-of-a-point-through-a-3-d-plane/\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes","text":"p,n = find_intersection_of_two_planes(pln1,pln2)\n\nFind a parametrization of the axis defined by the intersection of the planes pln1and pln2. The axis is parameterized by a point p and direction n.\n\n#Notes The algorithm follows John Krumm's solution for finding a common point on two intersecting planes as it is explained in https://math.stackexchange.com/questions/475953/how-to-calculate-the-intersection-of-two-planes To simplify the code, here the point p0 is the origin.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.find_smplx-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.find_smplx","text":"idx = find_smplx(list,smplx)\n\nFind index of simplex in ordered list of simplices. If the simplex is not contained in the list, the returned index is nothing\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_line_idx-NTuple{7,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_line_idx","text":"ln_idx = get_line_idx(ln,naxis_ln,nxsector_ln)\n\nGet index ln_idx of line ln  in a mesh that features naxis grid points and naxis_ln' lines on the center line,nxsectorgrid points andnxsector_ln' lines in a unit cell excluding the center axis.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_line_idx-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_line_idx","text":"ln_idx = get_line_idx(mesh::Mesh, ln)\n\nGet index ln_idx of line ln in mesh mesh.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_line_sector-Tuple{Any,Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_line_sector","text":"s = get_line_sector(ln)\n\nGet index s of sector containing line ln, in a mesh that features naxis grid points on the center line and nxsector grid points in a unit cell excluding the center axis..\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_line_sector-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_line_sector","text":"sidx = get_line_sector(mesh::Mesh, ln)\n\nGet sector idx sidxof line ln in mesh mesh.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_point_sector-Tuple{Any,Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_point_sector","text":"sector = get_point_sector(pnt_idx,naxis, nxsector)\n\nGet the sector containing point with index pnt_idx, in a mesh that features naxis grid points on the center line and nxsector grid points in a unit cell excluding the center axis.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_point_sector-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_point_sector","text":"sidx=get_point_sector(mesh::Mesh,pnt_idx)\n\nGet sector idx sidxof point with index pnt_idxin mesh mesh.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_reflected_index-NTuple{7,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_reflected_index","text":"ridx = get_reflected_index(idx,naxis,nxbloch,nbody,shiftbody,nxsymmetry)\n\nGet index ridx of a point in the first unit cell created from reflection of the point with index idx. The definig mesh feature naxis points on the center axis, nxbloch points on the bloch plane (excluding the center axis), nbody points in the interiror of the first half-cell, nxsymmetrypoints on the symmetry plane (excluding the center axis) nxsector points in a unit cell excluding the center axis. The difference of the indeces of a refernce body point and a reflected body point is shiftbody. The number of points per unit cell (excluding the center axis) is nxsector.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.get_rotated_index-NTuple{5,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.get_rotated_index","text":"ridx = get_rotated_index(idx,sector, naxis, nxsector, DOS)\n\nGet index ridx of point in sector sector created from rotation of the point with index idx. The definig mesh feature naxis points on the center axis, nxsector points in a unit cell excluding the center axis, and has a degree of symmetry DOS.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.insert_smplx!-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.insert_smplx!","text":"insert_smplx!(list,smplx)\n\nInsert simplex in ordered list of simplices.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.is_point_in_plane-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.is_point_in_plane","text":"check = is_point_in_plane(pnt, pln)\n\nCheck whether point \"pnt\" is in plane . Note that there is currently no handling of round off errors.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.make_normal_outwards!-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.make_normal_outwards!","text":"makenormaloutwards!(pln,testpoint)\n\nEnsure that the parameterization of the plane \"pln\" has a normal that is directed twoards testpoint. If necessary reparametrize pln.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.read_ansys-Tuple{Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.read_ansys","text":"read a mesh from ansys cfx file\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.read_msh2-Tuple{Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.read_msh2","text":"points, lines, triangles, tetrahedra, domains=read_msh2(file_name)\n\nRead gmsh's .msh-format version 2. This is an old format and wherever possible version 4 should be used.\n\nhttp://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.read_msh4-Tuple{Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.read_msh4","text":"points, lines, triangles, tetrahedra, domains=read_msh4(file_name)\n\nRead gmsh's .msh-format version 4.\n\nhttp://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.reflect_point_at_plane-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.reflect_point_at_plane","text":"p = reflect_point_at_plane(pnt,pln)\n\nReflect point pnt at plane pln and return as p.\n\n#Notes Code adapted from https://www.geeksforgeeks.org/mirror-of-a-point-through-a-3-d-plane/\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.sort_smplx-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.sort_smplx","text":"sort_smplx(list,smplx)\n\nHelper function for sorting simplices in lexicographic manner. Utilize divide an conquer strategy to find a simplex in ordered list of simpleces.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.three_points_to_plane-Tuple{Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.three_points_to_plane","text":"pln=three_points_to_plane(A)\n\nCompute equation for a plane from the three points defined in A. The plane is parameterized as a*x+b*y+c*z+d==0 with the coefficients returned as pln=[a,b,c,d].\n\n#Arguments\n\nA::3×3-Array : Array containing the three points defining the plane as columns.\n\n#Notes Code adapted from https://www.geeksforgeeks.org/program-to-find-equation-of-a-plane-passing-through-3-points/\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#NLEVP-1","page":"NLEVP","title":"NLEVP","text":"","category":"section"},{"location":"NLEVP.html#","page":"NLEVP","title":"NLEVP","text":"Modules = [WavesAndEigenvalues.NLEVP]","category":"page"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP","text":"Module containing routines to solve and perturb nonlinear eigenvalue problems.\n\n\n\n\n\n","category":"module"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.LinearOperatorFamily-Tuple{String}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.LinearOperatorFamily","text":"L=LinearOperatorFamily(fname::String)\n\nLoad and construct LinearOperatorFamily from file fname.\n\nSee also: save\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.beyn","text":"Ω, P = beyn(L::LinearOperatorFamily, Γ; <keyword arguments>)\n\nCompute all eigenvalues of L inside the contour Γ together with the associated eigenvectors. The contour is given as a list of complex numbers which are interpreted as polygon vertices in the complex plane.  The eigenvalues are stored in the list Ω and the eigenvectors are stored in the columns of P. The eigenvector P[:,i] corresponds to the eigenvalue Ω[i], i.e., they satisfy L(Ω[i])P[:,i]=0.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the non-linear eigenvalue problem\nΓ::Array: List of complex points defining the contour.\nl::Integer = 5: estimate of the number of eigenvalues inside of Γ.\nK::Integer = 1: Augmention dimension if Γ is assumed to contain more than size(L)[1] eigenvalues.\nN::Integer = 16: Number of evaluation points used to perform the Gauss-Legendre integration along each edge of Γ.\ntol::Float=0.0: Threshold value to discard spurious singular values. If set to 0 (the default) no singular values are discarded.\npos_test::bool=true: If set to true perform positions test on the computed eigenvalues, i.e., check whether the eigenvalues are enclosed by Γ and disregard all eigenvalues which fail the test.\noutput::bool=false: Show progressbar if true.\n\nReturns\n\nΩ::Array: List of computed eigenvalues\nP::Matrix: Matrix of eigenvectors.\n\nNotes\n\nThe original algorithm was first presented by Beyn in [1]. The implementation closely follows the pseudocode from Buschmann et al. in [2].\n\nReferences\n\n[1] W.-J. Beyn, An integral method for solving nonlinear eigenvalue problems, Linear Algebra and its Applications, 2012, 436(10), p.3839-3863, https://doi.org/10.1016/j.laa.2011.03.030\n\n[2] P.E. Buschmann, G.A. Mensah, J.P. Moeck, Solution of Thermoacoustic Eigenvalue Problems with a Non-Iterative Method, J. Eng. Gas Turbines Power, Mar 2020, 142(3): 031022 (11 pages) https://doi.org/10.1115/1.4045076\n\nSee also: householder\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.householder-Tuple{Any,Any}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.householder","text":"sol::Solution, n, flag = householder(L::LinearOperatorFamily, z; <keyword arguments>)\n\nUse a Householder method to iteratively find an eigenpar of L, starting the the iteration from z.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the nonlinear eigenvalue problem.\nz: Initial guess for the eigenvalue.\nmaxiter::Integer=10: Maximum number of iterations.\ntol=0: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is abs(z0-z1)<tol the iteration is aborted.\nrelax=1: relaxation parameter\nlam_tol=0.: tolerance for the auxiliary eigenvalue to test convergence\norder::Integer=1: Order of the Householder method, Maximum is 5\nn_eig_val::Integer=1: Number of Eigenvalues to be searched for in intermediate ARPACK calls.\nv0::Vector: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with ones.\noutput::Bool: Toggle printing online information.\n\nReturns\n\nsol::Solution\nn::Integer: Number of perforemed iterations\nflag::Integer: flag reporting the success of the method. Most important values are 1: method converged, 0: convergence might be slow, -1:maximum number of iteration has been reached. For other error codes see the source code.\n\nNotes\n\nHousholder methods are a generalization of Newton's method. If order=1 the Housholder method is identical to Newton's method. The solver then reduces to the \"generalized Rayleigh Quotient iteration\" presented in [1]. If no relaxation is used (relax == 1), the convergence rate is of order+1. With relaxation (relax != 1) the convergence rate is 1. Thus, with a higher order less iterations will be necessary. However, the computational time must not necessarily improve nor do the convergence properties. Anyway, if the method converges, the error in the eigenvalue is bounded above by tol. For more details on the solver, see the thesis [2].\n\nReferences\n\n[1] P. Lancaster, A Generalised Rayleigh Quotient Iteration for Lambda-Matrices,Arch. Rational Mech Anal., 1961, 8, p. 309-322, https://doi.org/10.1007/BF00277446\n\n[2] G.A. Mensah, Efficient Computation of Thermoacoustic Modes, Ph.D. Thesis, TU Berlin, 2019\n\nSee also: beyn,\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.perturb!","text":"perturb!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nFor large perturbation orders N the method might be slow.\n\nSee also: perturb_fast!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb_fast!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.perturb_fast!","text":"perturb_fast!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nThis method reads multi-indeces for the computation of the power series coefficients from disk. Make sure that JulHoltz is properly installed to use this fast method.\n\nSee also: perturb!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb_norm!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.perturb_norm!","text":"perturb_norm!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nThis method reads multi-indeces for the computation of the power series coefficients from disk. Make sure that JulHoltz is properly installed to use this fast method.\n\nSee also: perturb!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.save-Tuple{Any,WavesAndEigenvalues.NLEVP.LinearOperatorFamily}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.save","text":"save(fname::String,L::LinearOperatorFamily)\n\nSave L to file fname. The file is utf8 encoded and adheres to a Julia-enriched TOML standard.\n\nSee also: LinearOperatorFamily\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.polyval-Tuple{Any,Any}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.polyval","text":"`f=polyval(p,z)`\n\nEvaluate polynomial f(z)=∑_i p[i]z^1 at z, using Horner's scheme.\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.read_toml-Tuple{Any}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.read_toml","text":"This is a minimal TOML parser. See https://en.wikipedia.org/wiki/TOML\n\n\n\n\n\n","category":"method"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"EditURL = \"<unknown>/tutorial_01_rijke_tube.jl\"","category":"page"},{"location":"tutorial_01_rijke_tube.html#Tutorial-01-Rijke-Tube-1","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"##Introduction","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"A Rijke tube is the most simple thermo-acoustic configuration. It comprises a tube with an unsteady heat source somewhere inside the tube. This example will walk you through the basic steps of setting up a Rijke tube in a Helmholtz-solver stability analysis.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"###The Helmholtz equation The Helmholtz equation is the Fourier transform of the acoustic wave equation. Given that there is a heat source, it reads:","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"∇⋅(c² ∇ p̂) + ω² p̂ = -iω(γ-1)q̂","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Here c is speed-of-sound-field, p̂ the (complex) pressure fluctuation amplitude ω the (complex) frequency of the problem, i the imaginary unit, γ the ratio of specifc heats, and q̂ the amplitude of the heat release fluctuation.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"(Note that the Fourier transform here follows a ⋅' –> ⋅̂ exp(+iωt) convention.)","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Together with some boundary conditions the Helmholtz equation models thermo-acoustic resonance in a cavity. The minimum required inputs to specify a problem are","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"the shape of the domain\nthe speed-of-sound field\nthe boundary conditions","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"In case of an active flame (q̂!=0). We will also need","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"some additional gas porperties and\nand a flame response model linking the heat release fluctuations q̂ to the pressure fluctuations p̂","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Once you completed this tutorial you will know the basic steps of how to conduct a thermo-acoustic stability analysis","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"##Header","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"#First you will need to load the Helmholtz solver. The following line brings all","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"necessary tools into scope:","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"pwd()\nusing WavesAndEigenvalues.Helmholtz","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"##Mesh Now we can load the mesh file. It is the essential piece of information defining the domain shape . This tutorial's mesh has been specified in mm which is why we scale it by 0.001 to load the coordinates as m:","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"mesh=Mesh(\"Rijke_mm.msh\",scale=0.001)","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"You can have a look at some basic mesh data by printing it","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"print(mesh)","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"In an interactive session, is suffices to just type the mesh's variable name without the enclosing print command.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"This info tells us that the mesh features 1006 points as vertices 1562 (addressable) triangles on its surface and 3380tetrahedra forming the tube. Note, that there are currently no lines stored. This is because line information is only needed when using second-order finite elements. To save memory this information is only assembled and stored when explicitly requested. We will come back to this aspect in a later tutorial.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"You can also see that the mesh features several named domains such as \"Interior\",\"Flame\", \"Inlet\" and \"Outlet\". These domains are used to specify certain conditions for our model.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"A model descriptor is always given as a dictionairy featureing domain names as keys and tuples as values. The first tuple entry is a Julia symbol specifying the operator to be build on the associated domain, while the second entry is again a tuple holding information that is specific to the chosen operator.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"##Model set-up For instance, we certainly want to build the wave operator on the entire mesh. So first, we initialize an empty dictionairy","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"dscrp=Dict()","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"And then specify that the wave operator should be build everywhere. For the given mesh the domain-specifier to address the entire resononant cavity is \"Interior\" and in general the symbol to create the wave operator is :interior. It requires no options so the options tuple remains empty.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"dscrp[\"Interior\"]=(:interior, ())\n\n# src","category":"page"},{"location":"tutorial_01_rijke_tube.html#Boundary-Conditions-1","page":"Tutorial 01 Rijke Tube","title":"Boundary Conditions","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The tube should have a pressure node at its outlet, in order to model an open-end boundary condition. Boundary conditions are specified in terms of admittance values. A pressure note corresponds to an infinite admittance. To represent this on a computer we just give it a crazily high value like 1E15. We will also need to specify a variable name for our admmittance value. This will allow to quickly change the value after discretization of the model by addressing by this very name. This feature is one of the core concepts of the solver. As will be demonstrated later.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The complete description of our boundary condition reads","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"dscrp[\"Outlet\"]=(:admittance, (:Y,1E15))","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"You may wonder why we do not specify conditions for the other boundaries of the model. This is because the discretization is based on Bubnov-Galerkin finite elements. All unspecified, boundaries will therefore naturally be discretized as solid walls.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Flame-1","page":"Tutorial 01 Rijke Tube","title":"Flame","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The Rijke tube's main feauture is a domain of heat release. In the current mesh there is a designated domain \"Flame\" addressing a thin volume at the center of the tube. We can use this key to specify a flame with simple n-tau-dynamics. Therefore, we first need to define some basic gas properties.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"γ=1.4 #ratio of specific heats\nρ=1.225 #density at the reference location upstream to the flame in kg/m^3\nTu=300.0    #K unburnt gas temperature\nTb=1200.0    #K burnt gas temperature\nP0=101325.0 # ambient pressure in Pa\nA=pi*0.025^2 # cross sectional area of the tube\nQ02U0=P0*(Tb/Tu-1)*A*γ/(γ-1) #the ratio of mean heat release to mean velocity Q02U0","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"We will also need to provide the position where the reference velocity has been taken and the direction of that velocity","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"x_ref=[0.0; 0.0; -0.00101]\nn_ref=[0.0; 0.0; 1.00] #must be a unit vector\n#And of course, we need some values for n and tau\nn=0.0 #interaction index\nτ=0.001 #time delay","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"With these values the specification of the flame reads","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"dscrp[\"Flame\"]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ))","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Note that the order of the values in the options tuple is important. Also note that we assign the symbols :nand :τ for later analysis.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Speed-of-Sound-1","page":"Tutorial 01 Rijke Tube","title":"Speed of Sound","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The description of the Rijke tube model is nearly complete. We just need to specify the speed of sound field.  For this example, the field is fairly simple and can be specified analytically, using the generate_field function and a custom three-parameter function.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"R=287.05 # J/(kg*K) specific gas constant (air)\nfunction speedofsound(x,y,z)\n    if z<0.\n        return sqrt(γ*R*Tu)#m/s\n    else\n        return sqrt(γ*R*Tb)#m/s\n    end\nend\nc=generate_field(mesh,speedofsound)","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Note that in more elaborate models, you may read the field c from a file containing simulation or experimental data, rather than specifying it analytically.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Model-Discretization-1","page":"Tutorial 01 Rijke Tube","title":"Model Discretization","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Now we have all ingredients together and we can discretize the model.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"L=discretize(mesh,dscrp,c)","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The return value L here is a family of linear operators. You can display an algebraic representation of the family plus a list of associated parameters by just printing it","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"print(L)","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"(In an interactive session the enclosing print function is not necessary.)","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"You might notice that the list contains all parameters that have been specified during the model description (n,τ,Y). However, there are also two parameters that were added by default: ω and λ. ω is the complex frequency of the model and λ an auxiliary value that is important for the eigenfrequency computation. ##Solving the Model ###Global Solver We can solve the model for some eigenvalues using one of the eigenvalue solvers. The package provides you with two types of eigenvalue solvers. A global contour-integration-based solver. That finds you all eigenvalues inside of a specified contour Γ in the complex plane.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Γ=[150.0+5.0im, 150.0-5.0im, 1000.0-5.0im, 1000.0+5.0im].*2*pi #corner points for the contour (in this case a rectangle)\nΩ, P = beyn(L,Γ,l=10,N=64, output=true)","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The found eigenvalues are stored in the array Ω. The corresponding eigenvectors are the columns of P. The huge advantage of the global eigenvalue solver is that it finds you multiple eigenvalues. However, its accuracy may be low and sometimes it provides you with outright wrong solutions. However, for the current case the method works as we can varify that in our search window there are two eigenmodes oscilating at 272 and 695 Hz respectively:","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"for ω in Ω\n    println(\"Frequency: $(ω/2/pi)\")\nend","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"###Local Solver To get high accuracy eigenvalues , there is also local iterative eigenvalue solver. Based on an initial guess, it only finds you one eigenvalue at a time but with machine-precise accuracy.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"sol,nn,flag=householder(L,250*2*pi,output=true);\nnothing #hide","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The return values of this solver are a solution object sol, the number of iterations nn performed by the solver and and error flag flag providing information on the quality of the solution. If flag>0 the solution has converged. If flag<0something went wrong. And if flag==0... well, probably the solution is fine but you should check it.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"In the current case the flag is -1 indicating that the maximum number of iterations has been reached. This is because we havent specified a stopping criterion and the iteration just run for the maximum number of iterations. Nevertheless, the 272 Hz mode is correct. Indeed, as you can see from the printed output it already converged to machine-precision after 5 iterations.","category":"page"},{"location":"tutorial_01_rijke_tube.html#Changing-a-specified-parameter.-1","page":"Tutorial 01 Rijke Tube","title":"Changing a specified parameter.","text":"","category":"section"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"#Remember that we have specified the parameters `Y`,`n`, and `τ`?. We can change\n#these easily without rediscretizing our model. For instance currently `n==0.0`\n#so the solution is purely accoustic. The effect of the flame just enters the\n#problem via the speed of sound field (this is known as passive flame). By\n#setting the interaction index to `1.0` we activate the flame.\nL.params[:n]=1.0\n#Now we can just solve the model again to get the active solutions\nsol_actv,nn,flag=householder(L,250*2*pi,output=true);\n#The eigenfrequency is now complex:\nsol_actv.params[:ω]/2/pi\n#with a growth rate `-imag(sol_actv.params[:ω]/2/pi)≈  59.22`","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"Instead of recomputing the eigenvalue by one of the solvers. We can also approximate the eigenvalue as a function of one of the model parameters utilizing high-order perturbation theory. For instance this gives you the 30th order diagonal Padé estimate expanded from the passive solution.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"perturb_fast!(sol,L,:n,30) #compute the coefficients\nfreq(n)=sol(:n,n,15,15)/2/pi #create some function for convenience\nfreq(1) #evaluate the function at any value for `n` you are interested in.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The method is slow when only computing one eigenvalue. But its computational costs are allmost constant when computing multiple eigenvalues. Therefore, for larger parametric studies this is clearly the method of choice.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"##VTK Output for Paraview","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"To visualizte your solutions you can store them as \"*.vtu\" files to open them with paraview. Just, create a dictionairy, where your modes are stored as fields.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"data=Dict()\ndata[\"speed_of_sound\"]=c\ndata[\"abs\"]=abs.(sol_actv.v)/maximum(abs.(sol_actv.v)) #normalize so that max=1\ndata[\"phase\"]=angle.(sol_actv.v)\n\nvtk_write(\"tutorial_01\", mesh, data) # Write the solution to paraview","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"The vtk_write function automatically sorts your data by its interpolation scheme. Data that is constant on a tetrahedron will be written to a file \"_const.vtu\", data that is linearly interpolated on a tetrahedron will go to \"lin.vtu\", and data that is quadratically interpolated to \"*quad.vtu\". The current example uses constant speed of sound on a tetrahedron and linear finite elements for the discretization of p. Therefore, two files are generated, namely \"tutorial01const.vtu\" containing the speed-of-sound field and \"tutorial01lin.vtu\" containing the mode shape. Open them with paraview and have a look!.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"# src","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"##Summary","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"You learnt how to set-up a simple Rijke-tube study. This  already introduced all basic steps that are needed to work with the Helmholtz solver. However, their are a lot of details you can fine tune and even features that weren't mentioned in this tutorial. The next tutorials will introduce these aspects in more detail.","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"","category":"page"},{"location":"tutorial_01_rijke_tube.html#","page":"Tutorial 01 Rijke Tube","title":"Tutorial 01 Rijke Tube","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html#WavesAndEigenvalues.jl-1","page":"Home","title":"WavesAndEigenvalues.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Documentation for WavesAndEigenvalues.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A package for building Finite Element Models of wave-based problems and solving the associated eigenvalue problems.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"note: Note\nThis Package is under development, we will add more features soon!","category":"page"},{"location":"index.html#Package-Features-1","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Load mesh files in .msh format, with surface and volumes labeled (see e.g. gmsh).\nSpecify the equations to be solved on each surface and volumes.\nBuild a paramteric depedent FEM sparse_matrix.\nCalculate eigenvalues of nonlinear eigenvalue problems (NLEVP).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The Manual documents the package modules and functionalities.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Examples on usage in the form of Jupyter Notebooks will be made available soon.","category":"page"},{"location":"index.html#Documentation-Outline-1","page":"Home","title":"Documentation Outline","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n        \"Mesh.md\",\n        \"Helmholtz.md\",\n        \"NLEVP.md\",\n]\nDepth = 2","category":"page"},{"location":"index.html#Examples-1","page":"Home","title":"Examples","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages =[\n        \"load_mesh.md\",\n\t\"tutorial_01_rijke_tube.md\",\n]\nDepth = 1","category":"page"}]
}
