<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 09 Forcing · WavesAndEigenvalues.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavesAndEigenvalues.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="installation.html">Install</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="tutorial_00_NLEVP.html">Tutorial 00 Introduction to the NLEVP module</a></li><li><a class="tocitem" href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li><li><a class="tocitem" href="tutorial_02_global_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s Global Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_03_local_eigenvalue_solver.html">Tutorial 03  A Local Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_04_perturbation_theory.html">Tutorial 04 Perturbation Theory</a></li><li><a class="tocitem" href="tutorial_05_mesh_refinement.html">Tutorial 05 Mesh Refinement</a></li><li><a class="tocitem" href="tutorial_06_second_order_elements.html">Tutorial 06 Second Order Elements</a></li><li><a class="tocitem" href="tutorial_07_Bloch_periodicity.html">Tutorial 07 Bloch periodicity</a></li><li><a class="tocitem" href="tutorial_08_custom_FTF.html">Tutorial 08 Custom FTF</a></li><li class="is-active"><a class="tocitem" href="tutorial_09_forcing.html">Tutorial 09 Forcing</a><ul class="internal"><li><a class="tocitem" href="#Model-set-up."><span>Model set-up.</span></a></li><li><a class="tocitem" href="#Solving-the-problem"><span>Solving the problem</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="NLEVP.html">The NLEVP module</a></li><li><a class="tocitem" href="Meshutils.html">The Meshutils module</a></li><li><a class="tocitem" href="Helmholtz.html">The Helmholtz module</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="tutorial_09_forcing.html">Tutorial 09 Forcing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial_09_forcing.html">Tutorial 09 Forcing</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-09-Forcing"><a class="docs-heading-anchor" href="#Tutorial-09-Forcing">Tutorial 09 Forcing</a><a id="Tutorial-09-Forcing-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-09-Forcing" title="Permalink"></a></h1><p>The tutorial demonstrates how to incorporate source terms into your Helmholtz model. This allows for the computation of acoustic transfer functions and similar qunatities. Currently, only boundary sources are supported. This tutorial will use the outlet wall of the rijke tube mesh, as an acoustic source. Such a case would occur when simulating acoustic excitations from a loudspeaker membrane.</p><h2 id="Model-set-up."><a class="docs-heading-anchor" href="#Model-set-up.">Model set-up.</a><a id="Model-set-up.-1"></a><a class="docs-heading-anchor-permalink" href="#Model-set-up." title="Permalink"></a></h2><p>The model is the same Rijke tube configuration as in Tutorial 01.</p><p>The only difference is that we put a keyowrd <code>:speaker</code> together with some parameters in our model description. The parameters are the excitation strength and the speaker admittance.</p><p>In particular, the speaker forcing is derived from an impedance boundary condition p̂ - (cZ)/(iω) * ∇p̂⋅n=A where p̂ is the pressure fluctuation amplitude, c the local speed of sound, Z a normalized impedance, i the imaginary unit, ω an angular frequency, n the outward pointing unit normal, and A the excitation strength. This equation is equal to -iωY/c * p̂+∇p̂⋅n=-iωY/c*A, where the admittance is Y=1/Z. Note that for the special case of a a sound-soft impedance (Z=0 aka Y=∞) the excitation level A is identical to the pressure amplitude p̂ (p̂=A).</p><p>Ok let&#39;s see how it works. We start with the standard header known from tutorial 01.</p><pre><code class="language-julia">using WavesAndEigenvalues.Helmholtz
mesh=Mesh(&quot;Rijke_mm.msh&quot;,scale=0.001) #load mesh
dscrp=Dict() #initialize model descriptor
dscrp[&quot;Interior&quot;]=(:interior, ()) #define resonant cavity</code></pre><pre class="documenter-example-output">(:interior, ())</pre><p>Now comes the magic line that specifies the excitation level and speaker impedance:</p><pre><code class="language-julia">dscrp[&quot;Outlet&quot;]=(:speaker, (:A,1,:Y,1E15)); #specify outlet BC</code></pre><p>The rest is the usual set-up...</p><pre><code class="language-julia">γ=1.4; #ratio of specific heats
ρ=1.225; #density at the reference location upstream to the flame in kg/m^3
Tu=300.0;    #K unburnt gas temperature
Tb=1200.0;    #K burnt gas temperature
P0=101325.0; # ambient pressure in Pa
A=pi*0.025^2; # cross sectional area of the tube
Q02U0=P0*(Tb/Tu-1)*A*γ/(γ-1); #the ratio of mean heat release to mean velocity Q02U0
x_ref=[0.0; 0.0; -0.00101]; #reference point
n_ref=[0.0; 0.0; 1.00]; #directional unit vector of reference velocity
n=0.01; #interaction index
τ=0.001; #time delay
dscrp[&quot;Flame&quot;]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ)); #flame dynamics
R=287.05; # J/(kg*K) specific gas constant (air)
speedofsound(x,y,z) = z&lt;0. ? sqrt(γ*R*Tu) : sqrt(γ*R*Tb);
c=generate_field(mesh,speedofsound);</code></pre><p>Note that when calling <code>discretize</code> the <code>source</code> keyword is set to <code>true</code> and a second term <code>rhs</code> is returned. This is the discretization of the right hand side.</p><pre><code class="language-julia">L,rhs=discretize(mesh,dscrp,c,source=true,order=:quad);</code></pre><p>Like <code>L</code>, <code>rhs</code> is a linear operator family but note that it is a family of vectors not matrices. You can reset parameters  after the descretization. For instance the excitation strength <code>:A</code>:</p><pre><code class="language-julia">rhs.params[:A]=1;</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>You may also redefine the membrane impedance <code>:Y</code>, but note that you then also need to redefine it in <code>L</code> to get consistent results. There is currently no safety mechanism checking this for you!</p></div></div><h2 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h2><p>As the problem is linear solving it is an easy matter. We just use the backslash operator. For instance, finding the solution for an excitation frequency of 150 Hz reads:</p><pre><code class="language-julia">ω=150*2*pi;
sol=L(ω)\Array(rhs(ω));</code></pre><p>Note that the rhs is sparse, therefore, conversion to an Array is necessary as the backslash operator does not support sparse rhs. Anyways, we have a solution! We may right it to paraview, using the usual functions:</p><pre><code class="language-julia">data=Dict();
data[&quot;150Hz abs&quot;]=abs.(sol);
data[&quot;150Hz phase&quot;]=angle.(sol);
vtk_write(&quot;forcing&quot;, mesh, data);</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>You can also discretize a source vector and use it to model forced problems. Just use the <code>:speaker</code> option in the model description and set <code>soure=true</code> in the call to discretize.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial_08_custom_FTF.html">« Tutorial 08 Custom FTF</a><a class="docs-footer-nextpage" href="NLEVP.html">The NLEVP module »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 8 June 2021 16:00">Tuesday 8 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
