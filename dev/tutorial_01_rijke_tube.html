<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 01 Rijke Tube · WavesAndEigenvalues</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavesAndEigenvalues</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Documentation</span><ul><li><a class="tocitem" href="Mesh.html">Mesh</a></li><li><a class="tocitem" href="Helmholtz.html">Helmholtz</a></li><li><a class="tocitem" href="NLEVP.html">NLEVP</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="load_mesh.html">How to load a mesh?</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-01-Rijke-Tube-1"><a class="docs-heading-anchor" href="#Tutorial-01-Rijke-Tube-1">Tutorial 01 Rijke Tube</a><a class="docs-heading-anchor-permalink" href="#Tutorial-01-Rijke-Tube-1" title="Permalink"></a></h1><p>##Introduction</p><p>A Rijke tube is the most simple thermo-acoustic configuration. It comprises a tube with an unsteady heat source somewhere inside the tube. This example will walk you through the basic steps of setting up a Rijke tube in a Helmholtz-solver stability analysis.</p><p>###The Helmholtz equation The Helmholtz equation is the Fourier transform of the acoustic wave equation. Given that there is a heat source, it reads:</p><p>∇⋅(c² ∇ p̂) + ω² p̂ = -iω(γ-1)q̂</p><p>Here c is speed-of-sound-field, p̂ the (complex) pressure fluctuation amplitude ω the (complex) frequency of the problem, i the imaginary unit, γ the ratio of specifc heats, and q̂ the amplitude of the heat release fluctuation.</p><p>(Note that the Fourier transform here follows a ⋅&#39; –&gt; ⋅̂ exp(+iωt) convention.)</p><p>Together with some boundary conditions the Helmholtz equation models thermo-acoustic resonance in a cavity. The minimum required inputs to specify a problem are</p><ol><li>the shape of the domain</li><li>the speed-of-sound field</li><li>the boundary conditions</li></ol><p>In case of an active flame (q̂!=0). We will also need</p><ol><li>some additional gas porperties and</li><li>and a flame response model linking the heat release fluctuations q̂ to the pressure fluctuations p̂</li></ol><p>Once you completed this tutorial you will know the basic steps of how to conduct a thermo-acoustic stability analysis</p><p>##Header</p><pre><code class="language-julia">#First you will need to load the Helmholtz solver. The following line brings all</code></pre><p>necessary tools into scope:</p><pre><code class="language-julia">using WavesAndEigenvalues.Helmholtz</code></pre><p>##Mesh Now we can load the mesh file. It is the essential piece of information defining the domain shape . This tutorial&#39;s mesh has been specified in mm which is why we scale it by <code>0.001</code> to load the coordinates as m:</p><pre><code class="language-">mesh=Mesh(&quot;Rijke_mm.msh&quot;,scale=0.001)</code></pre><p>You can have a look at some basic mesh data by printing it</p><pre><code class="language-">print(mesh)</code></pre><p>In an interactive session, is suffices to just type the mesh&#39;s variable name without the enclosing <code>print</code> command.</p><p>This info tells us that the mesh features <code>1006</code> points as vertices <code>1562</code> (addressable) triangles on its surface and <code>3380</code>tetrahedra forming the tube. Note, that there are currently no lines stored. This is because line information is only needed when using second-order finite elements. To save memory this information is only assembled and stored when explicitly requested. We will come back to this aspect in a later tutorial.</p><p>You can also see that the mesh features several named domains such as <code>&quot;Interior&quot;</code>,<code>&quot;Flame&quot;</code>, <code>&quot;Inlet&quot;</code> and <code>&quot;Outlet&quot;</code>. These domains are used to specify certain conditions for our model.</p><p>A model descriptor is always given as a dictionairy featureing domain names as keys and tuples as values. The first tuple entry is a Julia symbol specifying the operator to be build on the associated domain, while the second entry is again a tuple holding information that is specific to the chosen operator.</p><p>##Model set-up For instance, we certainly want to build the wave operator on the entire mesh. So first, we initialize an empty dictionairy</p><pre><code class="language-julia">dscrp=Dict()</code></pre><pre><code class="language-none">Dict{Any,Any} with 0 entries</code></pre><p>And then specify that the wave operator should be build everywhere. For the given mesh the domain-specifier to address the entire resononant cavity is <code>&quot;Interior&quot;</code> and in general the symbol to create the wave operator is <code>:interior</code>. It requires no options so the options tuple remains empty.</p><pre><code class="language-julia">dscrp[&quot;Interior&quot;]=(:interior, ())

# src</code></pre><h2 id="Boundary-Conditions-1"><a class="docs-heading-anchor" href="#Boundary-Conditions-1">Boundary Conditions</a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-1" title="Permalink"></a></h2><p>The tube should have a pressure node at its outlet, in order to model an open-end boundary condition. Boundary conditions are specified in terms of admittance values. A pressure note corresponds to an infinite admittance. To represent this on a computer we just give it a crazily high value like <code>1E15</code>. We will also need to specify a variable name for our admmittance value. This will allow to quickly change the value after discretization of the model by addressing by this very name. This feature is one of the core concepts of the solver. As will be demonstrated later.</p><p>The complete description of our boundary condition reads</p><pre><code class="language-julia">dscrp[&quot;Outlet&quot;]=(:admittance, (:Y,1E15))</code></pre><pre><code class="language-none">(:admittance, (:Y, 1.0e15))</code></pre><p>You may wonder why we do not specify conditions for the other boundaries of the model. This is because the discretization is based on Bubnov-Galerkin finite elements. All unspecified, boundaries will therefore <em>naturally</em> be discretized as solid walls.</p><h2 id="Flame-1"><a class="docs-heading-anchor" href="#Flame-1">Flame</a><a class="docs-heading-anchor-permalink" href="#Flame-1" title="Permalink"></a></h2><p>The Rijke tube&#39;s main feauture is a domain of heat release. In the current mesh there is a designated domain <code>&quot;Flame&quot;</code> addressing a thin volume at the center of the tube. We can use this key to specify a flame with simple n-tau-dynamics. Therefore, we first need to define some basic gas properties.</p><pre><code class="language-julia">γ=1.4 #ratio of specific heats
ρ=1.225 #density at the reference location upstream to the flame in kg/m^3
Tu=300.0    #K unburnt gas temperature
Tb=1200.0    #K burnt gas temperature
P0=101325.0 # ambient pressure in Pa
A=pi*0.025^2 # cross sectional area of the tube
Q02U0=P0*(Tb/Tu-1)*A*γ/(γ-1) #the ratio of mean heat release to mean velocity Q02U0</code></pre><pre><code class="language-none">2088.98730878897</code></pre><p>We will also need to provide the position where the reference velocity has been taken and the direction of that velocity</p><pre><code class="language-julia">x_ref=[0.0; 0.0; -0.00101]
n_ref=[0.0; 0.0; 1.00] #must be a unit vector
#And of course, we need some values for n and tau
n=0.0 #interaction index
τ=0.001 #time delay</code></pre><pre><code class="language-none">0.001</code></pre><p>With these values the specification of the flame reads</p><pre><code class="language-julia">dscrp[&quot;Flame&quot;]=(:flame,(γ,ρ,Q02U0,x_ref,n_ref,:n,:τ,n,τ))</code></pre><pre><code class="language-none">(:flame, (1.4, 1.225, 2088.98730878897, [0.0, 0.0, -0.00101], [0.0, 0.0, 1.0], :n, :τ, 0.0, 0.001))</code></pre><p>Note that the order of the values in the options tuple is important. Also note that we assign the symbols <code>:n</code>and <code>:τ</code> for later analysis.</p><h2 id="Speed-of-Sound-1"><a class="docs-heading-anchor" href="#Speed-of-Sound-1">Speed of Sound</a><a class="docs-heading-anchor-permalink" href="#Speed-of-Sound-1" title="Permalink"></a></h2><p>The description of the Rijke tube model is nearly complete. We just need to specify the speed of sound field.  For this example, the field is fairly simple and can be specified analytically, using the <code>generate_field</code> function and a custom three-parameter function.</p><pre><code class="language-">R=287.05 # J/(kg*K) specific gas constant (air)
function speedofsound(x,y,z)
    if z&lt;0.
        return sqrt(γ*R*Tu)#m/s
    else
        return sqrt(γ*R*Tb)#m/s
    end
end
c=generate_field(mesh,speedofsound)</code></pre><p>Note that in more elaborate models, you may read the field <code>c</code> from a file containing simulation or experimental data, rather than specifying it analytically.</p><h2 id="Model-Discretization-1"><a class="docs-heading-anchor" href="#Model-Discretization-1">Model Discretization</a><a class="docs-heading-anchor-permalink" href="#Model-Discretization-1" title="Permalink"></a></h2><p>Now we have all ingredients together and we can discretize the model.</p><pre><code class="language-">L=discretize(mesh,dscrp,c)</code></pre><p>The return value <code>L</code> here is a family of linear operators. You can display an algebraic representation of the family plus a list of associated parameters by just printing it</p><pre><code class="language-">print(L)</code></pre><p>(In an interactive session the enclosing print function is not necessary.)</p><p>You might notice that the list contains all parameters that have been specified during the model description (<code>n</code>,<code>τ</code>,<code>Y</code>). However, there are also two parameters that were added by default: <code>ω</code> and <code>λ</code>. <code>ω</code> is the complex frequency of the model and <code>λ</code> an auxiliary value that is important for the eigenfrequency computation. ##Solving the Model ###Global Solver We can solve the model for some eigenvalues using one of the eigenvalue solvers. The package provides you with two types of eigenvalue solvers. A global contour-integration-based solver. That finds you all eigenvalues inside of a specified contour Γ in the complex plane.</p><pre><code class="language-">Γ=[150.0+5.0im, 150.0-5.0im, 1000.0-5.0im, 1000.0+5.0im].*2*pi #corner points for the contour (in this case a rectangle)
Ω, P = beyn(L,Γ,l=10,N=64, output=true)</code></pre><p>The found eigenvalues are stored in the array <code>Ω</code>. The corresponding eigenvectors are the columns of <code>P</code>. The huge advantage of the global eigenvalue solver is that it finds you multiple eigenvalues. However, its accuracy may be low and sometimes it provides you with outright wrong solutions. However, for the current case the method works as we can varify that in our search window there are two eigenmodes oscilating at 272 and 695 Hz respectively:</p><pre><code class="language-">for ω in Ω
    println(&quot;Frequency: $(ω/2/pi)&quot;)
end</code></pre><p>###Local Solver To get high accuracy eigenvalues , there is also local iterative eigenvalue solver. Based on an initial guess, it only finds you one eigenvalue at a time but with machine-precise accuracy.</p><pre><code class="language-">sol,nn,flag=householder(L,250*2*pi,output=true);
nothing #hide</code></pre><p>The return values of this solver are a solution object <code>sol</code>, the number of iterations <code>nn</code> performed by the solver and and error flag <code>flag</code> providing information on the quality of the solution. If <code>flag&gt;0</code> the solution has converged. If <code>flag&lt;0</code>something went wrong. And if <code>flag==0</code>... well, probably the solution is fine but you should check it.</p><p>In the current case the flag is -1 indicating that the maximum number of iterations has been reached. This is because we havent specified a stopping criterion and the iteration just run for the maximum number of iterations. Nevertheless, the 272 Hz mode is correct. Indeed, as you can see from the printed output it already converged to machine-precision after 5 iterations.</p><h2 id="Changing-a-specified-parameter.-1"><a class="docs-heading-anchor" href="#Changing-a-specified-parameter.-1">Changing a specified parameter.</a><a class="docs-heading-anchor-permalink" href="#Changing-a-specified-parameter.-1" title="Permalink"></a></h2><pre><code class="language-">#Remember that we have specified the parameters `Y`,`n`, and `τ`?. We can change
#these easily without rediscretizing our model. For instance currently `n==0.0`
#so the solution is purely accoustic. The effect of the flame just enters the
#problem via the speed of sound field (this is known as passive flame). By
#setting the interaction index to `1.0` we activate the flame.
L.params[:n]=1.0
#Now we can just solve the model again to get the active solutions
sol_actv,nn,flag=householder(L,250*2*pi,output=true);
#The eigenfrequency is now complex:
sol_actv.params[:ω]/2/pi
#with a growth rate `-imag(sol_actv.params[:ω]/2/pi)≈  59.22`</code></pre><p>Instead of recomputing the eigenvalue by one of the solvers. We can also approximate the eigenvalue as a function of one of the model parameters utilizing high-order perturbation theory. For instance this gives you the 30th order diagonal Padé estimate expanded from the passive solution.</p><pre><code class="language-">perturb_fast!(sol,L,:n,30) #compute the coefficients
freq(n)=sol(:n,n,15,15)/2/pi #create some function for convenience
freq(1) #evaluate the function at any value for `n` you are interested in.</code></pre><p>The method is slow when only computing one eigenvalue. But its computational costs are allmost constant when computing multiple eigenvalues. Therefore, for larger parametric studies this is clearly the method of choice.</p><p>##VTK Output for Paraview</p><p>To visualizte your solutions you can store them as <code>&quot;*.vtu&quot;</code> files to open them with paraview. Just, create a dictionairy, where your modes are stored as fields.</p><pre><code class="language-">data=Dict()
data[&quot;speed_of_sound&quot;]=c
data[&quot;abs&quot;]=abs.(sol_actv.v)/maximum(abs.(sol_actv.v)) #normalize so that max=1
data[&quot;phase&quot;]=angle.(sol_actv.v)

vtk_write(&quot;tutorial_01&quot;, mesh, data) # Write the solution to paraview</code></pre><p>The <code>vtk_write</code> function automatically sorts your data by its interpolation scheme. Data that is constant on a tetrahedron will be written to a file &quot;<em>_const.vtu&quot;, data that is linearly interpolated on a tetrahedron will go to &quot;</em><em>lin.vtu&quot;, and data that is quadratically interpolated to &quot;*</em>quad.vtu&quot;. The current example uses constant speed of sound on a tetrahedron and linear finite elements for the discretization of p. Therefore, two files are generated, namely &quot;tutorial<em>01</em>const.vtu&quot; containing the speed-of-sound field and &quot;tutorial<em>01</em>lin.vtu&quot; containing the mode shape. Open them with paraview and have a look!.</p><pre><code class="language-julia"># src</code></pre><p>##Summary</p><p>You learnt how to set-up a simple Rijke-tube study. This  already introduced all basic steps that are needed to work with the Helmholtz solver. However, their are a lot of details you can fine tune and even features that weren&#39;t mentioned in this tutorial. The next tutorials will introduce these aspects in more detail.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 June 2020 10:02">Friday 5 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
