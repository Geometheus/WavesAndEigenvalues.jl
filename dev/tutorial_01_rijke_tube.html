<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 01 Rijke Tube Â· WavesAndEigenvalues.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavesAndEigenvalues.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="installation.html">Install</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="tutorial_00_NLEVP.html">Tutorial 00 Introduction to the NLEVP module</a></li><li class="is-active"><a class="tocitem" href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a><ul class="internal"><li><a class="tocitem" href="#The-Helmholtz-equation"><span>The Helmholtz equation</span></a></li><li><a class="tocitem" href="#Header"><span>Header</span></a></li><li><a class="tocitem" href="#Mesh"><span>Mesh</span></a></li><li><a class="tocitem" href="#Model-set-up"><span>Model set-up</span></a></li><li><a class="tocitem" href="#Boundary-Conditions"><span>Boundary Conditions</span></a></li><li><a class="tocitem" href="#Flame"><span>Flame</span></a></li><li><a class="tocitem" href="#Speed-of-Sound"><span>Speed of Sound</span></a></li><li><a class="tocitem" href="#Model-Discretization"><span>Model Discretization</span></a></li><li><a class="tocitem" href="#Solving-the-Model"><span>Solving the Model</span></a></li><li><a class="tocitem" href="#Changing-a-specified-parameter."><span>Changing a specified parameter.</span></a></li><li><a class="tocitem" href="#VTK-Output-for-Paraview"><span>VTK Output for Paraview</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="tutorial_02_global_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s Global Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_03_local_eigenvalue_solver.html">Tutorial 03  A Local Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_04_perturbation_theory.html">Tutorial 04 Perturbation Theory</a></li><li><a class="tocitem" href="tutorial_05_mesh_refinement.html">Tutorial 05 Mesh Refinement</a></li><li><a class="tocitem" href="tutorial_06_second_order_elements.html">Tutorial 06 Second Order Elements</a></li><li><a class="tocitem" href="tutorial_07_Bloch_periodicity.html">Tutorial 07 Bloch periodicity</a></li><li><a class="tocitem" href="tutorial_08_custom_FTF.html">Tutorial 08 Custom FTF</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="NLEVP.html">The NLEVP module</a></li><li><a class="tocitem" href="Meshutils.html">The Meshutils module</a></li><li><a class="tocitem" href="Helmholtz.html">The Helmholtz module</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-01-Rijke-Tube"><a class="docs-heading-anchor" href="#Tutorial-01-Rijke-Tube">Tutorial 01 Rijke Tube</a><a id="Tutorial-01-Rijke-Tube-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-01-Rijke-Tube" title="Permalink"></a></h1><p>A Rijke tube is the most simple thermo-acoustic configuration. It comprises a tube with an unsteady heat source somewhere inside the tube. This example will walk you through the basic steps of setting up a Rijke tube in a Helmholtz-solver stability analysis.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To do this tutorial yourself you will need the <code>&quot;Rijke_mm.msh</code>&quot; file. Download it <a href="Rijke_mm.msh">here</a>.</p></div></div><h2 id="The-Helmholtz-equation"><a class="docs-heading-anchor" href="#The-Helmholtz-equation">The Helmholtz equation</a><a id="The-Helmholtz-equation-1"></a><a class="docs-heading-anchor-permalink" href="#The-Helmholtz-equation" title="Permalink"></a></h2><p>The Helmholtz equation is the Fourier transform of the acoustic wave equation. Given that there is a heat source, it reads:</p><p class="math-container">\[\nabla\cdot(c^2\nabla \hat p) + \omega^2\hat p = - i \omega (\gamma -1)\hat q\]</p><p>Here <span>$c$</span> is speed-of-sound-field, <span>$\hat p$</span> the (complex) pressure fluctuation amplitude <span>$\omega$</span> the (complex) frequency of the problem, <span>$i$</span> the imaginary unit, <span>$\gamma$</span> the ratio of specific heats, and <span>$\hat q$</span> the amplitude of the heat release fluctuation.</p><p>(Note that the Fourier transform here follows a <span>$f&#39;(t) \rightarrow \hat f(\omega)\exp(+i\omega t)$</span> convention.)</p><p>Together with some boundary conditions the Helmholtz equation models thermo-acoustic resonance in a cavity. The minimum required inputs to specify a problem are</p><ol><li>the shape of the domain</li><li>the speed-of-sound field</li><li>the boundary conditions</li></ol><p>In case of an active flame (<span>$\hat q \neq 0$</span>). We will also need</p><ol><li>some additional gas properties and</li><li>a flame response model linking the heat release fluctuations <span>$\hat q$</span> to the pressure fluctuations <span>$\hat p$</span></li></ol><p>Once you completed this tutorial you will know the basic steps of how to conduct a thermo-acoustic stability analysis</p><h2 id="Header"><a class="docs-heading-anchor" href="#Header">Header</a><a id="Header-1"></a><a class="docs-heading-anchor-permalink" href="#Header" title="Permalink"></a></h2><p>First you will need to load the Helmholtz solver. The following line brings all necessary tools into scope:</p><pre><code class="language-julia">using WavesAndEigenvalues.Helmholtz</code></pre><h2 id="Mesh"><a class="docs-heading-anchor" href="#Mesh">Mesh</a><a id="Mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh" title="Permalink"></a></h2><p>Now we can load the mesh file. It is the essential piece of information defining the domain shape . This tutorial&#39;s mesh has been specified in mm which is why we scale it by <code>0.001</code> to load the coordinates as m:</p><pre><code class="language-julia">mesh=Mesh(&quot;Rijke_mm.msh&quot;,scale=0.001)</code></pre><pre class="documenter-example-output">mesh: Rijke_mm.msh
#################
points:     1006
lines:      0
triangles:  1562
tetrahedra: 3380
#################
domains: Cold, Flame, Flame_in, Flame_out, Hot, Inlet, Interior, Outlet, Walls</pre><p>The displayed info tells us that the mesh features <code>1006</code> points as vertices <code>1562</code> (addressable) triangles on its surface and <code>3380</code> tetrahedra forming the tube. Note, that there are currently no lines stored. This is because line information is only needed when using second-order finite elements. To save memory this information is only assembled and stored when explicitly requested. We will come back to this aspect in a later tutorial.</p><p>You can also see that the mesh features several named domains such as <code>&quot;Interior&quot;</code>,<code>&quot;Flame&quot;</code>, <code>&quot;Inlet&quot;</code> and <code>&quot;Outlet&quot;</code>. These domains are used to specify certain conditions for our model.</p><p>A model descriptor is always given as a dictionary featureng domain names as keys and tuples as values. The first tuple entry is a Julia symbol specifying the operator to be build on the associated domain, while the second entry is again a tuple holding information that is specific to the chosen operator.</p><h2 id="Model-set-up"><a class="docs-heading-anchor" href="#Model-set-up">Model set-up</a><a id="Model-set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Model-set-up" title="Permalink"></a></h2><p>For instance, we certainly want to build the wave operator on the entire mesh. So first, we initialize an empty dictionary</p><pre><code class="language-julia">dscrp=Dict()</code></pre><pre class="documenter-example-output">Dict{Any,Any}()</pre><p>And then specify that the wave operator should be build everywhere. For the given mesh the domain-specifier to address the entire resonant cavity is <code>&quot;Interior&quot;</code> and in general the symbol to create the wave operator is <code>:interior</code>. It requires no options so the options tuple remains empty.</p><pre><code class="language-julia">dscrp[&quot;Interior&quot;]=(:interior, ())</code></pre><pre class="documenter-example-output">(:interior, ())</pre><h2 id="Boundary-Conditions"><a class="docs-heading-anchor" href="#Boundary-Conditions">Boundary Conditions</a><a id="Boundary-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions" title="Permalink"></a></h2><p>The tube should have a pressure node at its outlet, in order to model an open-end boundary condition. Boundary conditions are specified in terms of admittance values. A pressure note corresponds to an infinite admittance. To represent this on a computer we just give it a crazily high value like <code>1E15</code>. We will also need to specify a variable name for our admittance value. This will allow to quickly change the value after discretization of the model by addressing it by this very name. This feature is one of the core concepts of the solver. As will be demonstrated later.</p><p>The complete description of our boundary condition reads</p><pre><code class="language-julia">dscrp[&quot;Outlet&quot;]=(:admittance, (:Y,1E15))</code></pre><pre class="documenter-example-output">(:admittance, (:Y, 1.0e15))</pre><p>You may wonder why we do not specify conditions for the other boundaries of the model. This is because the discretization is based on Bubnov-Galerkin finite elements. All unspecified, boundaries will therefore <em>naturally</em> be discretized as solid walls.</p><h2 id="Flame"><a class="docs-heading-anchor" href="#Flame">Flame</a><a id="Flame-1"></a><a class="docs-heading-anchor-permalink" href="#Flame" title="Permalink"></a></h2><p>The Rijke tube&#39;s main feature is a domain of heat release. In the current mesh there is a designated domain <code>&quot;Flame&quot;</code> addressing a thin volume at the center of the tube. We can use this key to specify a flame with simple n-tau-dynamics. Therefore, we first need to define some basic gas properties.</p><pre><code class="language-julia">Î³=1.4 #ratio of specific heats
Ï=1.225 #density at the reference location upstream to the flame in kg/m^3
Tu=300.0    #K unburnt gas temperature
Tb=1200.0    #K burnt gas temperature
P0=101325.0 # ambient pressure in Pa
A=pi*0.025^2 # cross sectional area of the tube
Q02U0=P0*(Tb/Tu-1)*A*Î³/(Î³-1) #the ratio of mean heat release to mean velocity Q02U0</code></pre><pre class="documenter-example-output">2088.98730878897</pre><p>We will also need to provide the position where the reference velocity has been taken and the direction of that velocity</p><pre><code class="language-julia">x_ref=[0.0; 0.0; -0.00101]
n_ref=[0.0; 0.0; 1.00] #must be a unit vector</code></pre><pre class="documenter-example-output">3-element Array{Float64,1}:
 0.0
 0.0
 1.0</pre><p>And of course, we need some values for n and tau</p><pre><code class="language-julia">n=0.0 #interaction index
Ï=0.001 #time delay</code></pre><pre class="documenter-example-output">0.001</pre><p>With these values the specification of the flame reads</p><pre><code class="language-julia">dscrp[&quot;Flame&quot;]=(:flame,(Î³,Ï,Q02U0,x_ref,n_ref,:n,:Ï,n,Ï))</code></pre><pre class="documenter-example-output">(:flame, (1.4, 1.225, 2088.98730878897, [0.0, 0.0, -0.00101], [0.0, 0.0, 1.0], :n, :Ï, 0.0, 0.001))</pre><p>Note that the order of the values in the options tuple is important. Also note that we assign the symbols <code>:n</code>and <code>:Ï</code> for later analysis.</p><h2 id="Speed-of-Sound"><a class="docs-heading-anchor" href="#Speed-of-Sound">Speed of Sound</a><a id="Speed-of-Sound-1"></a><a class="docs-heading-anchor-permalink" href="#Speed-of-Sound" title="Permalink"></a></h2><p>The description of the Rijke tube model is nearly complete. We just need to specify the speed of sound field.  For this example, the field is fairly simple and can be specified analytically, using the <code>generate_field</code> function and a custom three-parameter function.</p><pre><code class="language-julia">R=287.05 # J/(kg*K) specific gas constant (air)
function speedofsound(x,y,z)
    if z&lt;0.
        return sqrt(Î³*R*Tu)#m/s
    else
        return sqrt(Î³*R*Tb)#m/s
    end
end
c=generate_field(mesh,speedofsound)</code></pre><pre class="documenter-example-output">3380-element Array{Float64,1}:
 694.4379021914054
 694.4379021914054
 694.4379021914054
 694.4379021914054
 694.4379021914054
 694.4379021914054
 694.4379021914054
 694.4379021914054
 694.4379021914054
 694.4379021914054
   â®
 347.2189510957027
 347.2189510957027
 347.2189510957027
 347.2189510957027
 347.2189510957027
 347.2189510957027
 347.2189510957027
 347.2189510957027
 347.2189510957027</pre><p>Note that in more elaborate models, you may read the field <code>c</code> from a file containing simulation or experimental data, rather than specifying it analytically.</p><h2 id="Model-Discretization"><a class="docs-heading-anchor" href="#Model-Discretization">Model Discretization</a><a id="Model-Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Discretization" title="Permalink"></a></h2><p>Now we have all ingredients together and we can discretize the model.</p><pre><code class="language-julia">L=discretize(mesh,dscrp,c)</code></pre><pre class="documenter-example-output">1006Ã1006-dimensional operator family: 

Ï^2*M+K+n*exp(-iÏÏ)*Q+Ï*Y*C

Parameters
----------
n	0.0 + 0.0im
Î»	Inf + 0.0im
Ï	0.0 + 0.0im
Ï	0.001 + 0.0im
Y	1.0e15 + 0.0im
</pre><p>The return value <code>L</code> here is a family of linear operators. The shown info is an algebraic representation of the family plus a list of associated parameters. You might have noticed that the list contains all parameters that have been specified during the model description (<code>n</code>,<code>Ï</code>,<code>Y</code>). However, there are also two parameters that were added by default: <code>Ï</code> and <code>Î»</code>. <code>Ï</code> is the complex frequency of the model and <code>Î»</code> an auxiliary value that is important for the eigenfrequency computation.</p><h2 id="Solving-the-Model"><a class="docs-heading-anchor" href="#Solving-the-Model">Solving the Model</a><a id="Solving-the-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-Model" title="Permalink"></a></h2><h3 id="Global-Solver"><a class="docs-heading-anchor" href="#Global-Solver">Global Solver</a><a id="Global-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Solver" title="Permalink"></a></h3><p>We can solve the model for some eigenvalues using one of the eigenvalue solvers. The package provides you with two types of eigenvalue solvers. A global contour-integration-based solver. That finds you all eigenvalues inside of a specified contour Î in the complex plane.</p><pre><code class="language-julia">Î=[150.0+5.0im, 150.0-5.0im, 1000.0-5.0im, 1000.0+5.0im].*2*pi #corner points for the contour (in this case a rectangle)
Î©, P = beyn(L,Î,l=5,N=256, output=true)</code></pre><pre class="documenter-example-output">(Complex{Float64}[1711.4187608614363 + 8.62316956628517im, 4370.048951426738 + 25.289648986111153im], Complex{Float64}[0.0003632488102475537 - 0.01834031619600166im 6.761239033017678e-5 + 0.04355322195158859im; 0.00036325300744217205 - 0.018407015391644795im 6.785964180127594e-5 + 0.04355337777869356im; â¦ ; 0.0003403596292166756 - 0.025501769394082243im 9.418377340769333e-5 + 0.040765369621667644im; -0.0003194854554595479 - 0.05397508026360308im 0.00020041757690195927 - 0.038672353843390336im])</pre><p>The found eigenvalues are stored in the array <code>Î©</code>. The corresponding eigenvectors are the columns of <code>P</code>. The huge advantage of the global eigenvalue solver is that it finds you multiple eigenvalues. Nonetheless, its accuracy may be low and sometimes it provides you with outright wrong solutions. However, for the current case the method works as we can verify that in our search window there are two eigenmodes oscilating at 272 and 695 Hz respectively:</p><pre><code class="language-julia">for Ï in Î©
    println(&quot;Frequency: $(Ï/2/pi)&quot;)
end</code></pre><pre class="documenter-example-output">Frequency: 272.38075549130394 + 1.3724200615938802im
Frequency: 695.5148921731194 + 4.024972645198529im</pre><h3 id="Local-Solver"><a class="docs-heading-anchor" href="#Local-Solver">Local Solver</a><a id="Local-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Solver" title="Permalink"></a></h3><p>To get high accuracy eigenvalues , there are also local iterative eigenvalue solvers. Based on an initial guess, they only find you one eigenvalue at a time but with machine-precise accuracy. One of these solvers is based on the method of successive linear problems (mslp). You call it as follows:</p><pre><code class="language-julia">sol,nn,flag=mslp(L,250*2*pi,output=true);</code></pre><pre class="documenter-example-output">Launching MSLP solver...
Iter   dz:     z:
----------------------------------
0			Inf	1570.7963267948965
1			144.7512883689692	1715.5476151638657 + 7.516104496360754e-13im
2			6.1067775966380395	1709.4408375672276 + 6.992327766313931e-13im
3			0.01090787460429965	1709.4299296926233 + 6.990634438094383e-13im
4			3.4808635973604396e-8	1709.4299296578147 + 6.990634427843083e-13im
5			1.3642420526593924e-12	1709.4299296578133 + 6.990634427873366e-13im
6			1.5916157281026244e-12	1709.4299296578117 + 6.990634427876007e-13im
7			2.483965218359922e-26	1709.4299296578117 + 6.990634427875759e-13im
8			2.0194839173657902e-27	1709.4299296578117 + 6.990634427875779e-13im
9			9.087677628146056e-28	1709.4299296578117 + 6.990634427875788e-13im
10		8.556944110533481e-10	2.2737367544323206e-13	1709.4299296578115 + 6.990634427876056e-13im
Warning: Maximum number of iterations has been reached!
...finished MSLP!
#####################
 Results
#####################
Number of steps: 10
Last step parameter variation:2.2737367544323206e-13
Auxiliary eigenvalue Î» residual (rhs):8.556944110533481e-10
Eigenvalue:1709.4299296578115 + 6.990634427876056e-13im</pre><p>The return values of this solver are a solution object <code>sol</code>, the number of iterations <code>nn</code> performed by the solver and an error flag <code>flag</code> providing information on the quality of the solution. If <code>flag==0</code> the solution has converged. If <code>flag&lt;0</code> something went wrong. And if <code>flag&gt;0</code>... well, probably the solution is fine but you should check it.</p><p>In the current case the flag is 1 indicating that the maximum number of iterations has been reached. This is because we haven&#39;t specified a stopping criterion and the iteration just ran for the maximum number of iterations. Nevertheless, the 272 Hz mode is correct. Indeed, as you can see from the printed output it already converged to machine-precision after 5 iterations.</p><h2 id="Changing-a-specified-parameter."><a class="docs-heading-anchor" href="#Changing-a-specified-parameter.">Changing a specified parameter.</a><a id="Changing-a-specified-parameter.-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-a-specified-parameter." title="Permalink"></a></h2><p>Remember that we have specified the parameters <code>Y</code>,<code>n</code>, and <code>Ï</code>?. We can change these easily without rediscretizing our model. For instance currently <code>n==0.0</code> so the solution is purely acoustic. The effect of the flame just enters the problem via the speed of sound field (this is known as passive flame). By setting the interaction index to <code>1.0</code> we activate the flame.</p><pre><code class="language-julia">L.params[:n]=1</code></pre><pre class="documenter-example-output">1</pre><p>Now we can just solve the model again to get the active solutions</p><pre><code class="language-julia">sol_actv,nn,flag=mslp(L,245*2*pi-82im*2*pi,output=true,order=3);</code></pre><pre class="documenter-example-output">Launching MSLP solver...
Iter   dz:     z:
----------------------------------
0			Inf	1539.3804002589986 - 515.221195188726im
1			1019.4775205432949	1053.6470564007975 + 381.1032625593791im
2			23.472745200482013	1075.3252077129691 + 372.1017336373935im
3			3.361460350470734e-5	1075.3252115068922 + 372.10176703720964im
4			4.190347093584501e-11	1075.3252115068517 + 372.1017670371988im
5			7.41866506207056e-12	1075.3252115068453 + 372.1017670372026im
6			1.2736097495586632e-11	1075.3252115068326 + 372.1017670372029im
7			5.514690581383049e-12	1075.325211506838 + 372.1017670372021im
8			4.351399913731402e-12	1075.325211506834 + 372.1017670372006im
9			2.3437142008433856e-13	1075.3252115068337 + 372.10176703720055im
10		4.1541902042462e-9	1.8410599683081325e-12	1075.325211506832 + 372.10176703720026im
Warning: Maximum number of iterations has been reached!
...finished MSLP!
#####################
 Results
#####################
Number of steps: 10
Last step parameter variation:1.8410599683081325e-12
Auxiliary eigenvalue Î» residual (rhs):4.1541902042462e-9
Eigenvalue:1075.325211506832 + 372.10176703720026im</pre><p>The eigenfrequency is now complex:</p><pre><code class="language-julia">sol_actv.params[:Ï]/2/pi</code></pre><pre class="documenter-example-output">171.14332284265015 + 59.221835557199306im</pre><p>with a growth rate <code>-imag(sol_actv.params[:Ï]/2/pi)â  59.22</code></p><p>Instead of recomputing the eigenvalue by one of the solvers. We can also approximate the eigenvalue as a function of one of the model parameters utilizing high-order perturbation theory. For instance this gives you the 30th order diagonal PadÃ© estimate expanded from the passive solution.</p><pre><code class="language-julia">perturb_fast!(sol,L,:n,16) #compute the coefficients
freq(n)=sol(:n,n,8,8)/2/pi #create some function for convenience
freq(1) #evaluate the function at any value for `n` you are interested in.</code></pre><pre class="documenter-example-output">172.47570467361967 + 59.82427381825554im</pre><p>The method is slow when only computing one eigenvalue. But its computational costs are almost constant when computing multiple eigenvalues. Therefore, for larger parametric studies this is clearly the method of choice.</p><h2 id="VTK-Output-for-Paraview"><a class="docs-heading-anchor" href="#VTK-Output-for-Paraview">VTK Output for Paraview</a><a id="VTK-Output-for-Paraview-1"></a><a class="docs-heading-anchor-permalink" href="#VTK-Output-for-Paraview" title="Permalink"></a></h2><p>To visualize your solutions you can store them as <code>&quot;*.vtu&quot;</code> files to open them with paraview. Just, create a dictionary, where your modes are stored as fields.</p><pre><code class="language-julia">data=Dict()
data[&quot;speed_of_sound&quot;]=c
data[&quot;abs&quot;]=abs.(sol_actv.v)/maximum(abs.(sol_actv.v)) #normalize so that max=1
data[&quot;phase&quot;]=angle.(sol_actv.v)

vtk_write(&quot;tutorial_01&quot;, mesh, data) # Write the solution to paraview</code></pre><p>The <code>vtk_write</code> function automatically sorts your data by its interpolation scheme. Data that is constant on a tetrahedron will be written to a file <code>*_const.vtu</code>, data that is linearly interpolated on a tetrahedron will go to <code>*_lin.vtu</code>, and data that is quadratically interpolated to <code>*_quad.vtu</code>. The current example uses constant speed of sound on a tetrahedron and linear finite elements for the discretization of p. Therefore, two files are generated, namely <code>tutorial_01_const.vtu</code> containing the speed-of-sound field and <code>tutorial_01_lin.vtu</code> containing the mode shape. Open them with paraview and have a look!.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>You learnt how to set-up a simple Rijke-tube study. This  already introduced all basic steps that are needed to work with the Helmholtz solver. However, there are a lot of details you can fine tune and even features that weren&#39;t mentioned in this tutorial. The next tutorials will introduce these aspects in more detail.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial_00_NLEVP.html">Â« Tutorial 00 Introduction to the NLEVP module</a><a class="docs-footer-nextpage" href="tutorial_02_global_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s Global Eigenvalue Solver Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 20 April 2021 09:17">Tuesday 20 April 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
