<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 07 Bloch periodicity · WavesAndEigenvalues.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavesAndEigenvalues.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="installation.html">Install</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="tutorial_00_NLEVP.html">Tutorial 00 Introduction to the NLEVP module</a></li><li><a class="tocitem" href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li><li><a class="tocitem" href="tutorial_02_global_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s Global Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_03_local_eigenvalue_solver.html">Tutorial 03  A Local Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_04_perturbation_theory.html">Tutorial 04 Perturbation Theory</a></li><li><a class="tocitem" href="tutorial_05_mesh_refinement.html">Tutorial 05 Mesh Refinement</a></li><li><a class="tocitem" href="tutorial_06_second_order_elements.html">Tutorial 06 Second Order Elements</a></li><li class="is-active"><a class="tocitem" href="tutorial_07_Bloch_periodicity.html">Tutorial 07 Bloch periodicity</a><ul class="internal"><li><a class="tocitem" href="#Model-Set-up"><span>Model Set-up</span></a></li><li><a class="tocitem" href="#Discretizing-the-full-mesh"><span>Discretizing the full mesh</span></a></li><li><a class="tocitem" href="#Unit-cell-computation"><span>Unit cell computation</span></a></li><li><a class="tocitem" href="#Writing-output-to-paraview"><span>Writing output to paraview</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="tutorial_08_custom_FTF.html">Tutorial 08 Custom FTF</a></li><li><a class="tocitem" href="tutorial_09_forcing.html">Tutorial 09 Forcing</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="NLEVP.html">The NLEVP module</a></li><li><a class="tocitem" href="Meshutils.html">The Meshutils module</a></li><li><a class="tocitem" href="Helmholtz.html">The Helmholtz module</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="tutorial_07_Bloch_periodicity.html">Tutorial 07 Bloch periodicity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial_07_Bloch_periodicity.html">Tutorial 07 Bloch periodicity</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-07-Bloch-periodicity"><a class="docs-heading-anchor" href="#Tutorial-07-Bloch-periodicity">Tutorial 07 Bloch periodicity</a><a id="Tutorial-07-Bloch-periodicity-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-07-Bloch-periodicity" title="Permalink"></a></h1><p>The Helmholtz solver was designed with the application of thermoacoustic stability assesment in mind. A very common case is that an annular combustion chamber needs assessment. These chamber types feature a discrete rotational symmetry, i.e., they are built from one constituent entity – the unit cell – that implicitly defines the annular geometry by copying it around the circumference multiple times. This high regularity of the geometry can be used to efficiently model the problem, e.g. only storing the unit cell instead of the entire geometry in a mesh-file in order to save memory and even performing the entire analysis thereby significantly accelerating the computations [1] This tutorial teaches you how using these features.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To do this tutorial yourself you will need the <code>&quot;NTNU_12.msh</code>&quot; file. Download it <a href="NTNU_12.msh">here</a>.</p></div></div><h2 id="Model-Set-up"><a class="docs-heading-anchor" href="#Model-Set-up">Model Set-up</a><a id="Model-Set-up-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Set-up" title="Permalink"></a></h2><p>As a geometry we choose the laboratory-scale annular combustor used at NTNU Norway [2]. The NTNU combustor features unit cells that are reflection-symmetric. The meshfile <code>NTNU_12.msh</code>, thus, stores only one half of the unit cell. Let&#39;s load it...</p><pre><code class="language-julia">using WavesAndEigenvalues.Helmholtz
mesh=Mesh(&quot;NTNU_12.msh&quot;,scale=1.0);</code></pre><p>Note that there are two special domains named <code>&quot;Bloch&quot;</code> and <code>&quot;Symmetry&quot;</code>. These are surfaces associated with the special symmetries of the combustor geometry. <code>&quot;Bloch&quot;</code> is the surface where one unit cell ends and the next one should begin, while <code>&quot;Symmetry&quot;</code> is the symmetry plane of the unit-cell. As the mesh is stored as a half-cell both surfaces are boundaries. The code will automatically use them to create the full mesh or just a unit-cell. First, let&#39;s create a full mesh We therefore specify the expansion scheme, this is a list of tuples containing all domain names we like to expand together with a qualifyer that is either <code>:full</code>,<code>:unit</code>, or <code>:half</code>, in order to tell the the code whether the copied versions should be merged into one addressable domain of the same name spanning the entire annulus (<code>:full</code>), pairs of domains from two corresponding half cells should be merged into individually adressable entities (<code>:unit</code>), or the copied hald cells remain individually addressable (:half). In the current case we only need individual names for each flames and can sefely merge all other entities. The scheme therefore reads:</p><pre><code class="language-julia">doms=[(&quot;Interior&quot;,:full),(&quot;Inlet&quot;,:full), (&quot;Outlet_high&quot;,:full),
     (&quot;Outlet_low&quot;,:full), (&quot;Flame&quot;,:unit),];</code></pre><p>and we can generate the mesh by</p><pre><code class="language-julia">full_mesh=extend_mesh(mesh,doms);</code></pre><p>The code automatically recognizes the degree of symmetry – 12 in the current case– and expands the mesh. Note how the full mesh now has 12 consecutively numbered flames, while all other entities still have a single name even though they were copied.</p><h2 id="Discretizing-the-full-mesh"><a class="docs-heading-anchor" href="#Discretizing-the-full-mesh">Discretizing the full mesh</a><a id="Discretizing-the-full-mesh-1"></a><a class="docs-heading-anchor-permalink" href="#Discretizing-the-full-mesh" title="Permalink"></a></h2><p>The generated mesh behaves just like any other mesh. We can use it to discretize the model.</p><pre><code class="language-julia">speedofsound(x,y,z)=z&lt;0.415 ? 347.0 : 850.0; #speed of sound field in m/s
C=generate_field(full_mesh,speedofsound);
dscrp=Dict(); #model description
dscrp[&quot;Interior&quot;]=(:interior,());
dscrp[&quot;Outlet_high&quot;]=(:admittance, (:Y_in,0));# src
dscrp[&quot;Outlet_low&quot;]=(:admittance, (:Y_out,0));# src
L=discretize(full_mesh, dscrp, C,order=:lin)</code></pre><pre class="documenter-example-output">22987×22987-dimensional operator family: 

ω*Y_out*C+ω^2*M+K+ω*Y_in*C

Parameters
----------
λ	Inf + 0.0im
ω	0.0 + 0.0im
Y_in	0.0 + 0.0im
Y_out	0.0 + 0.0im
</pre><p>We can use all our standard tools to solve the model. For instance, Indlekofer et al. report on a plenum-dominant 1124Hz-mode that is first order with respect to the azimuthal direction and also first order with respect to the axial direction. Let&#39;s see whether we can find it by putting 1000 Hz as an initial guess.</p><pre><code class="language-julia">sol,nn,flag=mslp(L,1000,tol=1E-9,scale=2pi,output=true);</code></pre><pre class="documenter-example-output">Launching MSLP solver...
scale: 6.283185307179586
Iter   dz:     z:
----------------------------------
0		Inf	999.9999999999999
1		123.12819008931804	1123.128190089318
2		0.4821754578897787	1123.6103655472077
3		0.00010345806850245335	1123.6102620891393
4		1.9541327962911847e-11	1123.6102620891197
Solution has converged!
...finished MSLP!
#####################
 Results
#####################
Number of steps: 4
Last step parameter variation:1.227817847393453e-10
Auxiliary eigenvalue λ residual (rhs):1.7353565060630459e-6
Eigenvalue:1123.6102620891197</pre><p>There it is! But to be honest the computation is kinda slow. Obviously, this is because the full mesh is quite large. Let&#39;s see how the unit cell computation would do....</p><h2 id="Unit-cell-computation"><a class="docs-heading-anchor" href="#Unit-cell-computation">Unit cell computation</a><a id="Unit-cell-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-cell-computation" title="Permalink"></a></h2><p>Ok, first, we create the unit cell mesh. We therefore set the keyowrd parameter <code>unit</code> to <code>true</code> in the call to <code>extend_mesh</code>.</p><pre><code class="language-julia">unit_mesh=extend_mesh(mesh,doms,unit=true)</code></pre><pre class="documenter-example-output">mesh: unit from NTNU_12.msh
#################
points:     2329
lines:      12444
triangles:  1484
tetrahedra: 8446
#################
domains: Flame#0, Inlet, Interior, Outlet_high, Outlet_low</pre><p>Voila, there we have it! Discretization is nearly as simple as with a normal mesh. However, to invoke special Bloch-periodic boundary conditions the optional parameter <code>b</code> must be set to define a symbol that is used as the Bloch wavenumber. The rest is as before.</p><pre><code class="language-julia">c=generate_field(unit_mesh,speedofsound);
l=discretize(unit_mesh, dscrp, c, b=:b)</code></pre><pre class="documenter-example-output">1933×1933-dimensional operator family: 

ω*Y_out*C+ω*Y_out*exp(ib2π/12)*C+ω*Y_out*exp(-ib2π/12)*C+ω*Y_out*δ(b)*C+ω*Y_out*δ(b)*exp(ib2π/12)*C+ω*Y_out*δ(b)*exp(-ib2π/12)*C+ω^2*M+ω^2*exp(ib2π/12)*M+ω^2*exp(-ib2π/12)*M+ω^2*δ(b)*M+ω^2*δ(b)*exp(ib2π/12)*M+ω^2*δ(b)*exp(-ib2π/12)*M+K+*exp(ib2π/12)*K+*exp(-ib2π/12)*K+*δ(b)*K+*δ(b)*exp(ib2π/12)*K+*δ(b)*exp(-ib2π/12)*K+ω*Y_in*C+ω*Y_in*exp(ib2π/12)*C+ω*Y_in*exp(-ib2π/12)*C+ω*Y_in*δ(b)*C+ω*Y_in*δ(b)*exp(ib2π/12)*C+ω*Y_in*δ(b)*exp(-ib2π/12)*C+(1-δ(b))*D

Parameters
----------
b	0.0 + 0.0im
λ	Inf + 0.0im
ω	0.0 + 0.0im
Y_in	0.0 + 0.0im
Y_out	0.0 + 0.0im
</pre><p>Note how the signature of the discretized operator is now much longer. These extra terms facilitate the Bloch periodicity. What is important is the parameter <code>:b</code> that is used to set the Bloch wavenumber. For relatively low frequencies, the Bloch wave number corresponds to the azimuthal mode order. Effectively, it acts like a filter to the eigenmodes. Setting it to <code>1</code> will give us mainly first order modes.   (In general it gives us modes with azimuthal order <code>k*12+1</code> where <code>k</code> is a natural number including 0, but 13th order modes are very high in frequency and therefore don&#39;t bother us). In comparison to the full model, this is an extra advantage of Bloch wave theory, as we cannot filter for certain mode shapes using the full mesh. This feature also allows us to reduce the estimate for eigenvalues inside the integration contour when using Beyn&#39;s algorithm, as there can only be eigenmodes corresponding to the current Bloch wavenumber. Let&#39;s try finding 1124-Hz mode again. It&#39;s of first azimuthal order so we should put the Bloch wavenumber to 1.</p><pre><code class="language-julia">l.params[:b] = 1;
sol,nn,flag = mslp(l,1000,tol=1E-9, scale=2pi, output=true);</code></pre><pre class="documenter-example-output">Launching MSLP solver...
scale: 6.283185307179586
Iter   dz:     z:
----------------------------------
0		Inf	999.9999999999999
1		127.20107543230797	872.798924567692 + 7.406416813969517e-14im
2		9.271457110544489	863.5274674571475 + 1.3191702956989754e-14im
3		0.04978223109540639	863.477685226052 + 4.341711409064263e-14im
4		1.4353235664278573e-6	863.4776837907285 - 9.6106619227306e-14im
5		1.0136616056359396e-12	863.4776837907295 - 1.2484850598797733e-13im
Solution has converged!
...finished MSLP!
#####################
 Results
#####################
Number of steps: 5
Last step parameter variation:6.369023706983804e-12
Auxiliary eigenvalue λ residual (rhs):6.580759984541837e-8
Eigenvalue:863.4776837907295 - 1.2484850598797733e-13im</pre><p>The computation is much faster than with the full mesh, but the eigenfrequency is exactly the same!</p><h2 id="Writing-output-to-paraview"><a class="docs-heading-anchor" href="#Writing-output-to-paraview">Writing output to paraview</a><a id="Writing-output-to-paraview-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-output-to-paraview" title="Permalink"></a></h2><p>Not only the eigemnvalues much but also the mode shapes. Bloch wave theory clearly dictates how to extend the mode shape from the unit cell to recover the full-annulus solution.</p><p>The `vtk<em>write  function does this for you. You, therefore, have to provide it with the current Bloch wavenumber. If you provide it with the unit</em>cell mesh, it will just write a single sector to the file.</p><pre><code class="language-julia">data=Dict();
v=bloch_expand(full_mesh,sol,:b);
data[&quot;abs&quot;]=abs.(v)./maximum(abs.(v));
data[&quot;pahase&quot;]=angle.(v)./pi;
vtk_write(&quot;Bloch_tutorial&quot;,full_mesh,data);</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>Bloch-wave-based analysis, significantly reduces the size of your problem without sacrificing any precission. It thereby saves you both memory and computational time.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] Efficient Computation of Thermoacoustic Modes in Industrial Annular Combustion Chambers Based on Bloch-Wave Theory, G.A. Mensah, G. Campa,  J.P. Moeck 2016, J. Eng. Gas Turb. and Power,<a href="https://doi.org/10.1115/1.4032335">doi:10.1115/1.4032335</a></p><p>[2] The effect of dynamic operating conditions on the thermoacoustic response of hydrogen rich flames in an annular combustor,  T. Indlekofer, A. Faure-Beaulieu, N. Noiray and J. Dawson, 2021, Comb. and Flame, <a href="https://doi.org/10.1016/j.combustflame.2020.10.013">doi:10.1016/j.combustflame.2020.10.013</a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial_06_second_order_elements.html">« Tutorial 06 Second Order Elements</a><a class="docs-footer-nextpage" href="tutorial_08_custom_FTF.html">Tutorial 08 Custom FTF »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 8 June 2021 16:00">Tuesday 8 June 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
