<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The NLEVP module · WavesAndEigenvalues.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavesAndEigenvalues.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="installation.html">Install</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="tutorial_00_NLEVP.html">Tutorial 00 Introduction to the NLEVP module</a></li><li><a class="tocitem" href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li><li><a class="tocitem" href="tutorial_02_global_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s Global Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_03_local_eigenvalue_solver.html">Tutorial 03  A Local Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_04_perturbation_theory.html">Tutorial 04 Perturbation Theory</a></li><li><a class="tocitem" href="tutorial_05_mesh_refinement.html">Tutorial 05 Mesh Refinement</a></li><li><a class="tocitem" href="tutorial_06_second_order_elements.html">Tutorial 06 Second Order Elements</a></li><li><a class="tocitem" href="tutorial_07_Bloch_periodicity.html">Tutorial 07 Bloch periodicity</a></li><li><a class="tocitem" href="tutorial_08_custom_FTF.html">Tutorial 08 Custom FTF</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href="NLEVP.html">The NLEVP module</a><ul class="internal"><li><a class="tocitem" href="#Exported-functionality:"><span>Exported functionality:</span></a></li><li><a class="tocitem" href="#Private-functionality:"><span>Private functionality:</span></a></li></ul></li><li><a class="tocitem" href="Meshutils.html">The Meshutils module</a></li><li><a class="tocitem" href="Helmholtz.html">The Helmholtz module</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="NLEVP.html">The NLEVP module</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="NLEVP.html">The NLEVP module</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/master/docs/src/NLEVP.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-NLEVP-module"><a class="docs-heading-anchor" href="#The-NLEVP-module">The NLEVP module</a><a id="The-NLEVP-module-1"></a><a class="docs-heading-anchor-permalink" href="#The-NLEVP-module" title="Permalink"></a></h1><h2 id="Exported-functionality:"><a class="docs-heading-anchor" href="#Exported-functionality:">Exported functionality:</a><a id="Exported-functionality:-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functionality:" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP" href="#WavesAndEigenvalues.NLEVP"><code>WavesAndEigenvalues.NLEVP</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module containing routines to solve and perturb nonlinear eigenvalue problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.LinearOperatorFamily" href="#WavesAndEigenvalues.NLEVP.LinearOperatorFamily"><code>WavesAndEigenvalues.NLEVP.LinearOperatorFamily</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearOperatorFamily</code></pre><p>Type for a linear operator family. The type is mutable.</p><p><strong>Fields</strong></p><ul><li><code>terms</code>: Array of terms forming the operator family</li><li><code>params</code>: Dictionary mapping parameter symbols to their values</li><li><code>eigval</code>: the symbol of the parameter that is the eigenvalue</li><li><code>auxval</code>: the symbol of the parameter that is the auxiliary eigenvalue</li><li><code>active</code>: list of symbols that can be actively change when using an instance of</li></ul><p>the family as a function.</p><ul><li><code>mode</code>: mode that is controlling which terms are evalauted when calling an</li></ul><p>instance of the family. This field is not to be modified by the user.</p><p>See also: <a href="@ref">Solution</a>, <a href="@ref">Term</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L114-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.LinearOperatorFamily-Tuple{String}" href="#WavesAndEigenvalues.NLEVP.LinearOperatorFamily-Tuple{String}"><code>WavesAndEigenvalues.NLEVP.LinearOperatorFamily</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">L=LinearOperatorFamily(fname::String)</code></pre><p>Load and construct <code>LinearOperatorFamily</code> from file <code>fname</code>.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.save-Tuple{Any,WavesAndEigenvalues.NLEVP.LinearOperatorFamily}"><code>save</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.Solution" href="#WavesAndEigenvalues.NLEVP.Solution"><code>WavesAndEigenvalues.NLEVP.Solution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Solution</code></pre><p>Type for the solution of an iterative eigensolver.</p><p><strong>Fields</strong></p><ul><li><code>params</code>: Dictionary mapping parameter symbols to their values</li><li><code>v</code>: right (direct) eigenvector</li><li><code>v_adj</code>: left (adjoint) eigenvector</li><li><code>eigval</code>: the symbol of the parameter that is the eigenvalue</li><li><code>eigval_pert</code>: extra data for asymptotic series expansion of the eigenvalue</li><li><code>v_pert</code>: extra data for asymptotic series expansion of the eigenvector</li><li><code>auxval</code>: the symbol of the parameter that is the auxiliary eigenvalue</li></ul><p>See also: <a href="@ref">LinearOperatorFamily</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L79-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.Solution" href="#WavesAndEigenvalues.NLEVP.Solution"><code>WavesAndEigenvalues.NLEVP.Solution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">sol=Solution(params,v,v_adj,eigval,auxval=Symbol())</code></pre><p>Standard constructor for a solution object. See <a href="@ref">Solution</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.Term" href="#WavesAndEigenvalues.NLEVP.Term"><code>WavesAndEigenvalues.NLEVP.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Term{T}</code></pre><p>Single term of a linear operator family.</p><p><strong>Fields</strong></p><ul><li><code>coeff::T</code>: matrix coefficient of the term</li><li><code>func::Tuple</code>: tuple of scalar-valued functions multiplying the matrix coefficient</li><li><code>symbol::String</code>: character string for displaying the function(s)</li><li><code>params::Tuple</code>: tuple of tuples containing function symbols for each function</li><li><code>operator:String</code>: String for displaying the matrix coefficient</li><li><code>varlist::Array{Symbol,1}</code>: Array containing all symbols of fucntion arguments</li></ul><p>that are used at least once</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.Term-Tuple{Any,Tuple,Tuple,String}" href="#WavesAndEigenvalues.NLEVP.Term-Tuple{Any,Tuple,Tuple,String}"><code>WavesAndEigenvalues.NLEVP.Term</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">term=Term(coeff,func::Tuple,params::Tuple,operator::String)</code></pre><p>Standard constructor for type <code>Term</code>.</p><p><strong>Arguments</strong></p><ul><li><code>coeff</code>: matrix coefficient of the term</li><li><code>func::Tuple</code>: tuple of scalar-valued functions multiplying the matrix coefficient</li><li><code>params::Tuple</code>: tuple of tuples containing function symbols for each function</li><li><code>operator:String</code>: String for displaying the matrix coefficient</li></ul><p><strong>Notes</strong></p><p>The rendering of the functions of <code>term</code> ist automotized. If the passed functions implement a method <code>f(z::Symbol)</code> then this method is used, otherwise the functions will be simply displayed with the string <code>f</code>. You can overwrite this behavior by explicitly passing a string for the function display using the syntax</p><p>term =Term(coeff,func::Tuple,params::Tuple,symbol::String,operator::String)</p><p>where the extra argument <code>symbol</code>is the string used to display the function.</p><p>See also: <a href="@ref">LinearOperatorFamily</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L37-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}" href="#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>WavesAndEigenvalues.NLEVP.beyn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Ω, P = beyn(L::LinearOperatorFamily, Γ; &lt;keyword arguments&gt;)</code></pre><p>Compute all eigenvalues of <code>L</code> inside the contour <code>Γ</code> together with the associated eigenvectors. The contour is given as a list of complex numbers which are interpreted as polygon vertices in the complex plane.  The eigenvalues are stored in the list <code>Ω</code> and the eigenvectors are stored in the columns of <code>P</code>. The eigenvector <code>P[:,i]</code> corresponds to the eigenvalue <code>Ω[i]</code>, i.e., they satisfy <code>L(Ω[i])P[:,i]=0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code>: Definition of the non-linear eigenvalue problem</li><li><code>Γ::Array</code>: List of complex points defining the contour.</li><li><code>l::Integer = 5</code>: estimate of the number of eigenvalues inside of <code>Γ</code>.</li><li><code>K::Integer = 1</code>: Augmention dimension if <code>Γ</code> is assumed to contain more than <code>size(L)[1]</code> eigenvalues.</li><li><code>N::Integer = 16</code>: Number of evaluation points used to perform the Gauss-Legendre integration along each edge of <code>Γ</code>.</li><li><code>tol::Float=0.0</code>: Threshold value to discard spurious singular values. If set to <code>0</code> (the default) no singular values are discarded.</li><li><code>pos_test::bool=true</code>: If set to <code>true</code> perform positions test on the computed eigenvalues, i.e., check whether the eigenvalues are enclosed by <code>Γ</code> and disregard all eigenvalues which fail the test.</li><li><code>output::bool=true</code>: Show progressbar if <code>true</code>.</li><li><code>random::bool=false</code>: Randomly initialize the V matrix if <code>true</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Ω::Array</code>: List of computed eigenvalues</li><li><code>P::Matrix</code>: Matrix of eigenvectors.</li></ul><p><strong>Notes</strong></p><p>The original algorithm was first presented by Beyn in [1]. The implementation closely follows the pseudocode from Buschmann et al. in [2].</p><p><strong>References</strong></p><p>[1] W.-J. Beyn, An integral method for solving nonlinear eigenvalue problems, Linear Algebra and its Applications, 2012, 436(10), p.3839-3863, https://doi.org/10.1016/j.laa.2011.03.030</p><p>[2] P.E. Buschmann, G.A. Mensah, J.P. Moeck, Solution of Thermoacoustic Eigenvalue Problems with a Non-Iterative Method, J. Eng. Gas Turbines Power, Mar 2020, 142(3): 031022 (11 pages) https://doi.org/10.1115/1.4045076</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}"><code>inveriter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}"><code>lancaster</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}"><code>mslp</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}"><code>rf2s</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}"><code>traceiter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/beyn.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.compute_moment_matrices-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}" href="#WavesAndEigenvalues.NLEVP.compute_moment_matrices-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>WavesAndEigenvalues.NLEVP.compute_moment_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">A=compute_moment_matrices(L,Γ, &lt;kwargs&gt;)</code></pre><p>Compute moment matrices of <code>L</code> integrating along <code>Γ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code></li><li><code>Γ</code>: List of complex points defining the contour.</li><li><code>l::Int=5</code>: (optional) estimate of the number of eigenvalues inside of <code>Γ</code>.</li><li><code>K::Int=1</code>: (optional) Augmention dimension if <code>Γ</code> is assumed to contain more than <code>size(L)[1]</code> eigenvalues.</li><li><code>N::Int=16</code>: (optional)  Number of evaluation points used to perform the Gauss-Legendre integration along each edge of <code>Γ</code>.</li><li><code>output::Bool=false</code> (optional) toggle waitbar</li><li><code>random::Bool=false</code> (optional) toggle random initialization of V-matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>A::Array</code>: Moment matrices.</li></ul><p><strong>Notes</strong></p><p>A is a 3 dimensional array. The last index loops over the various Moments, i.e., <code>A[:,:,i]=∫_Γ z^i inv(L(z)) V dz</code>. If <code>random</code>=false V is initialized with ones on its main diagonal. Otherwise it is random.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/beyn.jl#L211-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.count_poles_and_zeros-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.count_poles_and_zeros-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.count_poles_and_zeros</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">n=count_poles_and_zeros(L,Γ;N=16,output=false)</code></pre><p>Count number &quot;n&quot; of poles and zeros of the determinant of <code>L</code> inside the contour <code>Γ</code>. The optional parameters <code>N</code> and <code>output</code>. respectively  determine the order of the Gauss-Legendre integration and toggle whether output is desplayed.</p><p><strong>Notes</strong></p><p>Pole orders count negative while zero order count positive. The evaluation is based on applying the residue theorem to the determinant. It utilizes Jacobi&#39;s formula to compute the necessary derivatives from a trace operation. and is therefore only suitable for small problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/beyn.jl#L340-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.decode_error_flag-Tuple{Int64}" href="#WavesAndEigenvalues.NLEVP.decode_error_flag-Tuple{Int64}"><code>WavesAndEigenvalues.NLEVP.decode_error_flag</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">msg=decode_error_flag(flag::Int)</code></pre><p>Decode error flag <code>flag</code> from an iterative solver into a string <code>msg</code>.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}"><code>inveriter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}"><code>lancaster</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}"><code>mslp</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}"><code>rf2s</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}"><code>traceiter</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/iterative_solvers.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.householder-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.householder-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.householder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sol::Solution, n, flag = householder(L::LinearOperatorFamily, z; &lt;keyword arguments&gt;)</code></pre><p>Use a Householder method to iteratively find an eigenpar of <code>L</code>, starting the the iteration from <code>z</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code>: Definition of the nonlinear eigenvalue problem.</li><li><code>z</code>: Initial guess for the eigenvalue.</li><li><code>maxiter::Integer=10</code>: Maximum number of iterations.</li><li><code>tol=0</code>: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is <code>abs(z0-z1)&lt;tol</code> the iteration is aborted.</li><li><code>relax=1</code>: relaxation parameter</li><li><code>lam_tol=Inf</code>: tolerance for the auxiliary eigenvalue to test convergence. The default is infinity, so there is effectively no test.</li><li><code>order::Integer=1</code>: Order of the Householder method, Maximum is 5</li><li><code>nev::Integer=1</code>: Number of Eigenvalues to be searched for in intermediate ARPACK calls.</li><li><code>v0::Vector</code>: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with ones.</li><li><code>v0_adj::Vector</code>: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with <code>v0</code>.</li><li><code>output::Bool</code>: Toggle printing online information.</li></ul><p><strong>Returns</strong></p><ul><li><code>sol::Solution</code></li><li><code>n::Integer</code>: Number of perforemed iterations</li><li><code>flag::Integer</code>: flag reporting the success of the method. Most important values are <code>1</code>: method converged, <code>0</code>: convergence might be slow, <code>-1</code>:maximum number of iteration has been reached. For other error codes see the source code.</li></ul><p><strong>Notes</strong></p><p>Housholder methods are a generalization of Newton&#39;s method. If order=1 the Housholder method is identical to Newton&#39;s method. The solver then reduces to the &quot;generalized Rayleigh Quotient iteration&quot; presented in [1]. If no relaxation is used (<code>relax == 1</code>), the convergence rate is of <code>order+1</code>. With relaxation (<code>relax != 1</code>) the convergence rate is 1. Thus, with a higher order less iterations will be necessary. However, the computational time must not necessarily improve nor do the convergence properties. Anyway, if the method converges, the error in the eigenvalue is bounded above by <code>tol</code>. For more details on the solver, see the thesis [2].</p><p><strong>References</strong></p><p>[1] P. Lancaster, A Generalised Rayleigh Quotient Iteration for Lambda-Matrices,Arch. Rational Mech Anal., 1961, 8, p. 309-322, https://doi.org/10.1007/BF00277446</p><p>[2] G.A. Mensah, Efficient Computation of Thermoacoustic Modes, Ph.D. Thesis, TU Berlin, 2019</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>beyn</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/Householder.jl#L36-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.inveriter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sol,n,flag = inveriter(L,z;maxiter=10,tol=0., relax=1., x0=[],v=[], output=true)</code></pre><p>Deploy inverse iteration for finding an eigenpair of <code>L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code>: Definition of the nonlinear eigenvalue problem.</li><li><code>z</code>: Initial guess for the eigenvalue.</li><li><code>maxiter::Integer=10</code>: Maximum number of iterations.</li><li><code>tol=0</code>: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is <code>abs(z0-z1)&lt;tol</code> the iteration is aborted.</li><li><code>relax=1</code>: relaxation parameter</li><li><code>x0::Vector</code>: initial guess for eigenvector. If not provided it is all ones.</li><li><code>v0::Vector</code>: normalization vector. If not provided it is all ones.</li><li><code>output::Bool</code>: Toggle printing online information.</li></ul><p><strong>Returns</strong></p><ul><li><code>sol::Solution</code></li><li><code>n::Integer</code>: Number of perforemed iterations</li><li><code>flag::Integer</code>: flag reporting the success of the method. Most important values are <code>1</code>: method converged, <code>0</code>: convergence might be slow, <code>-1</code>:maximum number of iteration has been reached. For other error codes see the source code.</li></ul><p><strong>Notes</strong></p><p>The algorithm uses Newton-Raphson itreations on the vector level for iteratively solving the problem <code>L(λ)x == 0</code> and <code>v&#39;x == 0</code>. The implementation is based on Algorithm 1 in [1]</p><p><strong>References</strong></p><p>[1] V. Mehrmann and H. Voss (2004), Nonlinear eigenvalue problems: A challenge for modern eigenvalue methods, GAMM-Mitt. 27, 121–152.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>beyn</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}"><code>lancaster</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}"><code>mslp</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}"><code>rf2s</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}"><code>traceiter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.decode_error_flag-Tuple{Int64}"><code>decode_error_flag</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/iterative_solvers.jl#L255-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.lancaster</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sol,n,flag = lancaster(L,z;maxiter=10,tol=0., relax=1., x0=[],y0=[], output=true)</code></pre><p>Deploy Lancaster&#39;s Rayleigh-quotient iteration for finding an eigenvalue of <code>L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code>: Definition of the nonlinear eigenvalue problem.</li><li><code>z</code>: Initial guess for the eigenvalue.</li><li><code>maxiter::Integer=10</code>: Maximum number of iterations.</li><li><code>tol=0</code>: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is <code>abs(z0-z1)&lt;tol</code> the iteration is aborted.</li><li><code>relax=1</code>: relaxation parameter</li><li><code>x0::Vector</code>: initial guess for right iteration vector. If not provided it is all ones.</li><li><code>y0::Vector</code>: initial guess for left iteration vector. If not provided it is all ones.</li><li><code>output::Bool</code>: Toggle printing online information.</li></ul><p><strong>Returns</strong></p><ul><li><code>sol::Solution</code></li><li><code>n::Integer</code>: Number of perforemed iterations</li><li><code>flag::Integer</code>: flag reporting the success of the method. Most important values are <code>1</code>: method converged, <code>0</code>: convergence might be slow, <code>-1</code>:maximum number of iteration has been reached. For other error codes see the source code.</li></ul><p><strong>Notes</strong></p><p>The algorithm is a generalization of Rayleigh-quotient-iteration by Lancaster [1].</p><p><strong>References</strong></p><p>[1] P. Lancaster, A Generalised Rayleigh Quotient Iteration for Lambda-Matrices,Arch. Rational Mech Anal., 1961, 8, p. 309-322, https://doi.org/10.1007/BF00277446</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>beyn</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}"><code>inveriter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}"><code>mslp</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}"><code>rf2s</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}"><code>traceiter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.decode_error_flag-Tuple{Int64}"><code>decode_error_flag</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/iterative_solvers.jl#L350-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.moments2eigs-Tuple{Any}" href="#WavesAndEigenvalues.NLEVP.moments2eigs-Tuple{Any}"><code>WavesAndEigenvalues.NLEVP.moments2eigs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Ω,P = moments2eigs(A; tol_σ=0.0, return_σ=false)</code></pre><p>Compute eigenvalues <code>Ω</code> and eigenvectors <code>P from moment matrices</code>A`.</p><p><strong>Arguments</strong></p><ul><li><code>A::Array</code>: moment matrices</li><li><code>tol::Float=0.0</code>: tolerance for truncating singular values.</li><li><code>return_σ::Bool=false</code>: if true also return the singular values as third return value.</li></ul><p><strong>Returns</strong></p><ul><li><code>Ω::Array</code>: List of computed eigenvalues</li><li><code>P::Matrix</code>: Matrix of eigenvectors.</li><li><code>Σ::Array</code>: List of singular values (only if <code>return_σ==true</code>)</li></ul><p><strong>Notes</strong></p><p>The the i-th coloumn in P corresponds to the i-th eigenvalue in <code>Ω</code>, i.e., <code>Ω[i]</code> and <code>P[:,i]</code> are an eigenpair.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.compute_moment_matrices-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>compute_moment_matrices</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/beyn.jl#L269-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.mslp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sol,n,flag = mslp(L,z;maxiter=10,tol=0.,relax=1.,lam_tol=Inf,order=1,nev=1,v0=[],v0_adj=[],num_order=1,scale=1.0+0.0im,output=false)</code></pre><p>Deploy the method of successive linear problems for finding an eigentriple of <code>L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code>: Definition of the nonlinear eigenvalue problem.</li><li><code>z</code>: Initial guess for the eigenvalue.</li><li><code>maxiter::Integer=10</code>: Maximum number of iterations.</li><li><code>tol=0</code>: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is <code>abs(z0-z1)&lt;tol</code> the iteration is aborted.</li><li><code>relax=1</code>: relaxation parameter</li><li><code>lam_tol=Inf</code>: tolerance for the auxiliary eigenvalue to test convergence. The default is infinity, so there is effectively no test.</li><li><code>order::Integer=1</code>: Order of the Householder method, Maximum is 5</li><li><code>nev::Integer=1</code>: Number of Eigenvalues to be searched for in intermediate ARPACK calls.</li><li><code>v0::Vector</code>: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with ones.</li><li><code>v0_adj::Vector</code>: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with <code>v0</code>.</li><li><code>num_order::Int=1</code>: order of the numerator polynomial when forming the Padé approximant.</li><li><code>scale::Number=1</code>: scaling factor applied to the tolerance (and the eigenvalue output when <code>output==true</code>).</li><li><code>output::Bool=false</code>: Toggle printing online information.</li></ul><p><strong>Returns</strong></p><ul><li><code>sol::Solution</code></li><li><code>n::Integer</code>: Number of perforemed iterations</li><li><code>flag::Integer</code>: flag reporting the success of the method. Most important values are <code>1</code>: method converged, <code>0</code>: convergence might be slow, <code>-1</code>:maximum number of iteration has been reached. For other error codes see the source code.</li></ul><p><strong>Notes</strong></p><p>This is a variation of the method of succesive linear Problems [1] as published in Algorithm 3 in [2]. It treats the eigenvalue <code>ω</code> as a parameter in a linear eigenvalue problem <code>L(ω)p=λYp</code> and computes the root of the implicit relation <code>λ(ω)==0</code>.</p><p>The default values &quot;order==1&quot; and &quot;num_order==1&quot; will result in a Newton-iteration for finding the roots. Choosing a higher order will result in Housholder methods as a generalization of Newton&#39;s method. If no relaxation is used (<code>relax == 1</code>), the convergence rate is of <code>order+1</code>. With relaxation (<code>relax != 1</code>) the convergence rate is 1. Thus, with a higher order less iterations will be necessary. However, the computational time must not necessarily improve nor do the convergence properties. Anyway, if the method converges, the error in the eigenvalue is bounded above by <code>tol</code>. For more details on the solver, see the thesis [2].</p><p>Householder methods are based on expanding the relation <code>λ=λ(ω)</code> into a <code>[1/order-1]</code>-Padé approximant. The numerator order may be increased using the keyword &quot;num_order&quot;. This feature is experimental.</p><p><strong>References</strong></p><p>[1] A.Ruhe, Algorithms for the non-linear eigenvalue problem, SIAM J. Numer. Anal. ,10:674–689, 1973.</p><p>[2] V. Mehrmann and H. Voss (2004), Nonlinear eigenvalue problems: A challenge for modern eigenvalue methods, GAMM-Mitt. 27, 121–152.</p><p>[3] G.A. Mensah, Efficient Computation of Thermoacoustic Modes, Ph.D. Thesis, TU Berlin, 2019 <a href="http://dx.doi/10.14279/depositonce-8952">doi:10.14279/depositonce-8952 </a></p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>beyn</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}"><code>inveriter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}"><code>lancaster</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}"><code>rf2s</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}"><code>traceiter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.decode_error_flag-Tuple{Int64}"><code>decode_error_flag</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/iterative_solvers.jl#L49-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.perturb!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}" href="#WavesAndEigenvalues.NLEVP.perturb!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}"><code>WavesAndEigenvalues.NLEVP.perturb!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perturb!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; &lt;keyword arguments&gt;)</code></pre><p>Compute the <code>N</code>th order power series perturbation coefficients for the solution <code>sol</code> of the nonlineaer eigenvalue problem given by the operator family <code>L</code> with respect to the parameter <code>param</code>. The coefficients will be stored in the field <code>sol.eigval_pert</code> and <code>sol.v_pert</code> for the eigenvalue and the eignevector, respectively.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>mode = :compact</code>: parameter controlling internal programm flow. Use the default, unless you know what you are doing.</li></ul><p><strong>Notes</strong></p><p>For large perturbation orders <code>N</code> the method might be slow.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.perturb_fast!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}"><code>perturb_fast!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L519-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.perturb_fast!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}" href="#WavesAndEigenvalues.NLEVP.perturb_fast!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}"><code>WavesAndEigenvalues.NLEVP.perturb_fast!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perturb_fast!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; &lt;keyword arguments&gt;)</code></pre><p>Compute the <code>N</code>th order power series perturbation coefficients for the solution <code>sol</code> of the nonlineaer eigenvalue problem given by the operator family <code>L</code> with respect to the parameter <code>param</code>. The coefficients will be stored in the field <code>sol.eigval_pert</code> and <code>sol.v_pert</code> for the eigenvalue and the eignevector, respectively.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>mode = :compact</code>: parameter controlling internal programm flow. Use the default, unless you know what you are doing.</li></ul><p><strong>Notes</strong></p><p>This method reads multi-indeces for the computation of the power series coefficients from disk. Make sure that JulHoltz is properly installed to use this fast method.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.perturb!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}"><code>perturb!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L548-L560">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.perturb_norm!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}" href="#WavesAndEigenvalues.NLEVP.perturb_norm!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}"><code>WavesAndEigenvalues.NLEVP.perturb_norm!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>perturb_norm!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; &lt;keyword arguments&gt;)</p><p>Compute the <code>N</code>th order power series perturbation coefficients for the solution <code>sol</code> of the nonlineaer eigenvalue problem given by the operator family <code>L</code> with respect to the parameter <code>param</code>. The coefficients will be stored in the field <code>sol.eigval_pert</code> and <code>sol.v_pert</code> for the eigenvalue and the eignevector, respectively.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>mode = :compact</code>: parameter controlling internal programm flow. Use the default, unless you know what you are doing.</li></ul><p><strong>Notes</strong></p><p>This method reads multi-indeces for the computation of the power series coefficients from disk. Make sure that JulHoltz is properly installed to use this fast method.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.perturb!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}"><code>perturb!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L577-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.pos_test-Tuple{Any,Any,Any}" href="#WavesAndEigenvalues.NLEVP.pos_test-Tuple{Any,Any,Any}"><code>WavesAndEigenvalues.NLEVP.pos_test</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Ω,P=pos_test(Ω,P,Γ)</code></pre><p>Filter eigenpairs <code>Ω</code> and <code>P</code>for those whose eigenvalues lie inside <code>Γ</code>.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.moments2eigs-Tuple{Any}"><code>moments2eigs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/beyn.jl#L326-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.rf2s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sol,n,flag = rf2s(L,z;maxiter=10,tol=0., relax=1., x0=[],y0=[], output=true)</code></pre><p>Deploy two sided Rayleigh-functional iteration for finding an eigentriple of <code>L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code>: Definition of the nonlinear eigenvalue problem.</li><li><code>z</code>: Initial guess for the eigenvalue.</li><li><code>maxiter::Integer=10</code>: Maximum number of iterations.</li><li><code>tol=0</code>: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is <code>abs(z0-z1)&lt;tol</code> the iteration is aborted.</li><li><code>relax=1</code>: relaxation parameter</li><li><code>x0::Vector</code>: initial guess for right eigenvector. If not provided it is the first basis vector <code>[1 0 0 0 ...]</code>.</li><li><code>y0::Vector</code>: initial guess for left eigenvector. If not provided it is the first basis vector `[1 0 0 0 ...].</li><li><code>output::Bool</code>: Toggle printing online information.</li></ul><p><strong>Returns</strong></p><ul><li><code>sol::Solution</code></li><li><code>n::Integer</code>: Number of perforemed iterations</li><li><code>flag::Integer</code>: flag reporting the success of the method. Most important values are <code>1</code>: method converged, <code>0</code>: convergence might be slow, <code>-1</code>:maximum number of iteration has been reached. For other error codes see the source code.</li></ul><p><strong>Notes</strong></p><p>The algorithm is known to have a cubic convergence rate. Its implementation follows Algorithm 4.9 in [1].</p><p><strong>References</strong></p><p>[1] S. Güttel and F. Tisseur, The Nonlinear Eigenvalue Problem, 2017, http://eprints.ma.man.ac.uk/2531/.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>beyn</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}"><code>inveriter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}"><code>lancaster</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}"><code>mslp</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}"><code>traceiter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.decode_error_flag-Tuple{Int64}"><code>decode_error_flag</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/iterative_solvers.jl#L520-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.save-Tuple{Any,WavesAndEigenvalues.NLEVP.LinearOperatorFamily}" href="#WavesAndEigenvalues.NLEVP.save-Tuple{Any,WavesAndEigenvalues.NLEVP.LinearOperatorFamily}"><code>WavesAndEigenvalues.NLEVP.save</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save(fname::String,L::LinearOperatorFamily)</code></pre><p>Save <code>L</code> to file <code>fname</code>. The file is utf8 encoded and adheres to a Julia-enriched TOML standard.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.LinearOperatorFamily"><code>LinearOperatorFamily</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.solve-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}" href="#WavesAndEigenvalues.NLEVP.solve-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>WavesAndEigenvalues.NLEVP.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve(L,Γ;&lt;keywordarguments&gt;)</code></pre><p>Find eigenvalues of linear operator family <code>L</code> inside contour <code>Γ</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code>: Linear operator family for which eigenvalues are to be found</li><li><code>Γ::List</code>: List of complex points defining the contour.</li></ul><p><strong>Keywordarguments (optional)</strong></p><ul><li><code>Δl::Int=1</code>: Increment to the search space dimension in Beyn&#39;s algorithm</li><li><code>N::Int=16</code>: Number of integration points per edge of <code>Γ</code>.</li><li><code>tol::Float=1E-8</code>: Tolerance for local eigenvalue solver.</li><li><code>eigvals::Dict=Dict()</code>: Dictionary of known eigenvalues and corresponding eigenvectors.</li><li><code>maxcycles::Int=1</code>: Number of local correction cycles to global eigenvalue estimate.</li><li><code>nev::Int=1</code>: Number of tested eigenvalues for finding the best local match to the global estimates.</li><li><code>max_outer_cycles::Int=1</code>: Number of outer cycles, i.e., incremental increases to the search space dimension by <code>Δl</code>.</li><li><code>atol_σ::Float=1E-12</code>: absolute tolerance for terminating the inner cycle if the maximum singular value is <code>σ&lt;atol_σ</code>`</li><li><code>rtol_σ::Float=1E-8</code>: relative tolerance for terminating the inner cycle if the the ratio of the initial and the current maximum singular value is <code>σ/σ0&lt;rtol_σ</code></li><li><code>loglevel::Int=0</code>: loglevel value between 0 (no output) and 2 (max output) to control the detail of printed output.</li></ul><p><strong>Returns</strong></p><ul><li><code>eigvals::Dict</code>:List of computed eigenvalues and corresponding eigenvectors.</li></ul><p><strong>Notes</strong></p><p>The algorithm is experimental. It startes with a low-dimensional Beyn integral. From which estimates to the eigenvalues are computed. These estimates are used to analytically correct Beyn&#39;s integral. This step requires no additional numerical integration and is therefore relatively quick. New local estimates are computed and if the local solver then found new eigenvalues these are used to further correct Beyn&#39;s integral. In an optional outer loop the entire procedure can be repeated, after increasing the search space dimension.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.householder-Tuple{Any,Any}"><code>householder</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>beyn</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/solver.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.traceiter-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.traceiter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sol,n,flag = traceiter(L,z;maxiter=10,tol=0.,relax=1.,output=true)</code></pre><p>Deploy trace iteration for finding an eigevalue of <code>L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>L::LinearOperatorFamily</code>: Definition of the nonlinear eigenvalue problem.</li><li><code>z</code>: Initial guess for the eigenvalue.</li><li><code>maxiter::Integer=10</code>: Maximum number of iterations.</li><li><code>tol=0</code>: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is <code>abs(z0-z1)&lt;tol</code> the iteration is aborted.</li><li><code>relax=1</code>: relaxation parameter</li><li><code>output::Bool</code>: Toggle printing online information.</li></ul><p><strong>Returns</strong></p><ul><li><code>sol::Solution</code></li><li><code>n::Integer</code>: Number of perforemed iterations</li><li><code>flag::Integer</code>: flag reporting the success of the method. Most important values are <code>1</code>: method converged, <code>0</code>: convergence might be slow, <code>-1</code>:maximum number of iteration has been reached. For other error codes see the source code.</li></ul><p><strong>Notes</strong></p><p>The algorithm applies Newton-Raphson iteration for finding the root of the determinant. The updates for the iterates are computed by using trace operations and  Jacobi&#39;s formula [1]. The trace operation renders the method slow and inaccurate for medium and large problems.</p><p><strong>References</strong></p><p>[1] S. Güttel and F. Tisseur, The Nonlinear Eigenvalue Problem, 2017, http://eprints.ma.man.ac.uk/2531/.</p><p>See also: <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>beyn</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.inveriter-Tuple{Any,Any}"><code>inveriter</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.lancaster-Tuple{Any,Any}"><code>lancaster</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.mslp-Tuple{Any,Any}"><code>mslp</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.rf2s-Tuple{Any,Any}"><code>rf2s</code></a>, <a href="NLEVP.html#WavesAndEigenvalues.NLEVP.decode_error_flag-Tuple{Int64}"><code>decode_error_flag</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/iterative_solvers.jl#L437-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.wn-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.wn-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.wn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">w=wn(z,Γ)</code></pre><p>Compute winding number, i.e., how often <code>Γ</code> is wrapped around <code>z</code>. The sign of the winding number indocates the wrapping direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/beyn.jl#L180-L184">source</a></section></article><h2 id="Private-functionality:"><a class="docs-heading-anchor" href="#Private-functionality:">Private functionality:</a><a id="Private-functionality:-1"></a><a class="docs-heading-anchor-permalink" href="#Private-functionality:" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.initialize_V-Tuple{Int64,Int64}" href="#WavesAndEigenvalues.NLEVP.initialize_V-Tuple{Int64,Int64}"><code>WavesAndEigenvalues.NLEVP.initialize_V</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">V=initialize_V(d::Int,l::Int,random::Bool=false)</code></pre><p>initialioze matrix with <code>d</code>rows and <code>l</code> colums either as diagonal matrix featuring ones on the main diagonal and anywhere else or with random entries (<code>random</code>=true).</p><p>See also: <a href="@ref"><code>generate_subspace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/beyn.jl#L370-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.polyval-Tuple{Any,Any}" href="#WavesAndEigenvalues.NLEVP.polyval-Tuple{Any,Any}"><code>WavesAndEigenvalues.NLEVP.polyval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f=polyval(p,z)</code></pre><p>Evaluate polynomial f(z)=∑_i p[i]z^1 at z, using Horner&#39;s scheme.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/LinOpFam.jl#L697-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.project-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}" href="#WavesAndEigenvalues.NLEVP.project-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}"><code>WavesAndEigenvalues.NLEVP.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">P::LinearOperatorFamily=project(L::LinearOperatorFamily,Q)</code></pre><p>Project <code>L</code> on the subspace spanned by the unitary matrix <code>Q</code>, i.e. <code>P(z)=Q&#39;*L(z)*Q</code>.</p><p>See also: <a href="@ref"><code>generate_subspace</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/beyn.jl#L564-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.NLEVP.read_toml-Tuple{Any}" href="#WavesAndEigenvalues.NLEVP.read_toml-Tuple{Any}"><code>WavesAndEigenvalues.NLEVP.read_toml</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is a minimal TOML parser. See https://en.wikipedia.org/wiki/TOML</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/58dc707f15c4e2b4dc3cde0a23ef3d2d25c806fd/src/NLEVP/toml.jl#L9">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="tutorial_08_custom_FTF.html">« Tutorial 08 Custom FTF</a><a class="docs-footer-nextpage" href="Meshutils.html">The Meshutils module »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 1 April 2021 18:33">Thursday 1 April 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
