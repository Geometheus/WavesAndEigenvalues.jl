<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial 00 Introduction to the NLEVP module · WavesAndEigenvalues.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavesAndEigenvalues.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="installation.html">Install</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href="tutorial_00_NLEVP.html">Tutorial 00 Introduction to the NLEVP module</a><ul class="internal"><li><a class="tocitem" href="#Setting-up-a-NLEVP"><span>Setting up a NLEVP</span></a></li><li><a class="tocitem" href="#Iterative-eigenvalue-solvers"><span>Iterative eigenvalue solvers</span></a></li><li><a class="tocitem" href="#Beyn&#39;s-integration-based-solver"><span>Beyn&#39;s integration-based solver</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li><li class="toplevel"><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li><li><a class="tocitem" href="tutorial_02_global_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s Global Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_03_local_eigenvalue_solver.html">Tutorial 03  A Local Eigenvalue Solver</a></li><li><a class="tocitem" href="tutorial_04_perturbation_theory.html">Tutorial 04 Perturbation Theory</a></li><li><a class="tocitem" href="tutorial_05_mesh_refinement.html">Tutorial 05 Mesh Refinement</a></li><li><a class="tocitem" href="tutorial_06_second_order_elements.html">Tutorial 06 Second Order Elements</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="NLEVP.html">The NLEVP module</a></li><li><a class="tocitem" href="Meshutils.html">The Meshutils module</a></li><li><a class="tocitem" href="Helmholtz.html">The Helmholtz module</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="tutorial_00_NLEVP.html">Tutorial 00 Introduction to the NLEVP module</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tutorial_00_NLEVP.html">Tutorial 00 Introduction to the NLEVP module</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-00-Introduction-to-the-NLEVP-module"><a class="docs-heading-anchor" href="#Tutorial-00-Introduction-to-the-NLEVP-module">Tutorial 00 Introduction to the NLEVP module</a><a id="Tutorial-00-Introduction-to-the-NLEVP-module-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial-00-Introduction-to-the-NLEVP-module" title="Permalink"></a></h1><p>This tutorial briefly introduces you to the NLEVP module. NLEVP is an abbreviation for nonlinear eigenvalue problem. This is the problem <code>T(λ)v=0</code> where T is some matrix family the scalar <code>λ</code> and the vector <code>v</code> form an eigenpair. Often also the left eigenvector <code>w</code> for the corresponding problem <code>T&#39;(λ)w=0</code> is also sought. Clearly, NLEVPs are a generalization of classic (linear) eigenvalue problems they would read <code>T(λ)=A-λI</code> or <code>T(λ)=A-λB</code>. For the reminder of the tutorial it is assumed, that the reader is somewhat familiar with NLEVPs and we refer to the very nice review [1] for a detailed introduction.</p><h2 id="Setting-up-a-NLEVP"><a class="docs-heading-anchor" href="#Setting-up-a-NLEVP">Setting up a NLEVP</a><a id="Setting-up-a-NLEVP-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-up-a-NLEVP" title="Permalink"></a></h2><p>The NLEVP lets you define NLEVPs and provides you with tools for finding accurate as well as perturbative solutions. The <code>using</code> statement brings all necessary tools into scope:</p><pre><code class="language-julia">using WavesAndEigenvalues.NLEVP</code></pre><p>Let&#39;s consider the quadratic eigenvalue problem  1 from the collection of NLEVPs [2]. It reads <code>T(λ)= λ^2*A2 + λ*A1 + A0</code> where</p><pre><code class="language-julia">A2=[0 6 0;
    0 6 0;
    0 0 1];

A1=[1 -6 0;
    2 -7 0;
    0  0 0];

A0=[1 0 0;
    0 1 0;
    0 0 1];</code></pre><p>We first need to instantiate an empty operator family.</p><pre><code class="language-julia">T=LinearOperatorFamily()</code></pre><pre class="documenter-example-output">empty operator family



Parameters
----------
λ	NaN + NaN*im
</pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Per default the LinearOperatorFamily uses <code>:λ</code> as the symbol for the eigenvalue. You can customize this behavior by calling the constructor with additional parameters, e.g. <code>T=LinearOperatorFamily([:ω])</code>, would make the eigenvalue name <code>:ω</code>. It is also possible to change the eigenvalue after construction.</p></div></div><p>The next step is to create the three terms and add them to the matrix family. A term is created from the syntax <code>Term(M,func,args,txt,mat)</code>, where <code>M</code> is the matrix of the term, <code>func</code> is a list of scalar (possibly multi-variate) functions multiplying, <code>args</code>, is a list of lists containing the symbols of the arguments to the functions, and <code>mat</code> is the character string representing the matrix.</p><p>Ok, let&#39;s create the first term:</p><pre><code class="language-julia">term=Term(A2,(pow2,),((:λ,),),&quot;A2&quot;)</code></pre><pre class="documenter-example-output">λ^2*A2</pre><p>Note, that the function <code>pow2</code> is provided by the NLEVP module. It computes the square of its input, i.e. pow2(3)==9. However, it has an optional second parameter indicating a derivative order. For instance, <code>pow2(3,1)=6</code> because the first derivative of the square function at <code>3</code> is <code>2*3==6</code>. This feature is, important because many algorithms in the NLEVP module will need to compute derivatives. You can write your own coefficient-functions, but make sure that they provide at least the first derivative correctly. This will be further explained in the next tutorials.</p><p>Now, let&#39;s add the term to our family.</p><pre><code class="language-julia">T+=term</code></pre><pre class="documenter-example-output">3×3-dimensional operator family: 

λ^2*A2

Parameters
----------
λ	NaN + NaN*im
</pre><p>It worked! The family is not empty anymore.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>There is also the syntax <code>push!(T,term)</code> to add a term. It is actually more efficient because unlike the <code>+</code>-operator it does not create a temporary copy of <code>T</code>. However, it doesn&#39;t really matter for small problems like this example and we therefore prefer the <code>+</code>-operator for readability.</p></div></div><p>Let&#39;s also add the other two terms.</p><pre><code class="language-julia">T+=Term(A1,(pow1,),((:λ,),),&quot;A1&quot;)
T+=Term(A0,(),(),&quot;A0&quot;)</code></pre><pre class="documenter-example-output">3×3-dimensional operator family: 

λ^2*A2+λ*A1+A0

Parameters
----------
λ	NaN + NaN*im
</pre><p>Note that functions and arguments are empty in the last term because there is no coefficient function.</p><p>The family is now a complete representation of our problem</p><p>It is quite powerful. For instance, we can evaluate it at some point in the complex plane, say 3+2im:</p><pre><code class="language-julia">T(3+2im)</code></pre><pre class="documenter-example-output">3×3 Array{Complex{Float64},2}:
 4.0+2.0im  12.0+60.0im  0.0+0.0im
 6.0+4.0im  10.0+58.0im  0.0+0.0im
 0.0+0.0im   0.0+0.0im   6.0+12.0im</pre><p>We can even take its derivatives. For instance, the second derivative at the same point is</p><pre><code class="language-julia">T(3+2im,2)</code></pre><pre class="documenter-example-output">3×3 Array{Complex{Float64},2}:
 0.0+0.0im  12.0+0.0im  0.0+0.0im
 0.0+0.0im  12.0+0.0im  0.0+0.0im
 0.0+0.0im   0.0+0.0im  2.0+0.0im</pre><p>This syntax comes in handy when writing algorithms for the solution of the NLEVPs. However, the casual user will appreciate it when computing residuals.</p><h2 id="Iterative-eigenvalue-solvers"><a class="docs-heading-anchor" href="#Iterative-eigenvalue-solvers">Iterative eigenvalue solvers</a><a id="Iterative-eigenvalue-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-eigenvalue-solvers" title="Permalink"></a></h2><p>The NLEVP module provides various solvers for computing eigensolution. They essentially fall into two categories, <em>iterative</em> and <em>integration-based</em>. We will start the discussion with iterative solvers.</p><h3 id="method-of-successive-linear-problems"><a class="docs-heading-anchor" href="#method-of-successive-linear-problems">method of successive linear problems</a><a id="method-of-successive-linear-problems-1"></a><a class="docs-heading-anchor-permalink" href="#method-of-successive-linear-problems" title="Permalink"></a></h3><p>The method of successive linear problems is a robust iterative solver. Like all iterative solvers it tries finding an eigensolution from an initial guess. We will also set the <code>output</code> keyword to true, in order to see a bit what is going on behind the scenes. The function will return a solution <code>sol</code> of type <code>Solution</code>, as well as the number of iterations <code>n</code> run and an error flag <code>flag</code>.</p><pre><code class="language-julia">sol,n,flag=mslp(T,0,output=true);</code></pre><pre class="documenter-example-output">Launching MSLP solver...
Iter   dz:     z:
----------------------------------
0			Inf	0.0
1			0.2244912580419433	0.22273442990521633 - 0.028030317016627757im
2			0.08113409593058926	0.30216262377056435 - 0.011480285543462757im
3			0.02860118738428652	0.32939242223203097 - 0.002730085800657981im
4			0.0046842455090523065	0.33328324995273617 - 0.00012171166398420663im
5			0.00013157371980365514	0.33333340701442604 - 7.321239257681721e-8im
6			1.0386995389690534e-7	0.33333333333333337 + 6.473248625374385e-14im
7			6.473286708000606e-14	0.33333333333333315 - 1.5146129380243427e-28im
8			6.661338147750939e-16	0.3333333333333338 - 5.542625746548784e-32im
9			6.661338147750939e-16	0.33333333333333315 + 2.0426577352300165e-31im
10		6.661338147750942e-16	6.661338147750939e-16	0.3333333333333338 + 9.061877261010312e-32im
Warning: Maximum number of iterations has been reached!
...finished MSLP!
#####################
 Results
#####################
Number of steps: 10
Last step parameter variation:6.661338147750939e-16
Auxiliary eigenvalue __aux__ residual (rhs):6.661338147750942e-16
Eigenvalue:0.3333333333333338 + 9.061877261010312e-32im</pre><p>The printed output tells us that the algorithm found 1/3 is an eigenvalue of the problem. It has run for 10 iterations. However, it issued a warning that the maximum number of iterations has been reached. That is why the result comes with a non-zero flag, which says that something might be wrong. In general negative flag values represent errors, while positive values indicate warnings. In the current case the flag is <code>1</code>, so this is a warning. Therefore, the result can be true, but there is something we should be aware of.  Let&#39;s decode the error flag into something more readable.</p><pre><code class="language-julia">msg = decode_error_flag(flag)
println(msg)</code></pre><pre class="documenter-example-output">Warning: Maximum number of iterations has been reached!</pre><p>As we already knew, the iteration aborted because the maximum number of iterations (10) has been performed. You can change the maximum number of iterations from its default value by using the <code>maxiter</code> keyword. However, this won&#39;t fix the problem because the iteration will run until a certain tolerance is met or the maximum number of iteration is reached. Per default the tolerance is 0, and therefore due to machine-precision very unlikely to be precisely met. Indeed, we see from the printed output, above that the eigenvalue is not significantly changing anymore after 6 iterations. Let&#39;s redo the calculations, with a small but non-zero tolerance by setting the optional <code>tol</code> keyword.</p><pre><code class="language-julia">sol,n,flag=mslp(T,0,tol=1E-10,output=true);</code></pre><pre class="documenter-example-output">Launching MSLP solver...
Iter   dz:     z:
----------------------------------
0			Inf	0.0
1			0.284018050337417	0.24979553486303527 - 0.1351608067449942im
2			0.10520884204980731	0.32066640466029117 - 0.05740336170182356im
3			0.049479473262032156	0.3420236602194058 - 0.01277057208173793im
4			0.016164641536925036	0.33415035886164174 + 0.0013470325928204695im
5			0.001583086022207333	0.3333404990865899 - 1.3220508062320065e-5im
6			1.5038261058671961e-5	0.3333333340741803 + 1.1367990042030347e-9im
7			1.3568956693417812e-9	0.3333333333333336 - 1.0106325013303697e-17im
8		1.0106325013303658e-17	1.0106325013303702e-17	0.3333333333333336 + 4.622231866529366e-33im
Solution has converged!
...finished MSLP!
#####################
 Results
#####################
Number of steps: 8
Last step parameter variation:1.0106325013303702e-17
Auxiliary eigenvalue __aux__ residual (rhs):1.0106325013303658e-17
Eigenvalue:0.3333333333333336 + 4.622231866529366e-33im</pre><p>Boom! The iteration stops after 6 iterations and indicates that an eigenvalue has been found.</p><p>We may also inspect the corresponding left and right eigenvector. They are fields in the solution object:</p><pre><code class="language-julia">println(sol.v)
println(sol.v_adj)</code></pre><pre class="documenter-example-output">Complex{Float64}[0.6830291821096514 + 0.18295118580271838im, 0.6830291821096514 + 0.18295118580271838im, 1.0035013047802273e-41 - 5.017510629267731e-42im]
Complex{Float64}[1.3660583642193094 + 0.3659023716054385im, -2.732116728438617 - 0.7318047432108765im, 1.1199669561868777e-51 - 3.753961872786972e-52im]</pre><p>There are more iterative solvers. Not all of them solve the complete problem. Some only return the eigenvalue and the right eigenvector others even just the eigenvalue. (If the authors of this software get more funding this might be improved in the future...)</p><p>Let&#39;s briefly test them all...</p><h3 id="inverse-iteration"><a class="docs-heading-anchor" href="#inverse-iteration">inverse iteration</a><a id="inverse-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#inverse-iteration" title="Permalink"></a></h3><p>This algorithm finds an eigenvalue and a corresponding right eigenvector</p><pre><code class="language-julia">sol,n,flag=inveriter(T, 0, tol=1E-10, output=true);</code></pre><pre class="documenter-example-output">Launching inverse iteration...
0		Inf	0
1		0.30000000000000004	0.30000000000000004 + 0.0im
2		0.028571428571428137	0.3285714285714282 + 0.0im
3		0.00463320463320499	0.33320463320463317 + 0.0im
4		0.00012860089961053145	0.3333332341042437 + 0.0im
5		9.922903054793153e-8	0.33333333333327425 + 0.0im
6		5.950795411990839e-14	0.33333333333333376 + 0.0im
Solution has converged!</pre><h3 id="trace-iteration"><a class="docs-heading-anchor" href="#trace-iteration">trace iteration</a><a id="trace-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#trace-iteration" title="Permalink"></a></h3><p>This algorithm only finds an eigenvalue</p><pre><code class="language-julia">sol,n,flag=traceiter(T, 0, tol=1E-10, output=true);</code></pre><pre class="documenter-example-output">Launching trace iteration...
0		Inf	0
1		0.16666666666666666	0.16666666666666666 + 0.0im
2		0.10125889436234267	0.26792556102900933 + 0.0im
3		0.04886705474089864	0.31679261576990797 + 0.0im
4		0.014969376489607611	0.3317619922595156 + 0.0im
5		0.0015546254085949673	0.33331661766811055 + 0.0im
6		1.6713737663487382e-5	0.33333333140577404 + 0.0im
7		1.927559389880429e-9	0.3333333333333334 + 0.0im
8		2.220446049250313e-16	0.3333333333333332 + 0.0im
Solution has converged!</pre><h3 id="Lancaster&#39;s-generalized-Rayleigh-quotient-iteration"><a class="docs-heading-anchor" href="#Lancaster&#39;s-generalized-Rayleigh-quotient-iteration">Lancaster&#39;s generalized Rayleigh quotient iteration</a><a id="Lancaster&#39;s-generalized-Rayleigh-quotient-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Lancaster&#39;s-generalized-Rayleigh-quotient-iteration" title="Permalink"></a></h3><p>This algorithm only finds an eigenvalue</p><pre><code class="language-julia">sol,n,flag=lancaster(T, 0, tol=1E-10, output=true);</code></pre><pre class="documenter-example-output">Launching Lancaster&#39;s Rayleigh-quotient iteration...
0		Inf	0
1		0.30000000000000004	0.30000000000000004 + 0.0im
2		0.029104073704340316	0.32910407370434036 + 0.0im
3		0.004135217444984907	0.33323929114932527 + 0.0im
4		9.399316044850226e-5	0.33333328430977377 + 0.0im
5		4.902354600044845e-8	0.33333333333331977 + 0.0im
6		1.354472090042691e-14	0.3333333333333333 + 0.0im
Solution has converged!</pre><h3 id="two-sided-Rayleigh-functional-iteration"><a class="docs-heading-anchor" href="#two-sided-Rayleigh-functional-iteration">two-sided Rayleigh-functional iteration</a><a id="two-sided-Rayleigh-functional-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#two-sided-Rayleigh-functional-iteration" title="Permalink"></a></h3><p>This algorithm finds a complete eigentriple.</p><pre><code class="language-julia">sol,n,flag=rf2s(T, 0, tol=1E-10, output=true);</code></pre><pre class="documenter-example-output">Launching two-sided Rayleigh functional iteration...
0		Inf	0
1		0.23434529628710668	0.23434529628710668 - 0.0im
2		0.09576672895627122	0.3301120252433779 - 0.0im
3		0.0032212122529545195	0.3333332374963324 - 0.0im
4		9.583700116833072e-8	0.3333333333333336 - 0.0im
5		NaN	NaN + NaN*im
Warning: computer arithmetics problem. Eigenvalue is NaN</pre><p>Oops, this last test produced a NaN value. The problem often occurs when the eigenvalue and one point in the iteration is too precise. (See how in the last-but-one iteration we&#39;ve been already damn close to 1/3). Choosing a slightly different initial guess often leverages the problem:</p><pre><code class="language-julia">sol,n,flag=rf2s(T, 0, tol=1E-10, output=true);</code></pre><pre class="documenter-example-output">Launching two-sided Rayleigh functional iteration...
0		Inf	0
1		0.23434529628710668	0.23434529628710668 - 0.0im
2		0.09576672895627122	0.3301120252433779 - 0.0im
3		0.0032212122529545195	0.3333332374963324 - 0.0im
4		9.583700116833072e-8	0.3333333333333336 - 0.0im
5		NaN	NaN + NaN*im
Warning: computer arithmetics problem. Eigenvalue is NaN</pre><h2 id="Beyn&#39;s-integration-based-solver"><a class="docs-heading-anchor" href="#Beyn&#39;s-integration-based-solver">Beyn&#39;s integration-based solver</a><a id="Beyn&#39;s-integration-based-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Beyn&#39;s-integration-based-solver" title="Permalink"></a></h2><p>Iterative solvers are highly accurate and do not need many resources. However, they only find one eigenvalue at the time and heavily depend on the initial guess. This is a problem because NLEVPs have many eigenvalues. (Indeed, some have infinitely many!) This is where integration-based solvers enter the stage. They can find all eigenvalue enclosed by a contour in the complex plane. Several such algorithm exist. The NLEVP module implements the one of Beyn <a href="both of its variants!">3</a>. Any polygonal shape is supported as a contour (I am an engineer, so a polygon is any flat shape connecting three or more vertices with straight lines in a cyclic manner...).</p><p>Let&#39;s test Beyn&#39;s algorithm on our example problem by searching for all eigenvalues inside the axis-parallel square spanning from <code>-2-2im</code> to <code>2+2im</code>. The vertices of this contour are:</p><pre><code class="language-julia">Γ=[2+2im, -2+2im, -2-2im, +2-2im];</code></pre><p>It doesn&#39;t matter whether the contour is traversed in clockwise or counter-clockwise direction. However, the vertices should be traversed in a cyclic manner such that the contour is not criss-crossed (unless this is what you want to do, the algorithm correctly accounts for the winding number...)</p><p>Beyn&#39;s algorithm also needs an educated guess on how many eigenvalues you are expecting to find inside of the contour. If your guess is too high, this won&#39;t be a problem. You will find your eigenvalues but you&#39;ll waste computational resources and face an unnecessarily high run time. Nevertheless, if your guess is too small, weird things may happen and you probably will get wrong results. We will further discuss this point later. Now let&#39;s focus on the example problem. It is 3-dimensional and quadratic, we therefore know that it that it has 6 eigenvalues. Not all of them must lie in our contour, however this upper bound is a safe guess for our contour. We use the optional keyword <code>l=6</code> to pass this information to the algorithm. The call then is:</p><pre><code class="language-julia">Λ,V=beyn(T,Γ,l=6, output=true);</code></pre><pre class="documenter-example-output">Beyn...   2%|▄                             |  ETA: 0:00:45[KBeyn... 100%|██████████████████████████████| Time: 0:00:01[K
############
singular values:
[14.426760137347843, 6.283184515316615, 6.283184515316613, 3.429785123931821, 0.6821925100199041, 3.1888548929528184e-15]</pre><p>Note the printed information on singular values. One step in Beyn&#39;s algorithm leads to a singular value decomposition. Here, we got 6 singular values because we chose to run the algorithm with <code>l=6</code> option. In exact arithmetics There would be as many non-zero singular values as there are eigenvalues inside the contour, if the guess <code>l</code> is equal or greater than the number of eigenvalues. The output tells us that there are probably 5 eigenvalues inside the contour as there is only one singular value that can be considered equal to <code>0</code> given the machine precision. Indeed, the example solution is analytical solvable and it is known that it has 5 eigenvalues inside the square.</p><p>The return values <code>Λ</code> and <code>V</code> are the list of eigenvalues and corresponding (right) eigenvectors such that <code>T(Λ[i])*V[:,i]==0</code>. At least this is what it should be. Because the computation is carried out on a computer the eigenpairs won&#39;t evaluate to the zero vector but have some residual. We can use this as a quality check. The computation of the residual norms yields:</p><pre><code class="language-julia">for (idx,λ) in enumerate(Λ)
   v=V[:,idx]
   v/=sqrt(v&#39;*v)
   res=T(λ)*v
   println(&quot;λ=$λ residual norm: $(abs(sqrt(res&#39;*res)))&quot;)
end</code></pre><pre class="documenter-example-output">λ=-0.7475364389811163 - 0.45325436336718705im residual norm: 10.407145343650846
λ=-3.3306690738756856e-16 + 1.000000000000001im residual norm: 3.915476574515353e-15
λ=1.0838450249501201e-16 - 1.000000000000001im residual norm: 2.8609553533972574e-15
λ=0.33333333333333137 - 2.3509368740489103e-15im residual norm: 4.712672036660595e-15
λ=0.4999999999999981 + 2.528807404493626e-15im residual norm: 4.392620132872224e-15
λ=1.0000000000000022 + 5.825418272764615e-16im residual norm: 9.268179900429887e-15</pre><p>We clearly see that out of the 6 eigenvalues 5 have extremely low residuals. The eigenvalue with the high residual is actually not an eigenvalue. This is inline with our consideration on the singular value. There is a keyword <code>sigma_tol</code> that you may provide to the call of the algorithm, in order to ignore singular values that are smaller then a user-specified threshold.# However, an appropriate threshold is problem-dependent and often it is a better strategy to feed the computed eigenvalues as initial guesses into an iterative solver.</p><p>Please, note that you could also compute the number of poles and zeros inside the contour from the residual theorem with the following command:</p><pre><code class="language-julia">number=count_poles_and_zeros(T,Γ)</code></pre><pre class="documenter-example-output">4.999999621784568 + 1.987846675914698e-17im</pre><p>The functions sums up the number of poles and zeros of the determinant of <code>T</code> inside your contour. Zeros are positively counted while poles count negatively when encircling the domain mathematically positive (counter-clockwise). Thus, the number should not be mistaken as an initial guess for <code>l</code>. Yet, often you have some knowledge about the properties of your problem. For instance the current example problem is polynomial an therefore is unlikely to have poles. That <code>number≈5</code> is a further indicator that there are, indeed, only 5 eigenvalues inside the square. Note, that <code>count_poles_and_zeros</code> uses Jacobi&#39;s formula to compute the necessary derivatives of the determinant by trace operations. The command is therefore reliable for small-sized problems only.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>The NLEVP module provides you with essential tools for setting up and solving non-linear eigenvalue problems. In particular, there is a bunch of solution algorithms available. There is more the module can do. All of the presented solvers have various optional keyword arguments for fine-tuning there behavior. For instance, just type <code>? mslp</code> in the REPL or use the documentation browser of your choice to learn more about the <code>mslp</code> command. Moreover, there is functionality for computing perturbation expansions of known solutions. These topics will be further discussed in the next tutorials.</p><h1 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h1><p>[1] S. Güttel and F. Tisseur, The Nonlinear Eigenvalue Problem, 2017, <a href="http://eprints.ma.man.ac.uk/2538/">http://eprints.ma.man.ac.uk/2538/</a></p><p>[2] T. Betcke, N. J. Higham, V. Mehrmann, C. Schröder and F. Tisseur, NLEVP: A Collection of Nonlinear Eigenvalue Problems, 2013, ACM Trans. Math. Soft., <a href="https://doi.org/10.1145/2427023.2427024">doi:10.1145/2427023.2427024</a></p><p>[3] W.-J. Beyn, An integral method for solving nonlinear eigenvalue problems, 2012, Lin. Alg. Appl., <a href="https://doi.org/10.1016/j.laa.2011.03.030">doi:10.1016/j.laa.2011.03.030</a></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="installation.html">« Install</a><a class="docs-footer-nextpage" href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 25 March 2021 13:29">Thursday 25 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
