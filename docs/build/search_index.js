var documenterSearchIndex = {"docs":
[{"location":"Helmholtz.html#Helmholtz-1","page":"Helmholtz","title":"Helmholtz","text":"","category":"section"},{"location":"Helmholtz.html#","page":"Helmholtz","title":"Helmholtz","text":"Modules = [WavesAndEigenvalues.Helmholtz]","category":"page"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz","text":"Module providing functionality to numerically discretize the (thermoacoustic) Helmholtz equation by first and second-order finite elements.\n\n\n\n\n\n","category":"module"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.discretize-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any,Any}","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.discretize","text":"L=discretize(mesh, dscrp, C; el_type=1, c_type=0, b=:__none__)\n\nDiscretize the Helmholtz equation using the mesh mesh.\n\nArguments\n\nmesh::Mesh: tetrahedral mesh\ndscrp::Dict: dictionary containing information on where to apply physical constraints. Such as standard wave propagation, boundary conditions, flame responses, etc.\nC:Array: array defining the speed of sound. If \"ctype==0\" the speed of sound is constant along one tetrahedron and length(C)==length(mesh.tetrahedra). If `ctype==1the speed of sound is linearly interpolated between the vertices of the mesh andlength(C)==size(mesh.points,2)`.\neltype = 1: optional paramater to select between first (eltype==1 the default) and second order (eltype==2) finite elements.\nc_type = 1: optional parameter controlling whether speed of sound is constant on a tetrahedron or linearly interpolated between vertices.\nb::Symbol=:__none__: optional parameter defining the Bloch wave number. If b=:__none__ (the default) noch Blochwave formalism is applied.\n\nReturns\n\nL::LinearOperatorFamily: parametereized discretization of the specified Helmholtz equation.\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#Discretization-Order-1","page":"Helmholtz","title":"Discretization Order","text":"","category":"section"},{"location":"Helmholtz.html#","page":"Helmholtz","title":"Helmholtz","text":"Modules = [\n  WavesAndEigenvalues.Helmholtz.lin,\n  WavesAndEigenvalues.Helmholtz.quad,\n  WavesAndEigenvalues.Helmholtz.quad20,\n]","category":"page"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.lin.assemble_boundary_mass_operator-Tuple{Any,Any,Any}","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.lin.assemble_boundary_mass_operator","text":"boundary mass operator for first order elements\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.lin.assemble_stiffness_operator-Tuple{Any,Any,Any}","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.lin.assemble_stiffness_operator","text":"stiffness operator for first order elements\n\n\n\n\n\n","category":"method"},{"location":"Helmholtz.html#WavesAndEigenvalues.Helmholtz.lin.assemble_volume_source-Tuple{Any,Any}","page":"Helmholtz","title":"WavesAndEigenvalues.Helmholtz.lin.assemble_volume_source","text":"volume source vector for first order elements\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#Mesh-1","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"Mesh.html#","page":"Mesh","title":"Mesh","text":"Modules = [WavesAndEigenvalues.Meshutils]","category":"page"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils","page":"Mesh","title":"WavesAndEigenvalues.Meshutils","text":"Module containing functionality to read and process tetrahedral meshes from gmsh.\n\n\n\n\n\n","category":"module"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.Mesh","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.Mesh","text":"Definition of the mesh type\n\nFields\n\nname::String: the name of the mesh.\npoints::Array: 3×N array containing the coordinates of the N points defining the mesh.\nlines::List: List of simplices defining the edges of the mesh\ntriangles::List: List of simplices defining the surface triangles of the mesh\ntetrahedra::List: List of simplices defining the tetrahedra of the mesh\ndomains::Dict: Dictionairy defining the domains of the mesh. See comments below.\nfile::String: path to the file containing the mesh.\ntri2tet::Array: Array of length length(tetrahedra) containing the indices of the connected tetrahedra.\ndos: special field meant to contain symmetry information of highly symmetric meshes.\n\nNotes\n\nThe meshes are supposed to be tetrahedral. All simplices (lines, triangles, and tetrahedra) are stored as list of simplices. Simplices are lists of integers containing the indices of the points (i.e. the column number in the points array) forming the simplex. This means a line is a two-entry list, a triangle a three-entry list, and a tetrahedron a four entry lists. For convenience certain entities of the mesh can be further defined in the domainsdictionary. Each key defines a domain and maps to another dictionary. This second-level dictionary contains at least two keys: \"dimension\" mapping to the dimension of the specified domain (1,2, or 3) and \"simplices\" containing a list of integers mapping into the respective simplex lists. More keys may be added to the dictionary to define additional and/or custom information on the domain. For instance the compute_volume! function adds an entry with the domain size.\n\n\n\n\n\n","category":"type"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.Mesh-Tuple{String}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.Mesh","text":"mesh=Mesh(file_name::String; scale=1)\n\nread a tetrahedral mesh from gmsh file into mesh. The optional scaling factor scale may be used to scale the units of the mesh.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.collect_lines!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.collect_lines!","text":"collect_lines!(mesh::Mesh)\n\nPopulate the list of lines in mesh.lines.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.compute_volume!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.compute_volume!","text":"compute_volume!(mesh::Mesh,dom::String)\n\nCompute the size of the domain dom and store it in the field \"size\" of the domain definition. The size will be a length, area, or volume depending on the dimension of the domain.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.create_full_mesh-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.create_full_mesh","text":"full_mesh=create_full_mesh(mesh::Mesh, doms; sym_name=\"Symmetry\", blch_name=\"Bloch\", unit=false)\n\nCreate full mesh from half cell represented in mesh.\n\nArguments\n\nmesh::Mesh: mesh representing the half cell. The mesh must span a sector of 2π/2N, where N is the (integer) degree of symmetry of the full mesh.\ndoms::List: list of 2-tuples containing the domain names and their copy_degree (see notes below).\nsym_name::String=\"Symmetry\": name of the domain of mesh that forms the symmetry plane of the half-mesh.\nblch_name::String=\"Bloch\": name of the domain of mesh that forms the remaining azimuthal plane of the half-mesh.\nunit::Bool=false: toggle whether extend the mesh to unit cell only.\n\nReturns\n\nfull_mesh::Mesh: representation of the full mesh.\n\nNotes\n\nThe routine copies only domains that are specified  in doms. These domains are extended according to the specified copy_degree. The following are available:\n\n:full: extent the domain and save it under the same name in full_mesh.\n:unit: extent the domain and save the individual unit cells labeled from 0 to N-1 in full_mesh.#\n:half: extent the domain and save the individual unit cells as half cells labeled from 0 to N-1 in fullmesh where one half-cell  contains `img` in its name.\n\nMultiple styles can be mixed in one domain specification. An example for doms would be     doms=[(\"Interior\", :full), (\"Outlet\", :unit), (\"Flame\", :half)]\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point","text":"tet_idx=find_tetrahedron_containing_point(mesh::Mesh,point)\n\nFind the tetrahedron containing the point point and return the index of the tetrahedron as tet_idx. If the point lies on the interface of two or more tetrahedra, the returned tet_idx will be the lowest index of these tetrahedra, i.e. the index depends on the ordering of the tetrahedra in the mesh.tetrahedra. If no tetrahedron in the mesh encloses the point tet_idx==0.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!","text":"link_triangles_to_tetrahedra!(mesh::Mesh)\n\nFind the tetrahedra that are connected to the triangles in mesh.triangles and store this information in mesh.tri2tet.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.unify!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String,Vararg{Any,N} where N}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.unify!","text":"unify!(mesh::Mesh ,new_domain::String,domains...)\n\nCreate union of domains and name it new_domain. domains must share the same dimension and new_domain must be a new name otherwise errors will occur.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.compare-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.compare","text":"cmpr=compare(A,B)\n\nCompare two simplices following lexicographic rules. If B has lower rank, then A cmpr ==-1. If B has higher rank than A, cmpr==1. If A and B are identical, cmpr==0.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis","text":"R = create_rotation_matrix_around_axis(n,α)\n\nCompute the rotation matrix around the directional vector nrotating by an angle α (in rad).\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular","text":"foot=find_foot_of_perpendicular(pnt,pln)\n\nCompute the position of the foot of the perpendicular from the point pnt to the plane pln.\n\n#Notes Code adapted from https://www.geeksforgeeks.org/mirror-of-a-point-through-a-3-d-plane/\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes","text":"p,n = find_intersection_of_two_planes(pln1,pln2)\n\nFind a parametrization of the axis defined by the intersection of the planes pln1and pln2. The axis is parameterized by a point p and direction n.\n\n#Notes The algorithm follows John Krumm's solution for finding a common point on two intersecting planes as it is explained in https://math.stackexchange.com/questions/475953/how-to-calculate-the-intersection-of-two-planes To simplify the code, here the point p0 is the origin.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.find_smplx-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.find_smplx","text":"idx = find_smplx(list,smplx)\n\nFind index of simplex in ordered list of simplices. If the simplex is not contained in the list, the returned index is nothing\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.insert_smplx!-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.insert_smplx!","text":"insert_smplx!(list,smplx)\n\nInsert simplex in ordered list of simplices.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.is_point_in_plane-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.is_point_in_plane","text":"check = is_point_in_plane(pnt, pln)\n\nCheck whether point \"pnt\" is in plane . Note that there is currently no handling of round off errors.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.make_normal_outwards!-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.make_normal_outwards!","text":"makenormaloutwards!(pln,testpoint)\n\nEnsure that the parameterization of the plane \"pln\" has a normal that is directed twoards testpoint. If necessary reparametrize pln.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.read_ansys-Tuple{Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.read_ansys","text":"read a mesh from ansys cfx file\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.read_msh2-Tuple{Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.read_msh2","text":"points, lines, triangles, tetrahedra, domains=read_msh2(file_name)\n\nRead gmsh's .msh-format version 2. This is an old format and wherever possible version 4 should be used.\n\nhttp://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.read_msh4-Tuple{Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.read_msh4","text":"points, lines, triangles, tetrahedra, domains=read_msh4(file_name)\n\nRead gmsh's .msh-format version 4.\n\nhttp://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.reflect_point_at_plane-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.reflect_point_at_plane","text":"p=reflect_point_at_plane(pnt,pln)\n\nReflect point pnt at plane pln and return as p.\n\n#Notes Code adapted from https://www.geeksforgeeks.org/mirror-of-a-point-through-a-3-d-plane/\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.sort_smplx-Tuple{Any,Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.sort_smplx","text":"sort_smplx(list,smplx)\n\nHelper function for sorting simplices in lexicographic manner. Utilize divide an conquer strategy to find a simplex in ordered list of simpleces.\n\n\n\n\n\n","category":"method"},{"location":"Mesh.html#WavesAndEigenvalues.Meshutils.three_points_to_plane-Tuple{Any}","page":"Mesh","title":"WavesAndEigenvalues.Meshutils.three_points_to_plane","text":"pln=three_points_to_plane(A)\n\nCompute equation for a plane from the three points defined in A. The plane is parameterized as a*x+b*y+c*z+d==0 with the coefficients returned as pln=[a,b,c,d].\n\n#Arguments\n\nA::3×3-Array : Array containing the three points defining the plane as columns.\n\n#Notes Code adapted from https://www.geeksforgeeks.org/program-to-find-equation-of-a-plane-passing-through-3-points/\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#NLEVP-1","page":"NLEVP","title":"NLEVP","text":"","category":"section"},{"location":"NLEVP.html#","page":"NLEVP","title":"NLEVP","text":"Modules = [WavesAndEigenvalues.NLEVP]","category":"page"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP","text":"Module containing routines to solve and perturb nonlinear eigenvalue problems.\n\n\n\n\n\n","category":"module"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.LinearOperatorFamily-Tuple{String}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.LinearOperatorFamily","text":"L=LinearOperatorFamily(fname::String)\n\nLoad and construct LinearOperatorFamily from file fname.\n\nSee also: save\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.beyn-Tuple{WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Any}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.beyn","text":"Ω, P = beyn(L::LinearOperatorFamily, Γ; <keyword arguments>)\n\nCompute all eigenvalues of L inside the contour Γ together with the associated eigenvectors. The contour is given as a list of complex numbers which are interpreted as polygon vertices in the complex plane.  The eigenvalues are stored in the list Ω and the eigenvectors are stored in the columns of P. The eigenvector P[:,i] corresponds to the eigenvalue Ω[i], i.e., they satisfy L(Ω[i])P[:,i]=0.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the non-linear eigenvalue problem\nΓ::Array: List of complex points defining the contour.\nl::Integer = 5: estimate of the number of eigenvalues inside of Γ.\nK::Integer = 1: Augmention dimension if Γ is assumed to contain more than size(L)[1] eigenvalues.\nN::Integer = 16: Number of evaluation points used to perform the Gauss-Legendre integration along each edge of Γ.\ntol::Float=0.0: Threshold value to discard spurious singular values. If set to 0 (the default) no singular values are discarded.\npos_test::bool=true: If set to true perform positions test on the computed eigenvalues, i.e., check whether the eigenvalues are enclosed by Γ and disregard all eigenvalues which fail the test.\noutput::bool=false: Show progressbar if true.\n\nReturns\n\nΩ::Array: List of computed eigenvalues\nP::Matrix: Matrix of eigenvectors.\n\nNotes\n\nThe original algorithm was first presented by Beyn in [1]. The implementation closely follows the pseudocode from Buschmann et al. in [2].\n\nReferences\n\n[1] W.-J. Beyn, An integral method for solving nonlinear eigenvalue problems, Linear Algebra and its Applications, 2012, 436(10), p.3839-3863, https://doi.org/10.1016/j.laa.2011.03.030\n\n[2] P.E. Buschmann, G.A. Mensah, J.P. Moeck, Solution of Thermoacoustic Eigenvalue Problems with a Non-Iterative Method, 2019, J. Eng. Gas Turbines Power, (accepted manuscript) https://doi.org/10.1115/1.4045076\n\nSee also: householder\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.householder-Tuple{Any,Any}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.householder","text":"sol::Solution, n, flag = householder(L::LinearOperatorFamily, z; <keyword arguments>)\n\nUse a Householder method to iteratively find an eigenpar of L, starting the the iteration from z.\n\nArguments\n\nL::LinearOperatorFamily: Definition of the nonlinear eigenvalue problem.\nz: Initial guess for the eigenvalue.\nmaxiter::Integer=10: Maximum number of iterations.\ntol=0: Absolute tolerance to trigger the stopping of the iteration. If the difference of two consecutive iterates is abs(z0-z1)<tol the iteration is aborted.\nrelax=1: relaxation parameter\nlam_tol=0.: tolerance for the auxiliary eigenvalue to test convergence\norder::Integer=1: Order of the Householder method, Maximum is 5\nn_eig_val::Integer=1: Number of Eigenvalues to be searched for in intermediate ARPACK calls.\nv0::Vector: Initial vector for Krylov subspace generation in ARPACK calls. If not provided the vector is initialized with ones.\noutput::Bool: Toggle printing online information.\n\nReturns\n\nsol::Solution\nn::Integer: Number of perforemed iterations\nflag::Integer: flag reporting the success of the method. Most important values are 1: method converged, 0: convergence might be slow, -1:maximum number of iteration has been reached. For other error codes see the source code.\n\nNotes\n\nHousholder methods are a generalization of Newton's method. If order=1 the Housholder method is identical to Newton's method. The solver then reduces to the \"generalized Rayleigh Quotient iteration\" presented in [1]. If no relaxation is used (relax == 1), the convergence rate is of order+1. With relaxation (relax != 1) the convergence rate is 1. Thus, with a higher order less iterations will be necessary. However, the computational time must not necessarily improve nor do the convergence properties. Anyway, if the method converges, the error in the eigenvalue is bounded above by tol. For more details on the solver, see the thesis [2].\n\nReferences\n\n[1] P. Lancaster, A Generalised Rayleigh Quotient Iteration for Lambda-Matrices,Arch. Rational Mech Anal., 1961, 8, p. 309-322, https://doi.org/10.1007/BF00277446\n\n[2] G.A. Mensah, Efficient Computation of Thermoacoustic Modes, Ph.D. Thesis, TU Berlin, 2019\n\nSee also: beyn\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.perturb!","text":"perturb!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nFor large perturbation orders N the method might be slow.\n\nSee also: perturb_fast!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb_fast!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.perturb_fast!","text":"perturb_fast!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nThis method reads multi-indeces for the computation of the power series coefficients from disk. Make sure that JulHoltz is properly installed to use this fast method.\n\nSee also: perturb!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.perturb_norm!-Tuple{WavesAndEigenvalues.NLEVP.Solution,WavesAndEigenvalues.NLEVP.LinearOperatorFamily,Symbol,Int64}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.perturb_norm!","text":"perturb_norm!(sol::Solution,L::LinearOperatorFamily,param::Symbol,N::Int; <keyword arguments>)\n\nCompute the Nth order power series perturbation coefficients for the solution sol of the nonlineaer eigenvalue problem given by the operator family L with respect to the parameter param. The coefficients will be stored in the field sol.eigval_pert and sol.v_pert for the eigenvalue and the eignevector, respectively.\n\nKeyword Arguments\n\nmode = :compact: parameter controlling internal programm flow. Use the default, unless you know what you are doing.\n\nNotes\n\nThis method reads multi-indeces for the computation of the power series coefficients from disk. Make sure that JulHoltz is properly installed to use this fast method.\n\nSee also: perturb!\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.save-Tuple{Any,WavesAndEigenvalues.NLEVP.LinearOperatorFamily}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.save","text":"save(fname::String,L::LinearOperatorFamily)\n\nSave L to file fname. The file is utf8 encoded and adheres to a Julia-enriched TOML standard.\n\nSee also: LinearOperatorFamily\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.polyval-Tuple{Any,Any}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.polyval","text":"`f=polyval(p,z)`\n\nEvaluate polynomial f(z)=∑_i p[i]z^1 at z, using Horner's scheme.\n\n\n\n\n\n","category":"method"},{"location":"NLEVP.html#WavesAndEigenvalues.NLEVP.read_toml-Tuple{Any}","page":"NLEVP","title":"WavesAndEigenvalues.NLEVP.read_toml","text":"This is a minimal TOML parser. See https://en.wikipedia.org/wiki/TOML\n\n\n\n\n\n","category":"method"},{"location":"index.html#WavesAndEigenvalues.jl-1","page":"Home","title":"WavesAndEigenvalues.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Documentation for WavesAndEigenvalues.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A package for building Finite Element Models of wave-based problems and solving the associated eigenvalue problems.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"note: Note\nThis Package is under development, we will add more features soon!","category":"page"},{"location":"index.html#Package-Features-1","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Load mesh files in .msh format, with surface and volumes labeled (see e.g. gmsh).\nSpecify the equations to be solved on each surface and volumes.\nBuild a paramteric depedent FEM sparse_matrix.\nCalculate eigenvalues of nonlinear eigenvalue problems (NLEVP).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The Manual documents the package modules and functionalities.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Examples on usage in the form of Jupyter Notebooks will be made available soon.","category":"page"},{"location":"index.html#Manual-Outline-1","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n        \"Mesh.md\",\n        \"Helmholtz.md\",\n        \"NLEVP.md\",\n]\nDepth = 1","category":"page"}]
}
