<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mesh · WavesAndEigenvalues</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavesAndEigenvalues</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Documentation</span><ul><li class="is-active"><a class="tocitem" href="Mesh.html">Mesh</a></li><li><a class="tocitem" href="Helmholtz.html">Helmholtz</a></li><li><a class="tocitem" href="NLEVP.html">NLEVP</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="load_mesh.html">How to load a mesh?</a></li><li><a class="tocitem" href="tutorial_01_rijke_tube.html">Tutorial 01 Rijke Tube</a></li><li><a class="tocitem" href="tutorial_02_gloabal_eigenvalue_solver.html">Tutorial 02 Beyn&#39;s global eigenvalue solver</a></li><li><a class="tocitem" href="tutorial_03_local_eigenvalue_solver.html">Tutorial 03 Lancaster&#39;s local eigenvalue solver</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Documentation</a></li><li class="is-active"><a href="Mesh.html">Mesh</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Mesh.html">Mesh</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/master/docs/src/Mesh.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Mesh-1"><a class="docs-heading-anchor" href="#Mesh-1">Mesh</a><a class="docs-heading-anchor-permalink" href="#Mesh-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils" href="#WavesAndEigenvalues.Meshutils"><code>WavesAndEigenvalues.Meshutils</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module containing functionality to read and process tetrahedral meshes from gmsh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.Mesh" href="#WavesAndEigenvalues.Meshutils.Mesh"><code>WavesAndEigenvalues.Meshutils.Mesh</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Definition of the mesh type</p><p><strong>Fields</strong></p><ul><li><code>name::String</code>: the name of the mesh.</li><li><code>points::Array</code>: 3×N array containing the coordinates of the N points defining the mesh.</li><li><code>lines::List</code>: List of simplices defining the edges of the mesh</li><li><code>triangles::List</code>: List of simplices defining the surface triangles of the mesh</li><li><code>tetrahedra::List</code>: List of simplices defining the tetrahedra of the mesh</li><li><code>domains::Dict</code>: Dictionairy defining the domains of the mesh. See comments below.</li><li><code>file::String</code>: path to the file containing the mesh.</li><li><code>tri2tet::Array</code>: Array of length <code>length(tetrahedra)</code> containing the indices of the connected tetrahedra.</li><li><code>dos</code>: special field meant to contain symmetry information of highly symmetric meshes.</li></ul><p><strong>Notes</strong></p><p>The meshes are supposed to be tetrahedral. All simplices (lines, triangles, and tetrahedra) are stored as lists of simplices. Simplices are lists of integers containing the indices of the points (i.e. the column number in the <code>points</code> array) forming the simplex. This means a line is a two-entry list, a triangle a three-entry list, and a tetrahedron a four-entry list. For convenience certain entities of the mesh can be further defined in the <code>domains</code> dictionary. Each key defines a domain and maps to another dictionary. This second-level dictionary contains at least two keys: <code>&quot;dimension&quot;</code> mapping to the dimension of the specified domain (1,2, or 3) and <code>&quot;simplices&quot;</code> containing a list of integers mapping into the respective simplex lists. More keys may be added to the dictionary to define additional and/or custom information on the domain. For instance the <code>compute_volume!</code> function adds an entry with the domain size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L47-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.Mesh-Tuple{String}" href="#WavesAndEigenvalues.Meshutils.Mesh-Tuple{String}"><code>WavesAndEigenvalues.Meshutils.Mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mesh=Mesh(file_name::String; scale=1)</code></pre><p>read a tetrahedral mesh from gmsh file into <code>mesh</code>. The optional scaling factor <code>scale</code> may be used to scale the units of the mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.collect_lines!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}" href="#WavesAndEigenvalues.Meshutils.collect_lines!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}"><code>WavesAndEigenvalues.Meshutils.collect_lines!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collect_lines!(mesh::Mesh)</code></pre><p>Populate the list of lines in <code>mesh.lines</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L571-L575">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.compute_volume!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String}" href="#WavesAndEigenvalues.Meshutils.compute_volume!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String}"><code>WavesAndEigenvalues.Meshutils.compute_volume!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_volume!(mesh::Mesh,dom::String)</code></pre><p>Compute the size of the domain <code>dom</code> and store it in the field <code>&quot;size&quot;</code> of the domain definition. The size will be a length, area, or volume depending on the dimension of the domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L496-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.extend_mesh-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}" href="#WavesAndEigenvalues.Meshutils.extend_mesh-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}"><code>WavesAndEigenvalues.Meshutils.extend_mesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">full_mesh=extend_mesh(mesh::Mesh, doms; sym_name=&quot;Symmetry&quot;, blch_name=&quot;Bloch&quot;, unit=false)</code></pre><p>Create full mesh or unit cell from half cell represented in <code>mesh</code>.</p><p><strong>Arguments</strong></p><ul><li><code>mesh::Mesh</code>: mesh representing the half cell. The mesh must span a sector of <code>2π/2N</code>, where <code>N</code> is the (integer) degree of symmetry of the full mesh.</li><li><code>doms::List</code>: list of 2-tuples containing the domain names and their <code>copy_degree</code> (see notes below).</li><li><code>sym_name::String=&quot;Symmetry&quot;</code>: name of the domain of <code>mesh</code> that forms the symmetry plane of the half-mesh.</li><li><code>blch_name::String=&quot;Bloch&quot;</code>: name of the domain of <code>mesh</code> that forms the remaining azimuthal plane of the half-mesh.</li><li><code>unit::Bool=false</code>: toggle whether extend the mesh to unit cell only.</li></ul><p><strong>Returns</strong></p><ul><li><code>full_mesh::Mesh</code>: representation of the full mesh.</li></ul><p><strong>Notes</strong></p><p>The routine copies only domains that are specified  in <code>doms</code>. These domains are extended according to the specified <code>copy_degree</code>. The following are available:</p><ul><li><code>:full</code>: extent the domain and save it under the same name in <code>full_mesh</code>.</li><li><code>:unit</code>: extent the domain and save the individual unit cells labeled from <code>0</code> to <code>N-1</code> in <code>full_mesh</code>.</li><li><code>:half</code>: extent the domain and save the individual unit cells as half cells labeled from <code>0</code> to <code>N-1</code> in <code>full_mesh</code> where one half-cell  contains <code>_img</code> in its name.</li></ul><p>Multiple styles can be mixed in one domain specification. An example for <code>doms</code> would be     doms=[(&quot;Interior&quot;, :full), (&quot;Outlet&quot;, :unit), (&quot;Flame&quot;, :half)]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L243-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}" href="#WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}"><code>WavesAndEigenvalues.Meshutils.find_tetrahedron_containing_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tet_idx=find_tetrahedron_containing_point(mesh::Mesh,point)</code></pre><p>Find the tetrahedron containing the point <code>point</code> and return the index of the tetrahedron as <code>tet_idx</code>. If the point lies on the interface of two or more tetrahedra, the returned <code>tet_idx</code> will be the lowest index of these tetrahedra, i.e. the index depends on the ordering of the tetrahedra in the <code>mesh.tetrahedra</code>. If no tetrahedron in the mesh encloses the point <code>tet_idx==0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L537-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.generate_field" href="#WavesAndEigenvalues.Meshutils.generate_field"><code>WavesAndEigenvalues.Meshutils.generate_field</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_field(mesh::Mesh,func,el_type=0)</code></pre><p>Generate field from function <code>func</code>for mesh <code>mesh</code>. The element type is either <code>el_type=0</code> for field values associated with the mesh tetrahedra or <code>el_type=1</code> for field values associated with the mesh vertices. The function must accept three input arguments corresponding to the three space dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L791-L798">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_normal_vectors" href="#WavesAndEigenvalues.Meshutils.get_normal_vectors"><code>WavesAndEigenvalues.Meshutils.get_normal_vectors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal_vectors=get_normal_vectors(mesh::Mesh,output::Bool=true)</code></pre><p>Compute a 3×<code>length(mesh.triangles)</code> Array containing the outward pointing normal vectors of each of the surface triangles of the mesh <code>mesh</code>. The vectors are not normalised but their norm is twice the area of the corresponding triangle. The optional parameter <code>output</code> toggles whether a progressbar should be shown or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L744-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_surface_points" href="#WavesAndEigenvalues.Meshutils.get_surface_points"><code>WavesAndEigenvalues.Meshutils.get_surface_points</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">surface_points, tri_mask, tet_mask = get_surface_points(mesh::Mesh,output=true)</code></pre><p>Get a list <code>surface_points</code> of all point indices that are on the surface of the mesh <code>mesh</code>. The corresponding lists <code>tri_mask and</code>tet_mask<code>contain lists of indices of all triangles and tetrahedra that are connected to the surface point. The optional parameter</code>output` toggles whether a progressbar should be shown or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L620-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}" href="#WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!-Tuple{WavesAndEigenvalues.Meshutils.Mesh}"><code>WavesAndEigenvalues.Meshutils.link_triangles_to_tetrahedra!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">link_triangles_to_tetrahedra!(mesh::Mesh)</code></pre><p>Find the tetrahedra that are connected to the triangles in mesh.triangles and store this information in mesh.tri2tet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L466-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.unify!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String,Vararg{Any,N} where N}" href="#WavesAndEigenvalues.Meshutils.unify!-Tuple{WavesAndEigenvalues.Meshutils.Mesh,String,Vararg{Any,N} where N}"><code>WavesAndEigenvalues.Meshutils.unify!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unify!(mesh::Mesh ,new_domain::String,domains...)</code></pre><p>Create union of <code>domains</code> and name it <code>new_domain</code>. <code>domains</code> must share the same dimension and <code>new_domain</code> must be a new name otherwise errors will occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L587-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.vtk_write-Tuple{String,WavesAndEigenvalues.Meshutils.Mesh,Dict}" href="#WavesAndEigenvalues.Meshutils.vtk_write-Tuple{String,WavesAndEigenvalues.Meshutils.Mesh,Dict}"><code>WavesAndEigenvalues.Meshutils.vtk_write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vtk_write(file_name, mesh, data)</code></pre><p>Write vtk-file containing the datavalues <code>data</code> given on the usntructured grid <code>mesh</code>.</p><p><strong>Arguments</strong></p><ul><li><code>file_name::String</code>: name given to the written files. The name will be preceeded by a specifier. See Notes below.</li><li><code>mesh::Mesh</code>: mesh associated with the data.</li><li><code>data::Dict</code>: Dictionairy containing the data.</li></ul><p><strong>Notes</strong></p><p>The routine automatically sorts the data according to its type and writes it in up to three diffrent files. Data that is constant on a tetrahedron goes into <code>&quot;$(filename)_const.vtu&quot;</code>, data that is linearly interpolated on a tetrahedron goes into <code>&quot;$(filename)_lin.vtu&quot;</code>, and data that is quadratically interpolated on a tetrahedron goes into <code>&quot;$(filename)_quad.vtu&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/vtk_write.jl#L238-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.SymInfo" href="#WavesAndEigenvalues.Meshutils.SymInfo"><code>WavesAndEigenvalues.Meshutils.SymInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple struct element to store additional information on symmetry for rotational symmetric meshes.</p><p>#Fields</p><ul><li><code>DOS::Int64</code>: degree of symmetry</li><li><code>naxis::Int64</code>: number of grid points lying on the center axis</li><li><code>nxbloch::Int64</code>: number of grid points lying on the Bloch plane but not on the center axis</li><li><code>nbody::Int64</code>: number of interior points in half cell</li><li><code>shiftbody::Int64</code>: difference from body point to reflected body point</li><li><code>nxsymmetry::Int64</code>: number of grid points on symmetry plane (without center axis)</li><li><code>nxsector::Int64</code>: number of grid points belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)</li><li><code>naxis_ln::Int64</code>: number of line segments lying on the center axis</li><li><code>nxbloch_ln::Int64</code>: number of line segments belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)</li><li><code>nxsector_ln::Int64</code>: number of line segments belonging to a unit cell (without cenetraxis, Bloch and Bloch image plane)</li><li><code>nxsector_tri::Int64</code>: number of surface triangles belonging to a unit cell (without Bloch and Bloch image plane)</li><li><code>nxsector_tet::Int64</code>: number of tetrahedra of a unit cell</li><li><code>n</code>: unit axis vector of the center axis</li><li>`pnt: foot point of the center axis</li><li><code>unit::Bool</code>: true if mesh represents only a unit cell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L8-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.compare-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.compare-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.compare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cmpr=compare(A,B)</code></pre><p>Compare two simplices following lexicographic rules. If B has lower rank, then A <code>cmpr ==-1</code>. If B has higher rank than A, <code>cmpr==1</code>. If A and B are identical, <code>cmpr==0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/sorter.jl#L2-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.create_rotation_matrix_around_axis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">R = create_rotation_matrix_around_axis(n,α)</code></pre><p>Compute the rotation matrix around the directional vector <code>n</code>rotating by an angle <code>α</code> (in rad).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.find_foot_of_perpendicular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">foot = find_foot_of_perpendicular(pnt,pln)</code></pre><p>Compute the position of the foot of the perpendicular from the point <code>pnt</code> to the plane <code>pln</code>.</p><p>#Notes Code adapted from https://www.geeksforgeeks.org/mirror-of-a-point-through-a-3-d-plane/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L53-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.find_intersection_of_two_planes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p,n = find_intersection_of_two_planes(pln1,pln2)</code></pre><p>Find a parametrization of the axis defined by the intersection of the planes <code>pln1</code>and <code>pln2</code>. The axis is parameterized by a point <code>p</code> and direction <code>n</code>.</p><p>#Notes The algorithm follows John Krumm&#39;s solution for finding a common point on two intersecting planes as it is explained in https://math.stackexchange.com/questions/475953/how-to-calculate-the-intersection-of-two-planes To simplify the code, here the point p0 is the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L81-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.find_smplx-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.find_smplx-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.find_smplx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">idx = find_smplx(list,smplx)</code></pre><p>Find index of simplex in ordered list of simplices. If the simplex is not contained in the list, the returned index is <code>nothing</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/sorter.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_line_idx-NTuple{7,Any}" href="#WavesAndEigenvalues.Meshutils.get_line_idx-NTuple{7,Any}"><code>WavesAndEigenvalues.Meshutils.get_line_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ln_idx = get_line_idx(ln,naxis_ln,nxsector_ln)</code></pre><p>Get index <code>ln_idx</code> of line <code>ln</code>  in a mesh that features <code>naxis</code> grid points and <code>naxis_ln&#39; lines on the center line,</code>nxsector<code>grid points and</code>nxsector_ln&#39; lines in a unit cell excluding the center axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_line_idx-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}" href="#WavesAndEigenvalues.Meshutils.get_line_idx-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}"><code>WavesAndEigenvalues.Meshutils.get_line_idx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ln_idx = get_line_idx(mesh::Mesh, ln)</code></pre><p>Get index <code>ln_idx</code> of line <code>ln</code> in mesh <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L598-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_line_sector-Tuple{Any,Any,Any}" href="#WavesAndEigenvalues.Meshutils.get_line_sector-Tuple{Any,Any,Any}"><code>WavesAndEigenvalues.Meshutils.get_line_sector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">s = get_line_sector(ln)</code></pre><p>Get index <code>s</code> of sector containing line <code>ln</code>, in a mesh that features <code>naxis</code> grid points on the center line and <code>nxsector</code> grid points in a unit cell excluding the center axis..</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L198-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_line_sector-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}" href="#WavesAndEigenvalues.Meshutils.get_line_sector-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}"><code>WavesAndEigenvalues.Meshutils.get_line_sector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sidx = get_line_sector(mesh::Mesh, ln)</code></pre><p>Get sector idx <code>sidx</code>of line <code>ln</code> in mesh <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L585-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_point_sector-Tuple{Any,Any,Any}" href="#WavesAndEigenvalues.Meshutils.get_point_sector-Tuple{Any,Any,Any}"><code>WavesAndEigenvalues.Meshutils.get_point_sector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sector = get_point_sector(pnt_idx,naxis, nxsector)</code></pre><p>Get the sector containing point with index <code>pnt_idx</code>, in a mesh that features <code>naxis</code> grid points on the center line and <code>nxsector</code> grid points in a unit cell excluding the center axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L183-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_point_sector-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}" href="#WavesAndEigenvalues.Meshutils.get_point_sector-Tuple{WavesAndEigenvalues.Meshutils.Mesh,Any}"><code>WavesAndEigenvalues.Meshutils.get_point_sector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sidx=get_point_sector(mesh::Mesh,pnt_idx)</code></pre><p>Get sector idx <code>sidx</code>of point with index <code>pnt_idx</code>in mesh <code>mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L572-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_reflected_index-NTuple{7,Any}" href="#WavesAndEigenvalues.Meshutils.get_reflected_index-NTuple{7,Any}"><code>WavesAndEigenvalues.Meshutils.get_reflected_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ridx = get_reflected_index(idx,naxis,nxbloch,nbody,shiftbody,nxsymmetry)</code></pre><p>Get index <code>ridx</code> of a point in the first unit cell created from reflection of the point with index <code>idx</code>. The definig mesh feature <code>naxis</code> points on the center axis, <code>nxbloch</code> points on the bloch plane (excluding the center axis), <code>nbody</code> points in the interiror of the first half-cell, <code>nxsymmetry</code>points on the symmetry plane (excluding the center axis) <code>nxsector</code> points in a unit cell excluding the center axis. The difference of the indeces of a refernce body point and a reflected body point is <code>shiftbody</code>. The number of points per unit cell (excluding the center axis) is <code>nxsector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L156-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.get_rotated_index-NTuple{5,Any}" href="#WavesAndEigenvalues.Meshutils.get_rotated_index-NTuple{5,Any}"><code>WavesAndEigenvalues.Meshutils.get_rotated_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ridx = get_rotated_index(idx,sector, naxis, nxsector, DOS)</code></pre><p>Get index <code>ridx</code> of point in sector <code>sector</code> created from rotation of the point with index <code>idx</code>. The definig mesh feature <code>naxis</code> points on the center axis, <code>nxsector</code> points in a unit cell excluding the center axis, and has a degree of symmetry <code>DOS</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L134-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.insert_smplx!-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.insert_smplx!-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.insert_smplx!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insert_smplx!(list,smplx)</code></pre><p>Insert simplex in ordered list of simplices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/sorter.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.is_point_in_plane-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.is_point_in_plane-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.is_point_in_plane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check = is_point_in_plane(pnt, pln)</code></pre><p>Check whether point &quot;pnt&quot; is in plane . Note that there is currently no handling of round off errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.make_normal_outwards!-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.make_normal_outwards!-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.make_normal_outwards!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>make<em>normal</em>outwards!(pln,testpoint)</p><p>Ensure that the parameterization of the plane &quot;pln&quot; has a normal that is directed twoards <code>testpoint</code>. If necessary reparametrize <code>pln</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.read_ansys-Tuple{Any}" href="#WavesAndEigenvalues.Meshutils.read_ansys-Tuple{Any}"><code>WavesAndEigenvalues.Meshutils.read_ansys</code></a> — <span class="docstring-category">Method</span></header><section><div><p>read a mesh from ansys cfx file</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.read_msh2-Tuple{Any}" href="#WavesAndEigenvalues.Meshutils.read_msh2-Tuple{Any}"><code>WavesAndEigenvalues.Meshutils.read_msh2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">points, lines, triangles, tetrahedra, domains=read_msh2(file_name)</code></pre><p>Read gmsh&#39;s .msh-format version 2. This is an old format and wherever possible version 4 should be used.</p><p>http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L360-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.read_msh4-Tuple{Any}" href="#WavesAndEigenvalues.Meshutils.read_msh4-Tuple{Any}"><code>WavesAndEigenvalues.Meshutils.read_msh4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">points, lines, triangles, tetrahedra, domains=read_msh4(file_name)</code></pre><p>Read gmsh&#39;s .msh-format version 4.</p><p>http://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/Meshutils.jl#L220-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.reflect_point_at_plane-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.reflect_point_at_plane-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.reflect_point_at_plane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p = reflect_point_at_plane(pnt,pln)</code></pre><p>Reflect point <code>pnt</code> at plane <code>pln</code> and return as <code>p</code>.</p><p>#Notes Code adapted from https://www.geeksforgeeks.org/mirror-of-a-point-through-a-3-d-plane/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.sort_smplx-Tuple{Any,Any}" href="#WavesAndEigenvalues.Meshutils.sort_smplx-Tuple{Any,Any}"><code>WavesAndEigenvalues.Meshutils.sort_smplx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_smplx(list,smplx)</code></pre><p>Helper function for sorting simplices in lexicographic manner. Utilize divide an conquer strategy to find a simplex in ordered list of simpleces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/sorter.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavesAndEigenvalues.Meshutils.three_points_to_plane-Tuple{Any}" href="#WavesAndEigenvalues.Meshutils.three_points_to_plane-Tuple{Any}"><code>WavesAndEigenvalues.Meshutils.three_points_to_plane</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pln=three_points_to_plane(A)</code></pre><p>Compute equation for a plane from the three points defined in A. The plane is parameterized as <code>a*x+b*y+c*z+d==0</code> with the coefficients returned as <code>pln=[a,b,c,d]</code>.</p><p>#Arguments</p><ul><li>A::3×3-Array : Array containing the three points defining the plane as columns.</li></ul><p>#Notes Code adapted from https://www.geeksforgeeks.org/program-to-find-equation-of-a-plane-passing-through-3-points/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JulHoltzDevelopers/WavesAndEigenvalues.jl/blob/5f4af0ca970efb76ee6427a0a111b6d99b8b9c55/src/annular_meshes.jl#L2-L13">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="Helmholtz.html">Helmholtz »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 8 June 2020 16:38">Monday 8 June 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
